{"id":"3Jheb3FyCEtx7o61cc6N6","title":"Reddit - NetSec","displayTitle":"Reddit - NetSec","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":8,"items":[{"title":"Quantifying Swiss Cheese, the Bayesian Way","url":"https://stephenshaffer.io/quantifying-swiss-cheese-the-bayesian-way-b2b512472d85","date":1762021252,"author":"/u/t0sche","guid":103301,"unread":true,"content":"<p><strong>The Exploit Prediction Scoring System (EPSS)</strong> is a machine-learning model that publishes the likelihood of a CVE being exploited within the next thirty (30) days. Each CVE gets a likelihood value between 0 and 1 — the higher the score, the greater the chance of exploitation.</p><p> (or Grouped EPSS) is the probability that  (1) vulnerability on a given asset will see exploitation activity in the next thirty (30) days. We calculate it using the classic <a href=\"https://www.statology.org/probability-of-at-least-one-success/\" rel=\"noopener ugc nofollow\" target=\"_blank\">“at least one”</a> formula from probability theory. If each CVE  has probability EPSS, then the probability that none are exploited is the product of their non-exploitation probabilities (the inverse of the EPSS score). Subtracting from 1 gives us the probability of at least one CVE, which I call:</p><p>This provides a baseline probability of exploitation for each asset — assuming no controls. It’s a “worst-case exposure” measure. So how do we factor in our security controls?</p><p>Think of your organization’s defenses as layers of Swiss cheese. Each layer has some holes (no control is 100% effective), but multiple layers together can reduce the chance of an attacker slipping through all of them. This is the <a href=\"https://en.wikipedia.org/wiki/Swiss_cheese_model\" rel=\"noopener ugc nofollow\" target=\"_blank\">classic  of risk management</a>. If the holes (control failures) don’t line up, the threat is stopped; only when all holes align does the bad outcome occur.</p><p>This is where Bayesian inference enters the picture. Applying this to exploit likelihood means we can treat each control as a probabilistic filter that reduces the base exploitation likelihood from EPSS. To do this rigorously, we need a way to quantify how effective each layer is — and to update that belief over time.</p><p>No model mirrors reality perfectly — but building a quantifiable starting point lets us iteratively align our assumptions with new evidence.</p><p>Let’s dive into a few assumptions we need to establish.</p><ol><li>EPSS is representative of global exploitation pressure, a proxy for attacker behavior across the internet</li><li>Vulnerabilities with a CVE are not the only vulnerabilities in our software. EPSS covers only CVE-tagged vulnerabilities, a large but incomplete subset of all flaws. Still, it’s the only publicly available probabilistic dataset, making it the most practical foundation.</li><li>Grouped EPSS (EPSS) is the public exploit pressure on this asset if it were on the public internet.</li><li>Control Effectiveness rates assume that given the population of vulnerabilities, the control prevents exploitation % of the time. Controls are treated as independent layers — an assumption we can later test with telemetry.</li></ol><p>With those assumptions set, we can start quantifying how much each defensive slice of cheese actually helps.</p><h2>Modeling Control Effectiveness</h2><p>In this context, I define control effectiveness as the probability that a given control prevents the exploitation of a vulnerability. Think of it as the defensive success rate for a specific layer.</p><ul><li>A network firewall might block 70% of exploit attempts.</li><li>Assuming their effects are roughly independent, combined coverage could push actual likelihood well below the baseline.</li></ul><p>But how do we know those percentages?</p><p>We usually don’t. Vendor claims are vague, telemetry can be incomplete, and empirical data is scarce. So we start with informed estimates — structured, measurable beliefs we can later update with data.</p><p>One practical way to form our initial belief (the ) is to survey subject matter experts (SMEs) about control performance. Even if imperfect, this exercise builds a culture of quantitative reasoning and provides the starting point for Bayesian updating.</p><p>That notion aside, we can construct a survey question using a scenario that accounts for our assumptions:</p><blockquote><p>Given an asset with 10 vulnerabilities present behind a well-configured firewall, how many does the firewall prevent the exploitation of?</p></blockquote><p>In this context, we can define well-configured as one that meets our internal standards (e.g., signatures current, traffic monitored, rule sets tuned).</p><p>The answer options are integers between 0 and 10. Drawing on inspiration from <a href=\"https://bookshop.org/p/books/how-to-measure-anything-in-cybersecurity-risk-douglas-w-hubbard/d036aad27b7106de?ean=9781119892304&amp;next=t&amp;utm_source=google&amp;utm_medium=pmax&amp;utm_campaign=16243454879&amp;utm_content=&amp;utm_term=%7Bsearchterm%7D&amp;gad_source=1&amp;gad_campaignid=16235479093&amp;gbraid=0AAAAACfld43qAmRSgNoVzQDlZbkfrlVI9&amp;gclid=Cj0KCQjwsPzHBhDCARIsALlWNG1CCQKNy7ut8TdadjpOxc3shfHrfQgIgA-X1ktz-X9d5y2mffsYYf0aAoQmEALw_wcB\" rel=\"noopener ugc nofollow\" target=\"_blank\"><em>How to Measure Anything in Cybersecurity Risk</em></a>and <a href=\"https://www.amazon.com/Prove-Confronting-Security-Data/dp/111951536X\" rel=\"noopener ugc nofollow\" target=\"_blank\"></a>, we ask twice: once for the median estimate (we directly ask our SMEs for an answer to the question and assume it’s the median value), and again for the 90th-percentile value — the number they’re 90% confident the true effectiveness is below.</p><p>We then weight responses by self-rated expertise on a Likert scale (1 = novice, 5 = expert), producing both equal-weight and expertise-weighted models.</p><p>Let’s say for demonstration purposes that we survey 12 SMEs. An example of those responses is below:</p><p>In order to analyze this data, we turn to the <a href=\"https://en.wikipedia.org/wiki/Beta_distribution\" rel=\"noopener ugc nofollow\" target=\"_blank\">Beta distribution</a>. The Beta distribution is ideal for representing probabilities between 0 and 1 when we have uncertainty. The Beta distribution accepts two parameters:</p><ul><li>α (alpha) which is equal to the number of successes + 1</li><li>β (beta) which is equal to failures + 1</li></ul><p>In simple terms, α and β shape the curve describing how confident we are about control success and failure rates.</p><p>Our challenge is to infer α and β from SME p50 and p90 values. In Python, we can use  from  to reverse-engineer the Beta parameters that produce those percentiles.</p><pre></pre><p>This function finds α and β whose cumulative distribution matches our SME-reported medians and 90th percentiles. By running this across all SME responses, we can build aggregate Beta distributions — both equally weighted and expertise-weighted versions — to visualize our shared belief about the control’s effectiveness and show the shape of our uncertainty.</p><p>These distributions give us multiple values to pick for our central tendency single point value. In this scenario, I usually pick the lowest value in order to remain conservative with our judgments and overstate risk. Based on our example here, I would select a firewall control effectiveness rate for exploit prevention of 0.44, the expertise-weighted median value. The wide spread reminds us that uncertainty remains high until we gather more data.</p><h2>Updating our Beliefs: The Bayesian Way</h2><h3>Integrating Control Effectiveness with EPSSg</h3><p>Once we have a control effectiveness rate, we can update our asset-level exploit likelihood by multiplying it by the inverse of our control effectiveness rate (our control failure rate).</p><p>If an asset’s EPSS is 0.76 and our firewall effectiveness posterior mean is 0.44, then:</p><p>That’s a 42% adjusted exploit likelihood — more realistic than assuming total exposure.</p><h3>Continuously Updating Control Effectiveness</h3><p>Now that we have our initial beliefs quantified, we can now update them with observations. Observation data can come in many forms, and for the firewall effectiveness example, we can likely look at our firewall logs to find exploit-related events. We could formulate a system that parses these logs and picks out the events that were successes and failures, depending on what type of logic an organization wants to implement.</p><p>For our example here, let’s say we observe 15 successful exploit prevention events from our firewall logs, and 5 unsuccessful events in the next month. Using the reverse-engineered alpha and beta values from our expertise-weighted Beta distribution, we update our beliefs like so:</p><p>Below is the resulting Beta distribution. The central tendency (our updated best estimate of control effectiveness) increased from 0.44 to 0.703, meaning we’ve gained confidence that the firewall blocks about 70.3% of exploit attempts. Our confidence interval also tightened.</p><p>We can then turn around and make yet another update to our exploit likelihood on the asset (In practice, EPSS updates daily, so the asset’s baseline likelihood will shift as well.):</p><h3>From Static to Living Models</h3><p>This process transforms our exploit likelihood model into a living system that evolves as evidence accumulates. Observation sources include:</p><ul><li>Firewall and EDR telemetry — blocked vs. successful exploit attempts</li><li>Breach and attack simulation tools like </li><li>Red team or purple team exercises</li><li>Incident reports tied to control failures</li><li>Any feedback loop that distinguishes success from failure can feed the model</li></ul><p>Each update shifts our posterior a little closer to reality. Over time, our understanding of “how holey our cheese really is” becomes quantifiable.</p><p>A shared, continuously updated model lets all stakeholders align on reality and make smarter decisions about time, effort, and budget.</p><p>In vulnerability management, our goal is to reduce exploit risk. By quantifying control effectiveness transparently, we strengthen trust in both the model and the decisions it supports.</p><p>If you’re familiar with <a href=\"https://www.fairinstitute.org/hubfs/An%20Overview%20of%20FAIR-CAM.pdf\" rel=\"noopener ugc nofollow\" target=\"_blank\">FAIR-CAM</a> (Factor Analysis of Information Risk — Controls Analytics Model), you’ll recognize the conceptual overlap. FAIR-CAM formalizes how individual control functions combine to influence overall loss event frequency.</p><p>I view what I outline here as  — a focused, quantitative slice of that same principle, applied specifically to exploit prevention. Instead of modeling every control family, we’re zooming in on how a single control’s effectiveness updates our belief in exploit likelihood through Bayesian inference. It’s a practical on-ramp for teams not yet ready for full FAIR-CAM implementation.</p><p>The structure is identical in spirit:</p><ul><li> represents  (global exploit pressure).</li><li> functions as  (how often the control stops that pressure).</li><li> mirrors FAIR-CAM’s goal of adjusting control factors as evidence accumulates.</li></ul><p>In other words, this framework is an applied subset of FAIR-CAM — one that demonstrates how you can begin quantifying and updating control performance today, even before a full FAIR-CAM implementation.</p><p>What I demonstrated here was the use of a single control’s effectiveness in reducing exploitation likelihood. However, organizations usually have multiple controls in place, and FAIR-CAM accounts for this. We can borrow that logic and apply it directly to this scenario by building additional control effectiveness models to update the exploit likelihood in succession:</p><h3>Exploit Vector Incident Likelihood</h3><p>What if we could model the likelihood of an incident that includes exploitation within our environment? Where would we start, and how could we continuously update this model with observations? These questions point toward a vulnerability-to-incident pipeline, a frontier I am currently exploring.</p><blockquote><p>We can’t eliminate uncertainty — but we can measure it, update it, and communicate it.</p></blockquote><p>Bayesian updating gives us a disciplined way to evolve our beliefs as evidence accumulates. By pairing EPSS (our view of global exploit pressure) with quantified control effectiveness, we move from static assumptions to a dynamic, evidence-driven model.</p><p>Each layer of Swiss cheese becomes a measurable probability curve — not just a metaphor, but a quantifiable defense system we can track, test, and improve.</p>","contentLength":10781,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1oluzam/quantifying_swiss_cheese_the_bayesian_way/"},{"title":"open source CVE scanner for project dependencies. VSCode extension.","url":"https://marketplace.visualstudio.com/items?itemName=abhishekrai43.vulscan-mcp-vscode","date":1762007554,"author":"/u/FeelingResolution806","guid":103245,"unread":true,"content":"<p><strong>Find and fix security vulnerabilities in your project dependencies - right inside VS Code!</strong></p><p>VulScan-MCP automatically scans your project dependencies for known security vulnerabilities (CVEs) and provides clear, step-by-step instructions to fix them. Just ask Copilot about security, and it handles the rest!</p><ul><li>🔍  - Checks NVD and OSV databases for latest vulnerabilities</li><li>📦  - npm, pip, Maven, Go, Cargo, Composer, and more</li><li>🎯  - No commands to remember, just ask naturally</li><li>📝  - Get step-by-step remediation guidance</li><li>🚫  - Never modifies your code automatically</li><li>🌍  - Works on Windows, macOS, and Linux</li></ul><p>Open VS Code and install:</p><ol><li>Press  (Windows/Linux) or  (macOS)</li><li>Search for <strong>\"VulScan-MCP Security Scanner\"</strong></li></ol><ul><li> - Required for MCP integration</li></ul><p> The extension automatically:</p><ul><li>Detects your Python installation</li><li>Installs required dependencies on first use</li><li>Registers the MCP server with Copilot</li><li>Works immediately - no configuration needed!</li></ul><p>Simply ask Copilot Chat about security:</p><pre><code>\"Check for vulnerabilities\"\n\"Scan my dependencies\"\n\"Any security issues?\"\n</code></pre><p>The first time you use it, it may take a few seconds to install dependencies (requests library). After that, it's instant!</p><p>After scanning, you'll get a detailed report like this:</p><pre><code># VulScan-MCP Vulnerability Report\n\n## Summary\n- Total Dependencies Scanned: 87\n- Vulnerable Dependencies: 2\n- Manifest Files Found: 2\n\n### Scanned Files:\n- `package.json` at `/frontend/package.json`\n- `requirements.txt` at `/backend/requirements.txt`\n\n## Vulnerabilities Found\n\n### HIGH Severity\n\n#### lodash @ 4.17.15\n- **Severity:** HIGH\n- **CVEs Found:** 3 (OSV) + 2 (NVD)\n- **Fix:** Upgrade to version 4.17.21 or later\n\nWARNING: This fix requires a version upgrade. Test thoroughly \nin a staging environment before deploying to production.\n\n### MEDIUM Severity\n\n#### tslib @ ^2.3.0\n- **Severity:** MEDIUM\n- **CVEs Found:** 1 (NVD)\n- **Fix:** Upgrade to version 2.6.0 or later\n\n## Recommendations\n\n1. **Prioritize HIGH and CRITICAL severity vulnerabilities**\n2. **Test all updates in a staging environment first**\n3. **Review changelogs before upgrading**\n4. **Run your full test suite after updates**\n5. **Monitor for new vulnerabilities regularly**\n</code></pre><h2>Supported Package Managers</h2><table><thead><tr></tr></thead><tbody><tr><td>, , </td></tr><tr></tr></tbody></table><h3>Simple Questions That Work</h3><p>Just ask Copilot Chat naturally:</p><p><strong>\"Check for vulnerabilities\"</strong></p><p>The extension automatically activates - no need to mention \"MCP\" or \"tool\"!</p><ol><li> - Finds all dependency files in your project</li><li> - Queries NVD and OSV databases for CVEs</li><li> - Shows vulnerabilities grouped by severity</li><li> - Provides clear remediation instructions</li></ol><ul><li>PowerShell or Command Prompt</li><li>Python from Microsoft Store or python.org</li></ul><ul><li>Intel and Apple Silicon (M1/M2/M3)</li><li>Python via Homebrew or system Python</li></ul><ul><li>Ubuntu, Debian, Fedora, Arch</li><li>Python 3.11+ from package manager</li></ul><ul><li> - All scanning happens on your machine</li><li> - Your code stays private</li><li> - Full transparency</li><li> - Only checks public CVE databases</li></ul><p>Your code never leaves your computer!</p><h3>\"MCP server not available in Copilot\"</h3><ol><li>Ensure you have  of this extension installed</li><li>Reload VS Code window ( → \"Developer: Reload Window\")</li><li>The server registers automatically - no settings.json configuration needed!</li></ol><p>Make sure  or  command works in your terminal:</p><pre><code>python --version  # or python3 --version\n</code></pre><ol><li>Ensure GitHub Copilot is installed and active</li><li>Reload VS Code ( → \"Reload Window\")</li><li>Check Python version:  (should be 3.11+)</li><li>First scan may take 10-20 seconds while installing dependencies</li></ol><ul><li>Check your internet connection (needed for CVE databases)</li><li>Ensure you have dependency files (package.json, requirements.txt, etc.)</li><li>Try scanning again - APIs may have rate limits</li></ul><p><em>Powered by NVD, OSV, and the Model Context Protocol</em></p>","contentLength":3595,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1olpb18/open_source_cve_scanner_for_project_dependencies/"},{"title":"r/netsec monthly discussion & tool thread","url":"https://www.reddit.com/r/netsec/comments/1olp81v/rnetsec_monthly_discussion_tool_thread/","date":1762007343,"author":"/u/albinowax","guid":103244,"unread":true,"content":"<p>Questions regarding netsec and discussion related directly to netsec are welcome here, as is sharing tool links.</p><ul><li>Always maintain civil discourse. Be awesome to one another - moderator intervention will occur if necessary.</li><li>Avoid NSFW content unless absolutely necessary. If used, mark it as being NSFW. If left unmarked, the comment will be removed entirely.</li><li>If linking to classified content, mark it as such. If left unmarked, the comment will be removed entirely.</li><li>Avoid use of memes. If you have something to say, say it with real words.</li><li>All discussions and questions should directly relate to netsec.</li><li>No tech support is to be requested or provided on <a href=\"https://www.reddit.com/r/netsec\">r/netsec</a>.</li></ul><p>As always, the content &amp; discussion guidelines should also be observed on <a href=\"https://www.reddit.com/r/netsec\">r/netsec</a>.</p><p>Feedback and suggestions are welcome, but don't post it here. Please send it to the moderator inbox.</p>","contentLength":839,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"EDR-Redir V2: Blind EDR With Fake \"Program Files\"","url":"https://www.zerosalarium.com/2025/11/EDR-Redir-V2-Blind-EDR-With-Fake-Program-Files.html","date":1761994335,"author":"/u/Cold-Dinosaur","guid":103199,"unread":true,"content":"<p>\n  In previous articles, I demonstrated using Windows' bind link feature to block\n  or redirect Antivirus/EDR from accessing their executable folder. You can\n  review this article via the link:\n</p><p>\n  However, some EDRs provide good protection for their operating folders,\n  resulting in failed bind link creation.\n</p><p>\n  This time, <b>I will upgrade EDR-Redir to version V2</b>. Of course, I will\n  still use bind link technology, but in a completely different way.\n</p><p>\n  I will experiment with EDR-Redir V2 using Windows Defender on Windows 11. With\n  this new approach, I'm quite confident it will work with many Antivirus/EDR\n  solutions.\n</p><h3>1. The Idea Behind Working With EDR-Redir V2</h3><p>\n  When software is installed on Windows, it typically resides in a subfolder,\n  such as , , ,\n  and so on.\n</p><p>\n  Antivirus and EDR software are no exception; most of them are located in\n  either  or . Windows Defender,\n  however, is found in .\n</p><p>\n  Antivirus and EDRs, in order to protect their operating folders, typically\n  prevent writing files there. However,\n  <b>they cannot stop file writing to their parent folder</b>. For example, if\n  they block writing to the  folder, they inadvertently\n  prevent other software from being installed on the machine, which can cause\n  significant inconvenience for users.\n</p><p><b>So why not think outside the box?</b> Instead of creating a bind link to\n  the EDR's folder, we could\n  <b>create a bind link to the Program Files folder</b>, for example.\n</p><p>\n  When dealing with the Program Files folder, we encounter the issue of ensuring\n  that other software, aside from the EDR, functions normally.\n  <b>The idea here is to create bind links so that a folder points back to\n    itself.</b></p><p>\n  The steps to implement this idea are as follows (I will provide an example\n  using the  folder):\n</p><ol><li>Query all the folders within the Program Files folder.</li><li>\n    Create corresponding folders in a location you fully control\n    ().\n  </li><li>\n    Create bind links from the folders in Program Files that point to their\n    corresponding folders in .\n  </li><li>\n    Continue creating bind links from  that point to the\n    corresponding folders in Program Files. This will create a loop, causing\n    access to the folders in Program Files to circle back to themselves. Most\n    importantly, we will not create a bind link for the EDR's folder at this\n    stage.\n  </li><li>\n    Create a bind link from Program Files to  to force the\n    redirection of the EDR's folder through .\n  </li><li>\n    At this point, you can perform DLL hijacking by dropping executable files\n    that the EDR usually interacts with into , allowing you to\n    leverage them to activate in place of the EDR.\n  </li></ol><p>\n  Once these steps are successfully completed, we may be able to effectively\n  redirect even the most stubborn types of EDRs.\n</p><h3>\n  2. Experimenting With EDR-Redir V2 Using Windows Defender\n</h3><p>First, you can download  via the link below.</p><p><a href=\"https://amzn.to/4hDLIBG\" target=\"_blank\">Windows Defender</a> on\n  Windows 11 is located at <b>C:\\ProgramData\\Microsoft\\</b>. Therefore, I will\n  target this folder for the attack.\n</p><p>I will run  with the following parameters:</p><p><code>\n    EDR-Redir.exe C:\\ProgramData\\Microsoft c:\\TMP\\TEMPDIR\n    \"C:\\ProgramData\\Microsoft\\Windows Defender\"\n  </code></p><p> is the folder I need to redirect elsewhere.\n</p><p> is the target folder.</p><p><b> C:\\ProgramData\\Microsoft\\Windows Defender</b> is the exception folder; it\n  will not have a link loop created to block\n  <a href=\"https://amzn.to/4hDLIBG\" target=\"_blank\">Defender</a>.\n</p><p>\n  During execution, EDR-Redir will print to the console information about which\n  bind links will be created for easier monitoring. As shown in the results, I\n  successfully redirected Windows Defender to C:\\TMP\\TEMPDIR.\n</p><p>\n  At this point, Windows Defender will always see the folder\n   as the parent folder of its operating folder.\n</p><p>\n  Antivirus/EDR can only protect their operating folders; they cannot intervene\n  in the parent folders of these directories. Once the parent folder is\n  successfully attacked, the protection of the operating folders by the EDR\n  becomes meaningless.\n</p><p>\n  When programming, many developers may not consider the possibility of a folder\n  like Program Files being redirected. Therefore, I suspect that the list of\n  EDRs affected by this technique will be quite extensive.\n</p><p><a href=\"https://amzn.to/47iXD4j\" target=\"_blank\">The defensive approach</a>\n  is to monitor the use of bind links with folders like Program Files to ensure\n  they aren't tampered with by the hands of attackers.\n</p><p><b>Some books you should read to sharpen your cybersecurity skills, especially\n    in offensive security:</b></p><p><b></b></p>","contentLength":4379,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1olkuwg/edrredir_v2_blind_edr_with_fake_program_files/"},{"title":"Automating COM/DCOM vulnerability research","url":"https://www.incendium.rocks/posts/Automating-COM-Vulnerability-Research/","date":1761855847,"author":"/u/TangeloPublic9554","guid":102535,"unread":true,"content":"<p>COM (Component Object Model) and DCOM (Distrubuted COM) have been interesting components in Windows from a security perspective for many years. In the past, COM has been a target for many purposes. Not only have many vulnerabilities been discovered in COM, but it is also used for lateral movement or bypassing techniques.</p><p>Because of this, many (security) research is already conducted in this area. So to look for new vulnerabilities or techniques, another approach would probably lead to better results (vulnerabilities). I couldn’t find any tooling/blogs related to fuzzing COM/DCOM, but correct me if I’m wrong. As fuzzing MS-RPC <a href=\"https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/\">was proven to be a successful</a> approach to discovering new vulnerabilities, I wondered if the same concept could be applied to COM/DCOM.</p><p>I decided to write a fuzzer around the <a href=\"https://github.com/tyranid/oleviewdotnet\">OleViewDotNet</a> tool from <a href=\"https://x.com/tiraniddo\">James Forshaw</a>. The tool is mainly known for it’s GUI (Graphical User Interface). However, it’s power really comes with working with the command line options, more on this topic later.</p><p>This white paper describes how COM/DCOM works and what complications it has. In the next chapters, the white paper will describe how security research can be automated using the fuzzing approach. Since this approach comes with some problems, it describes how these problems were overcome (at least partially).</p><p>The white paper continues to describe what capabilities the COM fuzzer has and discusses some examples. Finally, the white paper will share some results and discuss how the fuzzer can be improved.</p><p>Essentially, COM solves a problem for developers. In the early days of Windows, software developers faced a major interoperability. Different applications were written in different languages (C, C++, Visual Basic, etc.). There was no standard way for programs or components to talk to each other or reuse code across applications. Developers often had to recompile or rewrite code just to use it in another program.</p><p>COM (Component Object Model) is Microsoft’s technology for building binary software components that can interact with each other, regardless of the programming language they were created in.</p><pre><code>graph TD\n    A1[\"C++ Component&lt;br/&gt;(e.g., Shape.dll)\"]\n    A2[\"Visual Basic App\"]\n    A3[\"Python Script\"]\n    A4[\"C# Application\"]\n\n    B1[\"COM Runtime&lt;br/&gt;(Component Object Model)\"]\n    B2[\"Common Binary Interface&lt;br/&gt;(IUnknown, Interfaces, GUIDs)\"]\n\n    A1 --&gt; B2\n    A2 --&gt; B2\n    A3 --&gt; B2\n    A4 --&gt; B2\n\n    B2 --&gt; B1\n\n    B1 --&gt; C1[\"Interoperable Object Communication\"]\n    C1 --&gt; C2[\"Language-Independent Reuse&lt;br/&gt;of Components\"]\n</code></pre><p>COM has a few core ideas that are necessary to get familiar with to understand how COM works. The first one are interfaces.</p><p>A COM object exposes functionality through interfaces. Each interface is identified by a GUID (Globally Unique Identifier). COM Clients don’t care how the object is implemented since they just call methods via its interface. The interface ensures that the client and server communicate using the same rules. It uses the Interface Definition Language (IDL) to create an interface. Consider the following example interface:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>All COM interfaces inherit from a fundamental base interface called , which defines three methods:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>The  gets pointers to other interfaces and ,  manage the object’s lifetime.</p><p>A COM Class is the actual implementation of one or more interfaces, and it is the blueprint for creating a COM object. It defines the functionality (methods and properties) available in the COM component. Every COM Class is uniquely identified by a Class ID (CLSID), which is a Globally Unique Identifier (GUID).</p><p>A client application uses the CLSID to ask the COM runtime (via functions like ) to instantiate an object of that specific class. CLSIDs are registered under the  key in the Windows Registry, pointing to the location of the actual component (DLL or EXE).</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n</pre></td><td><pre></pre></td></tr></tbody></table></code></div></div><p>The ProgID (Programmatic Identifier) is a user-friendly, human-readable string that serves as an alias for a COM Class’s CLSID. It provides an easy-to-use name for creating a COM object, often used in scripting languages like VBScript’s . ProgID’s typically follows the pattern: <code>&lt;Program&gt;.&lt;Component&gt;.&lt;Version&gt;</code>. Example: .</p><p>There are also version-independent ProgID’s that omit the version, example: . ProgIDs are registered under , and each ProgID key contains a subkey that maps it back to its corresponding CLSID.</p><p>The AppID is a GUID that uniquely identifies a COM server (the executable or DLL that hosts one or more COM Classes) for configuration purposes. Essentially, it’s an identifier that groups multiple related COM classes.</p><p>DCOM builds upon the core COM architecture by adding a network protocol layer, making remote object access feel like local access. DCOM primarily uses <a href=\"https://en.wikipedia.org/wiki/Microsoft_RPC\">Remote Procedure Call (RPC)</a> over network protocols like TCP/IP to facilitate communication between the client process and the object’s server process, which are on separate machines.</p><p>Proxies and stubs are used to enable a client on one machine to call a method on an object on another machine. A Proxy object is created on the client machine. The client calls methods on this local proxy object. The proxy packages the method call arguments, sends them across the network using RPC (marshalling), and waits for a response.</p><p>The client requests the object’s creation using the CLSID or ProgID. The local COM Service Control Manager (SCM) contacts the SCM on the remote machine to locate, authenticate, and launch the COM server process (EXE), which then creates the object.</p><pre><code>graph TD\n    A[Client Application] --&gt; B[COM Interface / Proxy]\n    B --&gt;|Local Call| C[Local COM Object&lt;br&gt;]\n    \n    B --&gt;|Remote Call via RPC| D[Network Layer&lt;br&gt; which is RPC over TCP/IP]\n    D --&gt; E[Remote Machine&lt;br&gt;DCOM Server Process]\n    E --&gt; F[COM Object Stub]\n\n    %% Labels\n    subgraph Local_Machine[Local Machine]\n        A\n        B\n        C\n    end\n\n    subgraph Remote_Machine[Remote Machine]\n        E\n        F\n    end\n</code></pre><p>When a COM class is defined, it represents a blueprint for creating COM objects. When a client application wants to use a COM object, it calls a function like , passing in the CLSID of the class and the interface it needs. This call is handled by the Service Control Manager (SCM), the COM service responsible for locating and activating the appropriate component.</p><p>The SCM checks the registry to determine whether the COM server is local or remote, and whether it runs as a DLL or an executable. If it’s a DLL, the SCM loads it directly into the client’s process. If it’s an EXE, it starts the executable (if not already running) and establishes communication with it.</p><pre><code>sequenceDiagram\n    participant Client\n    participant SCM\n    participant Server\n    participant ClassFactory\n    participant Object\n\n    Client-&gt;&gt;SCM: CoCreateInstance(CLSID)\n    SCM-&gt;&gt;Server: Load/start COM server (DLL or EXE)\n    Server-&gt;&gt;ClassFactory: DllGetClassObject(CLSID)\n    ClassFactory-&gt;&gt;Object: CreateInstance()\n    Object--&gt;&gt;Client: Return interface pointer (e.g., IMyInterface*)\n</code></pre><p>Using PowerShell reflection, we can create a COM object from a CLSID.</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n</pre></td><td><pre></pre></td></tr></tbody></table></code></div></div><h2><a href=\"https://www.incendium.rocks/posts/Automating-COM-Vulnerability-Research/#chapter-2--oleviewdotnet\"></a></h2><p>Working with COM classes using the registry is quite inconvenient. This is where the tool <a href=\"https://github.com/tyranid/oleviewdotnet\">OleViewDotNet</a> comes in. This is a .net OLE/COM viewer and inspector to merge functionality of <a href=\"https://learn.microsoft.com/en-us/windows/win32/com/ole-com-object-viewer\">OleView</a>.</p><p>It allows you to find COM objects through a number of different views (e.g., by CLSID, by ProgID, by server executable), enumerate interfaces on the object and then create an instance and invoke methods. It also has a basic container to attack ActiveX objects to so you can see the display output while manipulating the data.</p><p>The tool comes with a GUI that most people use when researching COM. However, the cmdlets accessible from PowerShell provide far more flexibility from a researching perspective.</p><p>Most of the cmdlets of OleViewDotNet parse a COM database that contains a set of classes. These classes can be gathered using :</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n</pre></td><td><pre></pre></td></tr></tbody></table></code></div></div><p>Here we get the first 10 COM classes that  gathered. Now it’s going to get annoying if every time you want to look at some COM information you need to run the lengthy Get-ComDatabase command. That’s why a simple save and reload feature was implemented. Running the following command will write the current database out to the default database location:</p><p>This is where things get more complicated, but it also is the reason the newer features of OleViewDotNet make a solid base for a fuzzer. In order to actually invoke COM procedures, we need a COM client to do so.</p><p>As explained by James Forshaw: The <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/rpcproxy/nf-rpcproxy-ndrproxyinitialize\">NdrProxyInitialize</a> function can be used to obtain the COM interface from its  structure by passing in the interface pointer to a proxy. Although this approach is not as flexible as a fully custom implementation, it provides a straightforward way to manage the transport layer without concern for platform or protocol differences. It can also operate with an existing COM object by querying the appropriate interface, extracting the buffer, and making calls to the remote server.</p><p>In order to create a COM client for an interface, we first create a new COM object from a CLSID and gather its interface ID’s using:</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n</pre></td><td><pre></pre></td></tr></tbody></table></code></div></div><p>Next, we pick one of the interface ID’s, example <code>866738b9-6cf2-4de8-8767-f794ebe74f4e</code> and create the client:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>Listing the members of the client object reveals its procedures:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>Finally, we can execute the procedure, for example  using:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>And this opens the calculator app.</p><pre><code>flowchart TD\n  A([Start])\n  A --&gt; B[Create COM object&lt;br/&gt;]\n  B --&gt; C[Enumerate interfaces&lt;br/&gt;]\n  C --&gt; D[Pick an IID&lt;br/&gt;]\n  D --&gt; E[Create COM client for IID]\n  E --&gt; F[Inspect client members&lt;br/&gt;]\n  F --&gt; G[Invoke procedure]\n  G --&gt; H([Result: Calculator opens / remote call executed])\n\n  %% Side-note about NdrProxyInitialize\n  subgraph NOTE[ ]\n    N1([\"NdrProxyInitialize: obtain COM interface from a MIDL_STUB_MESSAGE\"])\n  end\n  E -.-&gt; N1\n  style NOTE fill:#fff3cd,stroke:#e6b800,stroke-width:1px\n  style A fill:#e3f2fd,color:#000\n  style H fill:#e8f5e9,color:#000\n</code></pre><p>IDispatch is a fundamental COM interface, that allows scripting languages (VB, PowerShell) and higher-level languages (.NET) to interact with COM objects that implement it without prior knowledge. It achieves this by exposing unified methods that describe and interact with the implementing object.  maps names of methods or properties to an integer value named DISPID.</p><p>Our above example included the IDispatch interface:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>This is the reason our COM client was able to map the name of the methods/procedures, like . But not every COM class/object includes this interface. Proxies lose name information when compiled from MIDL to their C marshaled representation. Therefore, OleViewDotNet just generates placeholder names, for example, method names are of the form .</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n</pre></td><td><pre></pre></td></tr></tbody></table></code></div></div><p>If the proxy is for a type that has a known definition, such as from a Windows Runtime type or a type library, then OleViewDotNet will try and automatically apply the names. While losing the procedure name context is a bummer, it still allows invoking the procedure and A LOT of classes do not support the IDispatch interface, which means that skipping them would reveal far less interesting results.</p><p>With the previous chapters in mind and the power of OleViewDotNet, there lies an obvious solution to automating vulnerability research for COM; we loop over all classes it’s interfaces, create a COM client for it and invoke the procedures it holds. We feed the input parameters with randomized values and observe the result; fuzzing.</p><p>The fuzzing approach by general looks as follows:</p><pre><code>flowchart TD\n    A[Start: Define Target Program] --&gt; B[Generate Inputs]\n    B --&gt;|Random / Mutated / Structured| C[Fuzzer Engine]\n    C --&gt; D[Feed Inputs to Program Under Test]\n    D --&gt; E[Program Execution]\n    E --&gt;|Crash / Exception / Hang?| F{Program Behavior}\n\n    F --&gt;|Yes| G[Log &amp; Record Test Case]\n    F --&gt;|No| H[Continue Testing Loop]\n\n    G --&gt; I[Analyze Crash &amp; Reproduce Bug]\n    H --&gt; B\n\n    I --&gt; J[Fix Vulnerability]\n    J --&gt; K[Improve Fuzzer or Add Regression Test]\n    K --&gt; B\n\n    style A fill:#a2d2ff,stroke:#333,stroke-width:1px,color:#000\n    style C fill:#bde0fe,stroke:#333,stroke-width:1px,color:#000\n    style D fill:#ffc8dd,stroke:#333,stroke-width:1px,color:#000\n    style F fill:#ffafcc,stroke:#333,stroke-width:1px,color:#000\n    style I fill:#cdb4db,stroke:#333,stroke-width:1px,color:#000\n</code></pre><p>Of course this was easier said than done, who would’ve thought. However, a large part of the <a href=\"https://github.com/warpnet/MS-RPC-Fuzzer\">MS-RPC-Fuzzer</a> design could be reused for this project! First, we need a way to collect COM class information, the interfaces it holds and the interface it’s procedures. Each procedure has a definition with the input parameters it takes, example: <code>Proc5(string p0, int p1, NtApiDotNet.Ndr.Marshal.NdrUnsupported p2)</code>.</p><p>The first problem is parameters and a parameter its input value. This is also the most important factor for the fuzzer, because it will need to contain a value that will hopefully identify interesting COM classes. For fuzzing web applications this is a rather easy step, we can just always send strings. But for COM, there are more parameter types than just strings.</p><p>We don’t need or even can provide each type with a value. The most essential types for the fuzzing are the primitives (Strings, Integers, etc.) and arrays. We can provide these with random values with different sizes or lengths.</p><p>In summary, the COM fuzzer implement two functions: One function  will be responsible for extracting all parameters of a Method (procedure) and will call the other function  to provide it a value.</p><p>Some types are “complex” like <code>NtApiDotNet.Ndr.Marshal.NdrUnsupported</code> and we cannot provide them a value. However, we will need to provide the procedure the right format parameter type if we want to fuzz it. For example, when a procedure takes a string input parameter and a complex input parameter, we still want to fuzz the string input for that procedure.</p><p>To solve this, we can dynamically create an instance for the parameter using PowerShell reflection:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>The “complex” parameter type will most likely be provided with a value that the COM server will reject, because it expects some kind of value. However, this will provide us with the right parameter type so that we can still fuzz the other input parameters like strings.</p><pre><code>flowchart TD\n    A[Call Format-DefaultParameters for a Method] --&gt; B[Call Format-ParameterType for each parameter type]\n    \n    B --&gt; F{Type is primitive?}\n    F -- Yes --&gt; G[Generate random value of appropriate size/length]\n    F -- No --&gt; H{Type is array?}\n    \n    H -- Yes --&gt; I[Loop over array members]\n    I --&gt; J[Call Format-ParameterType recursively for each member]\n    \n    H -- No --&gt; K{Type is complex}\n    K -- Yes --&gt; L[Create instance using PowerShell reflection]\n    K -- No --&gt; M[Skip or provide default/null value]\n\n    G --&gt; N[Return value to Format-DefaultParameters]\n    J --&gt; N\n    L --&gt; N\n    M --&gt; N\n    N --&gt; O[Assemble complete parameter set]\n    O --&gt; P[Use parameters for fuzzing input]\n\n    style A fill:#eef,stroke:#333,stroke-width:1.5px,color:#000\n    style P fill:#bfb,stroke:#333,stroke-width:1.5px,color:#000\n    style L fill:#ffd,stroke:#333,stroke-width:1.5px,color:#000\n    style M fill:#fcc,stroke:#333,stroke-width:1.5px,color:#000\n</code></pre><p>Let’s take a step back. Before we can actually start fuzzing, we need to collect the required information to do so. The fuzzer implements a cmdlet  that can collect the COM class information from different input types; whole registry, COM database file, a specific CLSID or a list of CLSID’s.</p><p>In the following example we tell  to extract the information for the CLSID <code>13709620-C279-11CE-A49E-444553540000</code>:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>The required argument is , which tells the function where to export the results to. This is in the form of a JSON file. The following is a small part of the file that was generated using the above example:</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n</pre></td><td><pre></pre></td></tr></tbody></table></code></div></div><p>Why exporting it to a JSON file instead of directly fuzzing from the parsed CLSID you may ask. The answer to that is efficiency and time.</p><h4><a href=\"https://www.incendium.rocks/posts/Automating-COM-Vulnerability-Research/#321-efficiency-and-time\"></a></h4><ul><li>Creating an COM object isn’t always instant. Sometimes, the system is not able to create a COM object for the parsed CLSID and will error AFTER a timeout of around a minute.</li><li>Some interfaces hold procedures that crash PowerShell, having a JSON file allows you to remove the interface from the file so that the fuzzer won’t fuzz that interface.</li></ul><p>In general, when the JSON file was created for a COM class, you can always use it to fuzz because nothing will change, which is the case with, for example, RPC endpoints. The COM class may have a different implementation on another version of Windows, or after an update. But in general it should work when copying and pasting it to another system.</p><h4><a href=\"https://www.incendium.rocks/posts/Automating-COM-Vulnerability-Research/#322-class-context-and-templates\"></a></h4><p>Windows (11) contains a lot of COM classes:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>While the tool is capable of fuzzing every class, it still would take a lot of time to do so. So it’s better to have a specific set of COM classes where to focus on. The tool can filter some classes in different contexts; Remotely accessible classes, classess initiated from services and interactive user COM objects.</p><p>For example, we can point the  to collect COM classes initiated from services:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>This is also the reason the COM-fuzzer comes with 3 templates for COM classes that anyone can use to start fuzzing quickly. These are; ,  and .</p><p>For some COM classes there is a bug when creating a COM object, after a specific amount of time, the PowerShell session crashes AFTER already having created the object. So imagine the following scenario; we parse 100 COM classes and COM class on index 18 causes the PowerShell session to crash, but it will do so after some time while the function for collecting the information is already at index 84. One more reason to export the results to a JSON file instead of directly fuzzing.</p><p>During my research, I identified some of these classes and hard code blacklisted them in the  function. It could be that there are more COM classes/objects that show this behavior, so be aware of that when using the tooling.</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><h3><a href=\"https://www.incendium.rocks/posts/Automating-COM-Vulnerability-Research/#33-input-generation-and-the-canary\"></a></h3><p>Let’s get back to the fuzzing process. Once we determined the parameter type, the fuzzer provides it with a value, either standalone or within an array. The function  can be parsed with parameters like minimal string length or minimal integer size. The function takes the parameter type as value and then uses random to generate the input. As an example, the case for a  parameter type is given:</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n</pre></td><td><pre></pre></td></tr></tbody></table></code></div></div><p>You may notice the  variable. This is an important deal for the fuzzer to know where our input landed and determine relationships.</p><p>The <a href=\"https://en.wikipedia.org/wiki/Canary_trap\">canary method</a> is used to expose an information leak by giving different versions of a sensitive document of several suspects and seeing which version gets leaked. In our case, for string parameter types, we send a recognizable string and attach a random value to it. Example:</p><div><div><code><table><tbody><tr></tr></tbody></table></code></div></div><p>To find the information leak (know where our input lands in the background), we will need a tool that can monitor processes in the background of the Windows system. The ideal tool for this is <a href=\"https://learn.microsoft.com/en-us/sysinternals/downloads/procmon\">Process Monitor</a>. Process Monitor is an advanced monitoring tool for Windows that shows real-time file system, Registry and process/thread activity.</p><p>While having Process Monitor listening in the background, we can start our fuzzer. When we apply a filter in Process Monitor that includes our recognizable part of the string e.g., , we can see where our fuzzing input landed and what kind of function calls are being made with our input.</p><p><em>Process Monitor with canary as applied filter</em></p><p>When you know which process ID (PID) is making the request, a next step would be to filter the specific PID and look for further calls it makes. A user can now export the Process Monitor results into a CSV file. The fuzzer provides the  cmdlet to import the data into Neo4j. More about this in a later chapter.</p><p>Remotely invoking procedures is also possible (DCOM). Although you will need high privileges to actually invoke the COM call on the remote system, the fuzzer includes an option to do so. Using the  together with the credentials of the user that is allowed to invoke the COM call, it will fuzz COM on the remote system instead.</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>This works by first parsing the user provided arguments to . This creates a credential object which then gets parsed to . By default,  uses the following authentication level configuration:</p><div><div><code><table><tbody><tr><td><pre>AuthnSvc:        WinNT\nAuthnLevel:      PKT_PRIVACY\nImpLevel:        IMPERSONATE\nCapabilities:    None\n</pre></td></tr></tbody></table></code></div></div><p>Which should be fine for most tasks. To figure out if a COM class can be activated and executed remotely, OleViewDotNet’s cmdlet <code>Format-ComSecurityDescriptor</code> can help:</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n</pre></td><td><pre></pre></td></tr></tbody></table></code></div></div><p>Perfect for discovering new lateral movement techniques ;).</p><p>While the fuzzer is running, it will store the results into separate JSON files. These are allowed.json and denied.json depending on the returned message. The structure of the result file looks something like:</p><div><div><code><table><tbody><tr><td><pre>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n</pre></td><td><pre></pre></td></tr></tbody></table></code></div></div><p>It stores the input, the output and windows message according to the integer found in the output. But this json file can easily get as big as 50.000 lines. Also, from a JSON structure it is quite hard to see the relations. This calls for a solution that can provide us with tooling that makes analysis easy.</p><p>The fuzzing results are obtained within standalone JSON files, so a user can do analysis however he likes. Showing the relation between COM class, interface, procedure, input and output is a effective way to get a better understanding about the COM implementation. For this, I chose to reuse the <a href=\"https://neo4j.com/\">Neo4j</a> wrapper from my MS-RPC-Fuzzer. I rewrote some of the functions to import our JSON files to a (remote) Neo4j database.</p><p>The user can provide the JSON file and pipe it to the cmdlet :</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>To query the data in Neo4j, the Cypher language is used to make the relations. The following Cypher is an example:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>This query looks for high privileged file operation function calls. What does this mean? I wrote a rule that when a high privileged identity, like  is making the function call, or it is impersonating this identity, and the function call contains , it will mark it as an  node.</p><p><em>Viewing relationships in Neo4j with high privileged file operations</em></p><p>Viewing this relationship is only possible because we combined both our fuzzing input and the Process Monitor results into the same Neo4j database. In the above example, a file is being written with our user input provided as <code>NT AUTHORITY\\LOCAL SERVICE</code>.</p><p>To do this, the user should first import the fuzzing results into Neo4j:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>Next, the user should export the Process Monitor results into a CSV file and import it to Neo4j:</p><div><div><code><table><tbody><tr><td><pre></pre></td></tr></tbody></table></code></div></div><p>By default, the value for the canary is . But you can change this while fuzzing using the  argument with . Make sure to change the canary value for  as well if you changed this.</p><p>In summary; the fuzzer has 3 phashes; inventarize (collecting information), fuzzing and analysis.</p><pre><code>graph TD\n    User([User])\n\n    %% Input and output styling\n    classDef input fill:#d4fcd4,stroke:#2b8a3e,stroke-width:2px,color:#000;\n    classDef output fill:#fff3cd,stroke:#ffbf00,stroke-width:2px,color:#000;\n\n    %% Phase 1: Gather COM Data\n    User --&gt; A1[Get-ComServerData]\n    A1 --&gt; A2[Target or context specified]\n    A2 --&gt; A3[ComServerData.json]\n    A3 --&gt; B1[Invoke-ComFuzzer]\n\n    %% Phase 2: Fuzzing\n    B1 --&gt; B2[log.txt Call History]\n    B1 --&gt; B3[allowed.json]\n    B1 --&gt; B4[denied.json]\n\n    %% All fuzzer outputs used in Phase 3\n    B3 --&gt; C1[Import-DataToNeo4j]\n    B4 --&gt; C1\n\n    %% Phase 3: Analysis\n    C1 --&gt; C2[Neo4j Database]\n    C2 --&gt; C3[Graph Visualization &amp; Querying]\n\n    %% Apply styling\n    class A3 input;\n    class B3,B4,B2 output;\n\n    %% Labels for clarity\n    subgraph Phase1 [Phase 1: Initialize COM]\n        A1\n        A2\n        A3\n    end\n\n    subgraph Phase2 [Phase 2: Fuzzing]\n        B1\n        B2\n        B3\n        B4\n    end\n\n    subgraph Phase3 [Phase 3: Analysis]\n        C1\n        C2\n        C3\n    end\n</code></pre><p>First, specify a target to . This can be the whole registry, a specific CLSID, a list of CLSIDs or a COM database file. This will output a JSON file , containing the classes their CLSIDs, interfaces and procedures, which the user can parse to the fuzzer. If there is no target specified, it will default to the entire registry.</p><p>The fuzzer , takes the exported JSON file from the previous phase as required input. The fuzzer will output maximal 2 JSON files and one log file. It will write the COM calls before invoking them to , this way if there is a crash (BSOD), the user will know which call was responsible (last line).</p><p>It will separate the fuzz results into 2 JSON files:</p><ol><li>Fuzzed inputs that lead to Access Denied</li></ol><p>The user can use the JSON files for analysis as he likes. However, the fuzzer has an option to import them into your Neo4j instance using the  cmdlet. The fuzzer has a data mapper that makes relations for the data, easy as that.</p><p>The whole idea is to gain insights into COM/DCOM implementations that may be vulnerable using an automated approach and make it easy to visualize the data. By following this approach, a security researcher will hopefully identify interesting COM classes/implementations in such a time that would take a manual approach significantly more.</p><p>While some very interesting COM classes were identified during my research, for now only <a href=\"https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2025-59253\">CVE-2025-59253</a> got assigned. This shows that the tool is effective and can be used to discover new vulnerabilities. A big surface has not been properly analyzed. While COM/DCOM can lead to interesting bugs or vulnerabilities, it was never said that it reveals its secrets easily ;) (even with a fuzzing approach).</p><h2><a href=\"https://www.incendium.rocks/posts/Automating-COM-Vulnerability-Research/#chapter-5--conclusion-and-future-work\"></a></h2><p>COM (Component Object Model) and DCOM (Distributed COM) have been interesting components in Windows from a security perspective for many years. Diving into the implementation and internal workings of COM/DCOM was an interesting topic that I had on the planning for quite some time.</p><p>Because of the design of the <a href=\"https://github.com/warpnet/MS-RPC-Fuzzer\">MS-RPC-Fuzzer</a>, a large part of the COM-Fuzzer design could be recycled. While the fuzzer can reveal interesting COM/DCOM implementations, it is still blackbox fuzzing. This means that when we invoke a COM procedure, we are not sure what actually is going to happen. Using external tools such as Process Monitor while fuzzing helps to get a better understanding, but in the end, a researcher will still to reverse the actual implementation to know exactly what is going on. This fuzzer will hopefully identify the COM classes that are worth for further analysis, like reversing the server.</p><p>I’m glad the fuzzing approach once again proves that it can be effective on different disciplines, like COM/DCOM, as <a href=\"https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2025-59253\">CVE-2025-59253</a> was assigned during my research.</p><p>While effective, the tool can be improved in future work. For example, the bug as described in <a href=\"https://www.incendium.rocks/posts/Automating-COM-Vulnerability-Research/#323-com-objects-and-crashes\">chapter 3.2.3 COM objects and crashes</a> is something that will probably lead to issues while gathering COM-data for many classes. At some time I plan to filter out more classes that lead to the problem and get to the root cause of this and hopefully fix it/work around it without needing a blacklist.</p><p>While fuzzing, the PowerShell session can crash once again. I’ve tried to identify some of these classes for which this is the case and added them to  within the repository. The file can be parsed with the argument . While this works around the problem, it is again better to get to the root cause of this problem and fix it.</p><p>Some procedures take long to finish/execute or even hang. While you can use the argument  for this with a specific procedure, it still is annoying. So in the future it will probably be wise to implement a time out. While this is tricky in PowerShell, the requirement to have OleViewDotNet installed beforehand makes this slightly easier (so the module doesn’t have to be important each time when working with jobs.)</p><p>Finally, new approaches to fuzzing COM/DCOM implementations can be implemented in the future. Things like the  path argument or the  option can lead to new insights, pherhaps more of these options will be added in the future.</p><ul><li><p><a href=\"https://github.com/tyranid/oleviewdotnet\"><strong>OleView.NET (tyranid / James Forshaw)</strong></a> .NET reimplementation of Microsoft’s OLE/COM Object Viewer, useful for inspecting COM type libraries, registered classes, interfaces and typelib metadata when analyzing COM/RPC surfaces.</p></li><li><p><a href=\"https://github.com/warpnet/COM-Fuzzer\"><strong>COM-Fuzzer (Remco van der Meer)</strong></a> Fuzzing framework for exercising COM interfaces to discover parsing bugs, memory corruption, and unexpected behaviors in COM servers.</p></li><li><p><a href=\"https://github.com/warpnet/MS-RPC-Fuzzer\"><strong>MS-RPC-Fuzzer (Remco van der Meer)</strong></a> Fuzzer specialized for Microsoft RPC (MS-RPC) endpoints and automates generation and delivery of malformed RPC requests for stability and crash analysis.</p></li><li><p><a href=\"https://learn.microsoft.com/en-us/sysinternals/downloads/procmon\"></a> Real-time system activity monitor (file, registry, process/thread), indispensable for observing side-effects of fuzzing, RPC interactions, and runtime behavior on Windows hosts.</p></li><li><p><a href=\"https://neo4j.com/\"></a> Graph database and visualization platform, commonly used to model interfaces, call graphs and relationships discovered during reverse engineering and protocol analysis.</p></li></ul><ul><li><p><a href=\"https://en.wikipedia.org/wiki/Microsoft_RPC\"><strong>Microsoft RPC – Wikipedia</strong></a> High-level overview of Microsoft RPC concepts, history and architecture, a good primer before digging into implementation details or tooling.</p></li><li><p><a href=\"https://en.wikipedia.org/wiki/Canary_trap\"></a> Explanation of canary trap techniques for detection/attribution, useful when designing monitored testbeds or leak-detection mechanisms during research.</p></li></ul>","contentLength":29615,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1okanf4/automating_comdcom_vulnerability_research/"},{"title":"Can you break our pickle sandbox? Blog + exploit challenge inside","url":"https://iyehuda.substack.com/p/we-may-have-finally-fixed-pythons","date":1761846449,"author":"/u/valmarelox","guid":102469,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1ok6iot/can_you_break_our_pickle_sandbox_blog_exploit/"},{"title":"How we found +2k vulns, 400+ secrets and 175 PII instances in publicly exposed apps built on vibe-coded platforms (Research methodology)","url":"https://escape.tech/blog/methodology-how-we-discovered-vulnerabilities-apps-built-with-vibe-coding/","date":1761839590,"author":"/u/PriorPuzzleheaded880","guid":102380,"unread":true,"content":"<p>Hey there,<p>With Halloween around the corner, what’s scarier for organizations than vulnerabilities in their web applications?</p></p><p>And it's even scarier when the development of these applications is in the hands of users not familiar with security practices.</p><p>This year, the Escape research team has focused on a growing area of concern: . Purpose-built platforms like Lovable.dev, Base44.com, and Create.xyz have democratized application development, enabling non-developers to deploy full-stack applications without writing a single line of code. Just ask your colleagues on the marketing team what they've already deployed or experimented with under the hood! ;) </p><p>As vibe-coded applications become more accessible, inexperienced users are creating fresh risks.</p><p>Our research team analyzed over <strong>5,600 publicly available applications</strong> and identified more than , , and  (including medical records, IBANs, phone numbers, and emails).</p><p>Unlike other published articles on that topic, the goal of this research was to move beyond isolated case studies by identifying issues at scale that would otherwise require hours of manual work to uncover.</p><p>You can&nbsp;review the complete results <a href=\"https://escape.tech/state-of-security-of-vibe-coded-apps?ref=escape.tech\">in our comprehensive report.</a> Meanwhile, in this article, we'll show you the methodology that guided us to these impressive findings.</p><p>To collect and analyze our dataset, multiple domain sources were leveraged, including official launch directories (e.g., launched.lovable.dev), Shodan indexing, Reddit communities, and manual crawling.</p><p>First, we retrieved data from launched.lovable.dev to compile a dataset of 4,000 web applications. We then expanded our target set using additional sources, including lovable.dev, base44.com, vibe-studio.ai, bolt.new, create.xyz. Afterward, we performed subdomain enumeration on these domains to identify additional targets.</p><p>Following a cross-source analysis of the aggregated dataset, we derived three independent fingerprinting methods for detecting Lovable-based web apps:</p><p>After developing a fingerprint for the Lovable web app, we used Shodan to locate live instances of web apps that appear to be implemented with Lovable. To further augment the dataset, we scraped curated posts and comment threads from the Reddit communities r/lovable and r/base44.</p><p>The resulting URLs were curated through a multi-stage process:</p><ul><li>Deduplication to remove redundant entries</li><li>Automated reachability checks to exclude dead hosts: we filtered live assets by checking whether each main page returned an HTTP status code in the 200–399 range</li><li>Filtering to distinguish between non-application landing pages and functioning deployments.</li></ul><p>Initial platform coverage included Lovable (~4,000+ applications discovered), Base44 (~159), Create.xyz (~449), Vibe Studio, and Bolt.new (smaller samples).</p><p>The data collection was conducted as a one-time process. During collection, several limitations were deliberately imposed to ensure legal and ethical compliance. Domains that could be reasonably identified as educational or health-related were excluded, as typical users are not authorized to probe such systems. This exclusion reduced coverage but ensured adherence to established ethical norms of web crawling and security research.</p><p>We acknowledge several sources of potential bias in our methodology:</p><ul><li> Reliance on launch directories, Shodan, and community postings may overrepresent applications that are actively promoted or easily discoverable, while underrepresenting private or restricted deployments.</li><li> As data collection was performed once, the dataset represents a snapshot in time. Applications and platforms evolve rapidly; vulnerabilities may have been patched or newly introduced since collection.</li><li> The dataset is heavily skewed toward Lovable deployments, with substantially fewer applications discovered for Base44, Create.xyz, Vibe Studio, and Bolt.new. This imbalance may disproportionately influence prevalence measurements.</li></ul><p>At the same time, focusing on domains openly accessible to anyone online gives us a useful window into how these applications are actually built and used in practice. This approach highlights the security habits (and mistakes) that most often appear in real deployments, especially when apps are created by people with little security background.</p><p>Looking at this public-facing slice of the ecosystem helps us see not just isolated flaws, but broader patterns across sectors.</p><p>After the dataset was curated, the next stage of the methodology focused on systematically mapping the attack surface of each application, i.e., extracting all hosts, web apps, and APIs exposed by the domains we found (further defined as “assets” fed into Escape’s Attack Surface Management scanner). Our goal was to build a structured model of each application’s externally visible footprint and then subject high-value pieces of that footprint to dynamic testing.</p><p>As a platform, Escape is a collection of security scanners. A typical Escape’s ASM scanner is a tool that automates the identification of all exposed assets, correlates them, and helps prioritize which ones are most likely to be exploited. Its scanner structure can be seen as follows:</p><p>The scanner first ingests the “assets”. In our case, these assets include hosts, web apps, APIs, and schemas. The scanner then proceeds through a multi-step process of validation and reachability checks, followed by fingerprinting and metadata collection (such as WAF, cloud provider, framework, and GeoIP). This process ensures that only valid, accessible assets are mapped and ready for further testing.</p><p>Once the assets are identified, they are classified into the discovery phase. We relied on a layered discovery strategy to maximize coverage while minimizing intrusiveness:</p><ul><li><strong>Domain and host discovery. </strong>Subdomain enumeration and passive indices were used to enumerate hosts associated with each base domain. As mentioned before, we validated reachability via benign HTTP(s) probes and excluded hosts that returned only generic landing pages.</li><li><strong>Web crawling and route enumeration.</strong> A headless-browser crawler rendered pages and followed links, collecting URL structures, JS bundles, and client-side routing artifacts.</li><li><strong>Static frontend analysis.</strong> JavaScript and HTML were parsed to extract embedded API endpoints, fetch/XHR/WebSocket URLs, inline tokens or keys (when present in the public bundle), and configuration objects that reveal backend schemas or third-party integrations.</li><li>Endpoints discovered in JS, observed in network traces during crawl sessions, or exposed via documented routes were collated into service models. When available, open schema fragments (e.g., JSON responses illustrating resource shapes) were used to infer parameterization and access control points. We also performed API discovery by brute-forcing API paths, i.e., testing for common paths at scale and identifying API-like responses.</li></ul><p>By feeding the data collected during the discovery process into the scanner, we built a comprehensive, continuously updated map of each application's publicly visible footprint.</p><p>While analyzing the structure of specifically Lovable websites, we came across the integration of Lovable and Supabase. In this structure, we specifically identified and targeted APIs integral to the application’s functionality that could be discovered and analyzed at scale.</p><p>During our analysis, we also discovered that anonymous JWT tokens were exposed in the JavaScript bundles of the Lovable front end. These tokens were linked to PostgREST APIs as part of the Supabase backend integration. <a href=\"https://docs.lovable.dev/integrations/supabase?ref=escape.tech\" rel=\"noopener\">According to the documentation</a>, Supabase <em>“automatically generates a RESTful API from the database schema, allowing applications to interact with the PostgreSQL database through an interface, all from the browser.”</em></p><p>However, while Supabase's default security rules are permissive for development, they leave important security gaps if not properly configured before going live. Specifically, Row-Level Security (RLS) policies must be implemented to ensure that only authorized users can access or modify specific rows in the database, such as ensuring that users can access only their own data. The issue arises when RLS is misconfigured between the API layer and the database. This creates security risks, as unauthorized access could occur if JWT tokens (used for authentication) are exposed in the frontend code.</p><p>Therefore, while Lovable can assist in generating RLS policies, it is vital for users to manually review these policies (which can be a challenge for less experienced “vibe coders”).</p><h3>Introduction of Lightweight DAST Surface Scanning  or \"Visage Surface Scanner\"</h3><p>Given the structure of the integration between Lovable front-ends and Supabase backends via API, and the fact that certain high-value signals (exposed keys, for example, anonymous JWTs to APIs linking Supabase backends, client-side routes, embedded endpoints) only appear in frontend bundles or source output, we introduced a lightweight, read-only scan to harvest these artifacts and feed them back into the ASM inventory.</p><p>We called this scanner the Visage Surface Scanner. Unlike previous versions, this scanner is less in-depth: it doesn't execute any actions on the web application or trigger processes. Instead, it analyzes source code and frontend responses to identify secrets or routes that can be added to the asset inventory in our Attack Surface Management tool through a feedback loop.</p><p>The Visage Surface scanner was integrated into the Attack Surface Management (ASM) web app scanner, enabling us to scan Lovable web apps for vulnerabilities and identify exposed anonymous JWT tokens and Supabase API routes. These findings were then fed into the Escape API-focused Business Logic Security Testing Scanner, where they were analyzed for real-world security issues:</p><p>After adding the discovered URLs to the ASM and running the Visage Surface Scan, we now discovered in total  assets in the ASM, composed of:</p><ul><li> schemas (found and generated via frontend traffic)</li></ul><p>These assets were then filtered and organized into an Attack Surface Management (ASM) per application within Escape’s platform that included:</p><ul><li>Web application entry points and client routes</li><li>REST/GraphQL/WebSocket endpoints and their observed request/response shapes</li><li>Authentication and session management endpoints</li><li>Third-party integrations and service endpoints (e.g., Supabase, analytics, storage)</li></ul><h3>Security Testing and Dynamic Analysis</h3><p>Once the attack surface was extracted and modeled, we applied targeted security testing using in-house dynamic application security testing (DAST) techniques (<a href=\"https://escape.tech/blog/escape-dast-web-app-algorithm/\" rel=\"noopener\">see more info on the web app scanner here</a> and the <a href=\"https://escape.tech/blog/escape-proprietary-algorithm/\" rel=\"noopener\">API scanner here</a>). The objective was not to exhaustively exploit weaknesses, but to identify recurring classes of misconfigurations and vulnerabilities in a safe, controlled manner.</p><p>We ran DAST scans in a “passive” mode, explicitly configured to avoid destructive operations, high-volume brute force attempts, or payloads that could disrupt target services. This design choice was made to respect ethical and legal boundaries and to minimize unintended impact on live deployments. While this conservative approach ensures safety, it also introduces an important bias: the results presented here are lower-bound estimates. <strong>Running Escape’s full scanning capabilities (e.g., injection payloads, deeper fuzzing, and aggressive brute-force) would almost certainly surface a larger volume of issues, including higher-severity vulnerabilities.</strong></p><p>All REST API endpoints passed our REST DAST scan, using the schema produced by the Visage Surface scanner and the credentials stored in the web application. We attempted to implement an automated registration agent for the web application to provision an account, execute a comprehensive scan, and forward the resulting authentication token to the REST DAST tool.</p><p>Two important observations shaped the testing results:</p><ul><li><strong>Most vulnerabilities were exposed without authentication</strong></li></ul><p>Across platforms, critical weaknesses (e.g., exposed Supabase tokens, misconfigured APIs, and missing row-level security) were accessible directly through public endpoints. Tokens such as Supabase service keys were often trivially retrievable from frontend bundles, underscoring that many security issues in vibe-coded apps exist “in the open,” without requiring any privileged access. If we decided to go more in-depth, we could develop an AI-driven auto-authentication system that leveraged headless browser automation and agent-based orchestration.</p><p>2<strong>. Results understate the true risk</strong></p><p>Because scans were run in a passive mode, the findings reflect only a subset of exploitable issues. A more aggressive testing configuration would likely have uncovered additional vulnerabilities with greater impact. In this sense, our findings represent a conservative baseline rather than the full extent of the security risks present in these ecosystems.</p><h3>Data Cleanup and Verification</h3><p>After running the ASM-driven DAST scans, the raw output contained a large volume of findings with the Escape platform, ranging from high-confidence exposures to some noisy signals. To ensure that only meaningful vulnerabilities and secret disclosures were included in our analysis, we applied a multi-stage cleanup and verification process.</p><p><strong>Deduplication and Normalization</strong></p><p>Deduplication and normalization were performed automatically by the Escape platform, which consolidated findings across multiple discovery vectors.</p><p><strong>Verification of Exposed Secrets</strong></p><ul><li>Pattern-based filtering: Escape applied platform-specific rules to distinguish genuine credentials (e.g., API keys, Supabase tokens, environment variables) from placeholders or noise.</li><li>False-positive reduction: Values resembling generic identifiers (UUIDs, hashes, opaque IDs) were automatically flagged and excluded if not usable as credentials.</li><li>Safe live validation: Where legally and ethically permissible, exposed tokens were tested against non-destructive requests to public endpoints to verify validity. Tokens granting elevated privileges (particularly Supabase service role keys) were flagged as critical exposures due to the level of access they provided.</li></ul><ul><li>Vulnerabilities suggesting missing or weak authentication were validated by replaying requests without tokens or with modified headers to confirm whether access restrictions were enforced.</li><li>Manual spot-checks. A representative subset of findings was manually validated to assess the precision of automated classification and to calibrate severity scoring.</li></ul><p>It is important to note that the cleanup and verification process was intentionally conservative. Only findings that could be confirmed with high confidence were retained. As a result, the vulnerabilities and exposed secrets presented in this study represent a verified baseline rather than the full universe of potential issues.</p><p>Mapping out the attack surface of these vibe-coded applications wasn’t easy, but it was necessary. By taking a comprehensive approach to identifying exposed assets and vulnerabilities, we uncovered risks that would otherwise go unnoticed. </p><p>Our study reveals that these vulnerabilities are spreading across diverse websites, industries, and asset types. As the vibe coding phenomenon continues to explode, especially within modern tech industries, the challenge grows. Even though users may be increasingly tech-savvy, many still lack critical security awareness. As a result, the risks are only amplifying.</p><p>Organizations must respond quickly to these threats by adopting best practices to protect their assets. The sooner they act, the better.</p>","contentLength":15529,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1ok3ffd/how_we_found_2k_vulns_400_secrets_and_175_pii/"},{"title":"A Deep Dive Into Warlock Ransomware Deployed Via ToolShell SharePoint Chained Vulnerabilities","url":"https://hybrid-analysis.blogspot.com/2025/10/a-deep-dive-into-warlock-ransomware.html","date":1761838709,"author":"/u/CyberMasterV","guid":102381,"unread":true,"content":"<ul><li>Warlock ransomware was deployed by exploiting the SharePoint vulnerabilities  and </li><li>The malware includes a hostname verification mechanism that excludes designated systems from encryption, indicating self-preservation tactics</li><li>Warlock performs defense evasion by stopping a list of services and processes and removes volume shadow copies&nbsp;</li><li>The ransomware encrypts files using a combination of the  algorithm and </li></ul><div><div>Warlock ransomware has been recently found being distributed through newly discovered <a href=\"https://www.crowdstrike.com/en-us/blog/crowdstrike-detects-blocks-sharepoint-zero-day-exploitation/\" target=\"_blank\">SharePoint vulnerabilities</a>. This malware represents the latest evolution in ransomware tactics, combining advanced encryption methods with targeted defense evasion techniques.</div><div>As a result, we have conducted a comprehensive analysis of Warlock, examining both its initial behavior through sandbox environments and performing detailed static and dynamic analysis of samples in the wild. The findings reveal a methodical attack pattern designed to maximize damage while protecting itself from detection and removal.</div><div>The ransomware exploits two critical SharePoint vulnerabilities ( and ) as its entry point, then deploys a multi-stage attack that includes terminating security services, removing recovery options, and implementing a hybrid encryption scheme using  and  algorithms.</div><div>Perhaps most telling is Warlock's self-preservation mechanism—a hostname verification feature that deliberately avoids encrypting certain systems, suggesting a calculated self-preservation approach built by its operators.</div></div><h2>A Hybrid Analysis Perspective</h2><div>As we can see in the Hybrid Analysis report, the ransomware appends its extension to the existing one:</div><div>Figure 1 - Warlock ransomware’s extension identified</div><div>Figure 2 reveals that the malware is looking to open and possibly stop multiple services related to backup, databases,&nbsp; shadow copies, AntiVirus software, and so on.</div><div>Figure 2 - Multiple services are targeted</div><div>Hybrid Analysis identifies that the sample implements the  algorithm for encryption using YARA rules (Figure 3).</div><div>Figure 3 - ChaCha20 algorithm identified</div><div>Figure 4 - CryptoPP library is statically linked</div><div>The  API is utilized to empty the Recycle Bin in order to avoid possible file recovery from the location:</div><div>Figure 5 - SHEmptyRecycleBinW API call</div><h2>A Deeper Dive Into Warlock</h2><div>The process retrieves the command-line arguments and compares them with the following list: “” (doesn’t change the extension of the file passed as a parameter), “” (doesn’t create the ransom note) and “”.</div><div>Figure 6 - Command-line arguments retrieval</div><div>The threat actor embedded a GUID in the code that will appear in all encrypted files. The ransomware also implements a check (skipping files encryption) for a placeholder that should be a hostname called “”.</div><div>Figure 7 - Hard-coded information</div><div>The malware hides the current window via a function call to  (0x0 = ):</div><div>Figure 8 - Malware’s window is hidden</div><div> is used to empty the Recycle Bin on all drives (0x7 = <b>SHERB_NOCONFIRMATION | SHERB_NOPROGRESSUI | SHERB_NOSOUND</b>):</div><div>Figure 9 - Empty the Recycle Bin</div><div>Warlock mounts all unmounted volumes using the , , and  functions.</div><div>Figure 10 - Mount all unmounted volumes</div><div>The ransomware stops a list of services (i.e. AntiVirus, backup, shadow copies) using the  method (0x1 = ). The entire list of services can be found in the Appendix.</div><div>Figure 11 - Targeted services are stopped</div><div>The executable stops a list of processes that might interfere with the encryption. The list of all processes can be found in the Appendix.</div><div>Figure 12 - Targeted processes are killed</div><h2>Volume Shadow Copies Deletion</h2><div>The ransomware deletes all volume shadow copies by calling the  function and then  on every shadow copy found (see Figure 13).</div><div>Figure 13 - Delete volume shadow copies using COM interface</div><div> is used to retrieve the drive type, which must be different than 0x1 () and 0x5 ():</div><div>Figure 14 - GetDriveTypeW API call</div><div>The following files and directories will  be encrypted by Warlock Ransomware:</div><div>Figure 15 - Skipped files and directories</div><div>The malware creates multiple threads that will handle the file encryption. Firstly, it appends the “.” extension to every file to be encrypted using :</div><div>Figure 16 - Append the ransomware’s extension to encrypted files</div><div>The ransomware uses  (CryptoPP library) and  for encrypting files. It calls  to generate 32 random bytes (session private key), computes the 32-byte session public key using , and then computes the 32-byte shared secret using the session private key and a hard-coded 32-byte public key. The  key is the SHA256 of the shared secret and the IV is equal to the first 8 bytes from the key. The entire workflow is highlighted in the figure below. The threat actor can recover the shared secret using the session public key that is written to the encrypted file and the secret private key that corresponds to the hard-coded public key.</div><div>Figure 17 - Generate the shared secret using Curve25519</div><div>Figure 18 - Hard-coded 32-byte public key</div><div>The ransomware traverses the directories and encrypts the files using :</div><div>Figure 19 - Open targeted file for encryption</div><div>Figure 20 - Write encrypted content to the file</div><div>A snippet of the  implementation is displayed in Figure 21.</div><div>Figure 21 - ChaCha20 algorithm</div><div>An example of an encrypted file is displayed below. The footer contains the 32-byte session public key generated before and the hard-coded GUID already mentioned.</div><div>Figure 22 - Footer contains the 32-byte session public key and GUID</div><div>The ransom note called “” is dropped in every encrypted directory (Figure 23).</div><h2>Warlock Through the Eyes of Hybrid Analysis</h2><div>The Hybrid Analysis sandbox report reveals multiple key behavioral indicators of Warlock ransomware's functionality. The analysis identifies the ransomware's unique file extension and confirms its use of the ChaCha20 algorithm for file encryption. A significant indicator of malicious intent is the ransomware's systematic termination of backup and AntiVirus software services. The in-depth technical analysis provides crucial evidence from the dynamic analysis and describes the volume shadow copies deletion process, as well as every step of the complex file encryption workflow.&nbsp;</div><div>Hybrid Analysis is a powerful platform for identifying and analyzing malware, whether mundane or highly sophisticated. It provides detailed context and information that can be investigated further during the dynamic analysis of the malware. For performing a more in-depth analysis of malware samples, you can download them by registering with a Hybrid Analysis account and becoming a <a href=\"https://www.hybrid-analysis.com/knowledge-base/how-to-submit-a-vetting-request\" target=\"_blank\">vetted user</a>.</div><div>How to decrypt my data.txt</div><div>\"sql.exe\", \"oracle.exe\", \"ocssd.exe\", \"dbsnmp.exe\", \"synctime.exe\", \"agntsvc.exe\", \"isqlplussvc.exe\", \"xfssvccon.exe\", \"mydesktopservice.exe\", \"ocautoupds.exe\", \"encsvc.exe\", \"firefox.exe\", \"tbirdconfig.exe\", \"mydesktopqos.exe\", \"ocomm.exe\", \"dbeng50.exe\", \"sqbcoreservice.exe\", \"excel.exe\", \"infopath.exe\", \"msaccess.exe\", \"mspub.exe\", \"onenote.exe\", \"outlook.exe\", \"powerpnt.exe\", \"steam.exe\", \"thebat.exe\", \"thunderbird.exe\", \"visio.exe\", \"winword.exe\", \"wordpad.exe\", \"notepad.exe\"</div><div>\"vss\", \"sql\", \"svc$\", \"memtas\", \"mepocs\", \"sophos\", \"veeam\", \"backup\", \"GxVss\", \"GxBlr\", \"GxFWD\", \"GxCVD\", \"GxCIMgr\", \"DefWatch\", \"ccEvtMgr\", \"ccSetMgr\", \"SavRoam\", \"RTVscan\", \"QBFCService\", \"QBIDPService\", \"Intuit.QuickBooks.FCS\", \"QBCFMonitorService\", \"YooBackup\", \"YooIT\", \"zhudongfangyu\", \"sophos\", \"stc_raw_agent\", \"VSNAPVSS\", \"VeeamTransportSvc\", \"VeeamDeploymentService\", \"VeeamNFSSvc\", \"veeam\", \"PDVFSService\", \"BackupExecVSSProvider\", \"BackupExecAgentAccelerator\", \"BackupExecAgentBrowser\", \"BackupExecDiveciMediaService\", \"BackupExecJobEngine\", \"BackupExecManagementService\", \"BackupExecRPCService\", \"AcrSch2Svc\", \"AcronisAgent\", \"CASAD2DWebSvc\", \"CAARCUpdateSvc\"</div>","contentLength":7669,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1ok31dq/a_deep_dive_into_warlock_ransomware_deployed_via/"}],"tags":["netsec"]}