{"id":"82kPqoBYiySD8ih7nAXkFuDhjyLjtPi8jr6gSpxV4VMW","title":"The Go Blog","displayTitle":"Dev - Golang Blog","url":"http://blog.golang.org/feed.atom","feedLink":"http://blog.golang.org/feed.atom","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":1,"items":[{"title":"Traversal-resistant file APIs","url":"https://go.dev/blog/osroot","date":1741737600,"author":"Damien Neil","guid":85,"unread":true,"content":"<p>A <em>path traversal vulnerability</em> arises when an attacker can trick a program\ninto opening a file other than the one it intended.\nThis post explains this class of vulnerability,\nsome existing defenses against it, and describes how the new\n<a href=\"https://go.dev/pkg/os#Root\"></a> API added in Go 1.24 provides\na simple and robust defense against unintentional path traversal.</p><p>“Path traversal” covers a number of related attacks following a common pattern:\nA program attempts to open a file in some known location, but an attacker causes\nit to open a file in a different location.</p><p>If the attacker controls part of the filename, they may be able to use relative\ndirectory components (\"..\") to escape the intended location:</p><pre><code>f, err := os.Open(filepath.Join(trustedLocation, \"../../../../etc/passwd\"))\n</code></pre><p>On Windows systems, some names have special meaning:</p><pre><code>// f will print to the console.\nf, err := os.Create(filepath.Join(trustedLocation, \"CONOUT$\"))\n</code></pre><p>If the attacker controls part of the local filesystem, they may be able to use\nsymbolic links to cause a program to access the wrong file:</p><pre><code>// Attacker links /home/user/.config to /home/otheruser/.config:\nerr := os.WriteFile(\"/home/user/.config/foo\", config, 0o666)\n</code></pre><p>If the program defends against symlink traversal by first verifying that the intended file\ndoes not contain any symlinks, it may still be vulnerable to\n<a href=\"https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use\" rel=\"noreferrer\" target=\"_blank\">time-of-check/time-of-use (TOCTOU) races</a>,\nwhere the attacker creates a symlink after the program’s check:</p><pre><code>// Validate the path before use.\ncleaned, err := filepath.EvalSymlinks(unsafePath)\nif err != nil {\n  return err\n}\nif !filepath.IsLocal(cleaned) {\n  return errors.New(\"unsafe path\")\n}\n\n// Attacker replaces part of the path with a symlink.\n// The Open call follows the symlink:\nf, err := os.Open(cleaned)\n</code></pre><p>Another variety of TOCTOU race involves moving a directory that forms part of a path\nmid-traversal. For example, the attacker provides a path such as “a/b/c/../../etc/passwd”,\nand renames “a/b/c” to “a/b” while the open operation is in progress.</p><p>Before we tackle path traversal attacks in general, let’s start with path sanitization.\nWhen a program’s threat model does not include attackers with access to the local file system,\nit can be sufficient to validate untrusted input paths before use.</p><p>Unfortunately, sanitizing paths can be surprisingly tricky,\nespecially for portable programs that must handle both Unix and Windows paths.\nFor example, on Windows  reports ,\nbecause the path “\\foo” is relative to the current drive.</p><p>In Go 1.20, we added the <a href=\"https://go.dev/pkg/path/filepath#IsLocal\"></a>\nfunction, which reports whether a path is “local”. A “local” path is one which:</p><ul><li>does not escape the directory in which it is evaluated (\"../etc/passwd\" is not allowed);</li><li>is not an absolute path (\"/etc/passwd\" is not allowed);</li><li>is not empty (\"\" is not allowed);</li><li>on Windows, is not a reserved name (“COM1” is not allowed).</li></ul><p>In Go 1.23, we added the <a href=\"https://go.dev/pkg/path/filepath#Localize\"></a>\nfunction, which converts a /-separated path into a local operating system path.</p><p>Programs that accept and operate on potentially attacker-controlled paths should almost\nalways use  or  to validate or sanitize those paths.</p><p>Path sanitization is not sufficient when attackers may have access to part of\nthe local filesystem.</p><p>Multi-user systems are uncommon these days, but attacker access to the filesystem\ncan still occur in a variety of ways.\nAn unarchiving utility that extracts a tar or zip file may be induced\nto extract a symbolic link and then extract a file name that traverses that link.\nA container runtime may give untrusted code access to a portion of the local filesystem.</p><p>Programs may defend against unintended symlink traversal by using the\n<a href=\"https://go.dev/pkg/path/filepath#EvalSymlinks\"><code>path/filepath.EvalSymlinks</code></a>\nfunction to resolve links in untrusted names before validation, but as described\nabove this two-step process is vulnerable to TOCTOU races.</p><p>Before Go 1.24, the safer option was to use a package such as\n<a href=\"https://go.dev/pkg/github.com/google/safeopen\">github.com/google/safeopen</a>,\nthat provides path traversal-resistant functions for opening a potentially-untrusted\nfilename within a specific directory.</p><p>In Go 1.24, we are introducing new APIs in the  package to safely open\na file in a location in a traversal-resistent fashion.</p><p>The new <a href=\"https://go.dev/pkg/os#Root\"></a> type represents a directory somewhere\nin the local filesystem. Open a root with the <a href=\"https://go.dev/pkg/os#OpenRoot\"></a>\nfunction:</p><pre><code>root, err := os.OpenRoot(\"/some/root/directory\")\nif err != nil {\n  return err\n}\ndefer root.Close()\n</code></pre><p> provides methods to operate on files within the root.\nThese methods all accept filenames relative to the root,\nand disallow any operations that would escape from the root either\nusing relative path components (\"..\") or symlinks.</p><pre><code>f, err := root.Open(\"path/to/file\")\n</code></pre><p> permits relative path components and symlinks that do not escape the root.\nFor example,  is permitted. Filenames are resolved using the\nsemantics of the local platform: On Unix systems, this will follow\nany symlink in “a” (so long as that link does not escape the root);\nwhile on Windows systems this will open “b” (even if “a” does not exist).</p><p> currently provides the following set of operations:</p><pre><code>func (*Root) Create(string) (*File, error)\nfunc (*Root) Lstat(string) (fs.FileInfo, error)\nfunc (*Root) Mkdir(string, fs.FileMode) error\nfunc (*Root) Open(string) (*File, error)\nfunc (*Root) OpenFile(string, int, fs.FileMode) (*File, error)\nfunc (*Root) OpenRoot(string) (*Root, error)\nfunc (*Root) Remove(string) error\nfunc (*Root) Stat(string) (fs.FileInfo, error)\n</code></pre><p>In addition to the  type, the new\n<a href=\"https://go.dev/pkg/os#OpenInRoot\"></a> function\nprovides a simple way to open a potentially-untrusted filename within a\nspecific directory:</p><pre><code>f, err := os.OpenInRoot(\"/some/root/directory\", untrustedFilename)\n</code></pre><p>The  type provides a simple, safe, portable API for operating with untrusted filenames.</p><h2>Caveats and considerations</h2><p>On Unix systems,  is implemented using the  family of system calls.\nA  contains a file descriptor referencing its root directory and will track that\ndirectory across renames or deletion.</p><p> defends against symlink traversal but does not limit traversal\nof mount points. For example,  does not prevent traversal of\nLinux bind mounts. Our threat model is that  defends against\nfilesystem constructs that may be created by ordinary users (such\nas symlinks), but does not handle ones that require root privileges\nto create (such as bind mounts).</p><p>On Windows,  opens a handle referencing its root directory.\nThe open handle prevents that directory from being renamed or deleted until the  is closed.</p><p> prevents access to reserved Windows device names such as  and .</p><p>On WASI, the  package uses the WASI preview 1 filesystem API,\nwhich are intended to provide traversal-resistent filesystem access.\nNot all WASI implementations fully support filesystem sandboxing,\nhowever, and ’s defense against traversal is limited to that provided\nby the WASI impementation.</p><p>When GOOS=js, the  package uses the Node.js file system API.\nThis API does not include the openat family of functions,\nand so  is vulnerable to TOCTOU (time-of-check-time-of-use) races in symlink\nvalidation on this platform.</p><p>When GOOS=js, a  references a directory name rather than a file descriptor,\nand does not track directories across renames.</p><p>Plan 9 does not have symlinks.\nOn Plan 9, a  references a directory name and performs lexical sanitization of\nfilenames.</p><p> operations on filenames containing many directory components can be much more expensive\nthan the equivalent non- operation. Resolving “..” components can also be expensive.\nPrograms that want to limit the cost of filesystem operations can use  to\nremove “..” components from input filenames, and may want to limit the number of\ndirectory components.</p><p>You should use  or  if:</p><ul><li>you are opening a file in a directory; AND</li><li>the operation should not access a file outside that directory.</li></ul><p>For example, an archive extractor writing files to an output directory should use\n, because the filenames are potentially untrusted and it would be incorrect\nto write a file outside the output directory.</p><p>However, a command-line program that writes output to a user-specified location\nshould not use , because the filename is not untrusted and may\nrefer to anywhere on the filesystem.</p><p>As a good rule of thumb, code which calls  to combine a fixed directory\nand an externally-provided filename should probably use  instead.</p><pre><code>// This might open a file not located in baseDirectory.\nf, err := os.Open(filepath.Join(baseDirectory, filename))\n\n// This will only open files under baseDirectory.\nf, err := os.OpenInRoot(baseDirectory, filename)\n</code></pre><p>The  API is new in Go 1.24.\nWe expect to make additions and refinements to it in future releases.</p><p>The current implementation prioritizes correctness and safety over performance.\nFuture versions will take advantage of platform-specific APIs, such as\nLinux’s , to improve performance where possible.</p><p>There are a number of filesystem operations which  does not support yet, such as\ncreating symbolic links and renaming files. Where possible, we will add support for these\noperations. A list of additional functions in progress is in\n<a href=\"https://go.dev/issue/67002\">go.dev/issue/67002</a>.</p>","contentLength":8941,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","go"]}