{"id":"EfcLDDAkyqguXw9Vbtcae7fRhxCsY1chPUNLpwbK9oHS42b4dGEMeGvA2hWHB2j3LFSAo7qhibLNgPBcA5djbGp95Jk5T","title":"top scoring links : programming","displayTitle":"Reddit - Programming","url":"https://www.reddit.com/r/programming/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/programming/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Popular GitHub Action `tj-actions/changed-files` has been compromised with a payload that appears to attempt to dump secrets","url":"https://semgrep.dev/blog/2025/popular-github-action-tj-actionschanged-files-is-compromised/","date":1742106264,"author":"/u/alexeyr","guid":409,"unread":true,"content":"<p>Popular GitHub Action <a rel=\"noopener noreferrer\" href=\"https://github.com/tj-actions/changed-files\">tj-actions/changed-files</a>&nbsp;has been compromised (<a rel=\"noopener noreferrer\" href=\"https://github.com/tj-actions/changed-files/issues/2463\">GitHub issue</a>) with a payload that appears to attempt to dump secrets, impacting thousands of CI pipelines.&nbsp;This isn’t the first security issue with tj-actions/changed-files—see prior vulnerability <a rel=\"noopener noreferrer\" href=\"https://www.cve.org/CVERecord?id=CVE-2023-51664\">CVE-2023-51664</a>.</p><ol start=\"2\"><li><p> Switch to a safer alternative or inline your file-change detection logic.</p><ol start=\"1\"><li><p>Just removing it from the main branch of your repository won’t be enough — it could still run on other branches depending on how your actions are configured. So you need to remove it from  branches to be safe.</p></li><li><ol start=\"1\"><li><p>You’ll need a list of GitHub Actions used at your org. Run this query on your codebase:</p><pre><code>$ semgrep -e 'uses: $ACTION' -l yaml --json .github  | jq -r '.results[].extra.metavars[\"$ACTION\"].abstract_content' | grep -vE '^(actions/|docker://|[.]/[.]github/|tj-actions/)' | awk -F'@' '{print $1 \"@*,\"}' | sort | uniq\nDataDog/synthetics-ci-github-action@*,\nactions-rs/toolchain@*,\nastral-sh/setup-uv@*,\naws-actions/amazon-ecr-login@*,</code></pre></li><li><p>Remove tj-actions/changed-files from the list of GitHub Actions.</p></li></ol></li><li><p><strong>Generally, pin all GitHub Actions to specific commit SHAs (rather than version tags) you know are safe.</strong> In this case, it appears that all versions are compromised.</p></li><li><p><strong>Audit past workflow runs for signs of compromise.</strong> Check logs for suspicious outbound network requests. Prioritize repos where your CI runner logs are public, as secrets are dumped to stdout in the payload.</p></li></ol></li></ol>","contentLength":1435,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1jcfchv/popular_github_action_tjactionschangedfiles_has/"},{"title":"Decoding JSON sum types in Go without panicking","url":"https://nicolashery.com/decoding-json-sum-types-in-go/","date":1742100126,"author":"/u/FoxInTheRedBox","guid":405,"unread":true,"content":"<p><em>The Go programming language doesn't have native support for sum types, but we'll see how we can emulate them, how to decode and encode them into JSON, and how in some cases they can help avoid runtime panic exceptions.</em></p><h2 tabindex=\"-1\">Whether we find them useful or not, sum types exist</h2><p>Many languages support sum types natively: <a href=\"https://zig.guide/language-basics/unions/\">Zig</a>, <a href=\"https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions\">TypeScript</a>, <a href=\"https://ocaml.org/docs/basic-data-types#variants\">OCaml</a>, <a href=\"https://doc.rust-lang.org/book/ch06-00-enums.html\">Rust</a>, just to name a few. Even <a href=\"https://swagger.io/specification/#discriminator-object\">OpenAPI has them</a>, the de-facto standard and language-agnostic way to define HTTP APIs using JSON. So even if the programming language you're using doesn't natively support sum types, you may still need to handle a JSON payload over the wire that is modeled as one. This requires deciding how to decode that payload in your language of choice.</p><p>Personal feelings about sum types aside, I think most people would agree they effectively model data structures that can be <em>\"one of these (potentially very different) things, and nothing else\"</em>. And once you've experienced sum types with a  or match expression combined with , it's hard to go back.</p><p>Let's take a primitive type, a boolean or  in Rust. It has 2 possible values:  or  (also called \"cardinality\"). A struct or record is called a  because you can count the number of possible values (or cardinality) by  the number of possible values of each field. So if I have a struct with 2 boolean fields (example here in Rust):</p><pre><code>\n    signed_up\n    subscribed</code></pre><p>The number of possible values for this struct (or \"product type\") is: 2x2 = .</p><p>Now I didn't choose this struct example completely at random. Some of the possible values are not valid in this particular domain: a user can't be  if they are not  as well. You'll also hear the phrase \"make illegal states unrepresentable\" when talking about sum types.</p><p>A  is called that way because... you guessed it. You can count the number of possible values (or cardinality) by  the number of possible values of each branch. So if I have the following sum type (example still in Rust, where they are called \"enums\"):</p><pre><code> subscribed</code></pre><p>The number of possible values for this \"sum type\" is: 1+2 = .</p><p>I'll leave it as an exercise to the reader to discuss and decide which of these two data structures is better adapted for representing this particular domain.</p><h2 tabindex=\"-1\">My first nil pointer panic in Go was due to lack of sum types</h2><p>Ok, that section title is a bit cheeky and probably not entirely true. But when I figured out what caused the panic in my code, the thought \"sum types would've caught this at compile time\"  cross my mind. I'm sure the astute reader could find better ways to structure my first implementation, even without sum types. But humor me for the sake of this article.</p><p>Let me say it now: This is  one of those \"Go should have sum types\" post. A lot has already been written on the topic and I don't want to get into the debate (although you'll probably guess where I stand). Let's just assume I want to  something like sum types in Go, then:</p><ol><li>How do I do so without straying too far from what's idiomatic in the language?</li><li>How do I encode and decode it, to and from JSON, with the structure we'll see below?</li></ol><p>This post is also  a criticism of Go. I came across this issue in my first Go project, and I actually enjoyed working with the language. Having shied away from Go for a while (notably because of lack of sum types), I finally gave it a try because it seemed a good fit for this project. The fast compile times, robust standard library, simplicity of the language, and great developer tooling all delivered on their promise.</p><p>For the anecdote, the first time I ran  was on the sample codebase from <a href=\"https://lets-go-further.alexedwards.net/\">Alex Edward's \"Let's Go Further\" book</a> (excellent book by the way), and I had to run it again because it was so much faster than what I was used to ( Haskell ), I thought nothing had happened.</p><p>Back to the historical context: I'm feeling very productive with Go on this particular project. The feedback loop is amazing, and I have a working proof-of-concept in just a couple of days. Code seems to just slip from my fingers, everything works on the first try, zero values and pointers do not scare me anymore, I just need to add this last thing and... then it hits me:</p><pre><code>2024/12/07 12:16:53 http: panic serving [::1]:60984:\nruntime error: invalid memory address or nil pointer dereference\ngoroutine 4 [running]:\nnet/http.(*conn).serve.func1()\n    /usr/local/go/src/net/http/server.go:1947 +0xb0\npanic({0x100a00f00?, 0x100f19b00?})\n    /usr/local/go/src/runtime/panic.go:785 +0x124\nexample/main.TransformAction(0x14000115e08)\n    /Users/nicolashery/dev/example/main.go:110 +0x1c\nexample/main.(*Server).handleTransformActions(0x140001cad80, {0x100ad6358, 0x14000160380}, 0x140001597c0)\n    /Users/nicolashery/dev/example/main.go:157 +0x20c\n[...]</code></pre><p>Ouch. Having done a lot of Haskell and (strict) TypeScript recently, I had forgotten one could get such runtime errors. But I don't panic (pun intended), and I carefully look at the code mentioned in the stack trace.</p><p>Below is a simplified version of the code for the sake of this article (the actual implementation had bigger structures and more cases). Can you spot the error? You have 5 seconds.</p><pre><code>a Action result  aType  ActionType_CreateObject\n\t\tresult  fmt aObjectType aObjectID aObjectName ActionType_UpdateObject\n\t\tresult  fmt aObjectType aObjectID aObjectName ActionType_DeleteObject\n\t\tresult  fmt aObjectID ActionType_DeleteAllObjects\n\t\tresult  result\n</code></pre><p>Ok, obviously you'll want to  on  to see what it is:</p><pre><code> Action \n\tType   ActionType \n\tObject Object    \n\tID     object Object Action  Action\n\t\tType   ActionType_CreateObject\n\t\tObject objectobject Object Action  Action\n\t\tType   ActionType_UpdateObject\n\t\tObject objectid  Action  Action\n\t\tType ActionType_DeleteObject\n\t\tIDid Action  Action\n\t\tType ActionType_DeleteAllObjects</code></pre><p>Did you see the error? If yes, then you can stop reading now and get back to work. I'm joking. Didn't see it in the allowed time limit? Don't worry, the Go type checker couldn't either.</p><h2 tabindex=\"-1\">Decoding JSON sum types in Go, take one</h2><p>How did I get to the code above, you might wonder? Well, imagine our service is receiving a JSON payload that looks like this:</p><pre><code></code></pre><p>These are all different types of \"actions\", and this JSON representation is not unreasonable. The <a href=\"https://swagger.io/specification/#discriminator-object\">OpenAPI specification</a> has a discriminator \"pet\" example, and the <a href=\"https://redocly.com/learn/openapi/discriminator\">Redocly documentation</a> a \"vehicle\" example, that are similar to this. (I have yet to come across an API with pets so apologies my example will be the less fun, but maybe more realistic.)</p><p>My naive attempt to decode this JSON, because I was in a rush (and maybe also because Copilot suggested it, if I'm being honest), was to create a struct which I call . This is a struct with all possible fields for every action type merged, and using pointers. The zero-value of pointers is  which will be set for fields that are \"unused\" by a particular action type. Here it is in all its glory:</p><pre><code> Action \n\tType   ActionType \n\tObject Object    \n\tID      ActionType \n\tActionType_CreateObject     ActionType \n\tActionType_UpdateObject     ActionType \n\tActionType_DeleteObject     ActionType \n\tActionType_DeleteAllObjects ActionType </code></pre><p>This works because  doesn't care if there are missing fields in the JSON payload, it will just set the zero-value for them:</p><pre><code>actions Action err  jsondataactions err  err\n</code></pre><p>We can also go the other way and call  to encode the struct into the same JSON representation as the snippet above. The  struct tag option will remove fields unused by each action type from the resulting JSON.</p><p>So we're off to the races, what can go wrong with a bag of pointers? Subtle bugs when trying to access a field that is  because unused by that action type, that's what:</p><pre><code> aType  ActionType_CreateObject\n\tresult  fmt aObjectType aObjectID aObjectName ActionType_UpdateObject\n\tresult  fmt aObjectType aObjectID aObjectName ActionType_DeleteObject\n\tresult  fmt aObjectID ActionType_DeleteAllObjects\n\tresult </code></pre><h2 tabindex=\"-1\">How do OpenAPI and Protobuf handle this?</h2><p>I pick myself up after this runtime panic, and have the following genius idea: There are code generators for OpenAPI, if I give them the specification for the <a href=\"https://swagger.io/specification/#discriminator-object\">JSON discriminated union</a> above, what do they output for Go? Also, <a href=\"http://protobuf.dev/\">Protocol Buffers</a> is a popular wire format that is based on code generation, and the <a href=\"https://protobuf.dev/programming-guides/editions/#oneof\">Oneof field</a> looks a lot like a sum type, so what do  generate for Go?</p><p>The OpenAPI schema for an action would look like this:</p><pre><code> object\n   type\n     object\n   string\n    </code></pre><p>If I feed this to the <a href=\"https://openapi-generator.tech/\">OpenAPI Generator</a> (note that I'm using the <code>useOneOfDiscriminatorLookup=true</code> option for better output), I get what I'll call a <em>\"bag of all the branches\"</em>:</p><pre><code> Action \n\tcreateObject     CreateObject\n\tupdateObject     UpdateObject\n\tdeleteObject     DeleteObject\n\tdeleteAllObjects DeleteAllObjects\n CreateObject \n\tObject Object </code></pre><p>It generates an  method for  that:</p><ul><li>first decodes the JSON to check the  field (this is thanks to the <code>useOneOfDiscriminatorLookup=true</code> codegen option)</li><li>according to the value of , it chooses the appropriate branch and decodes the JSON using the corresponding struct (, , etc.)</li></ul><p>Edited for clarity, it looks something like this:</p><pre><code>a Actiondata  tagged \n\t\tType ActionType  err  jsondatatagged err  err\n\t err  taggedType  ActionType_CreateObject\n\t\terr  jsondataacreateObject ActionType_UpdateObject\n\t\terr  jsondataaupdateObject ActionType_DeleteObject\n\t\terr  jsondataadeleteObject ActionType_DeleteAllObjects\n\t\terr  jsondataadeleteAllObjects</code></pre><p>To get the actual underlying value, the generator creates a method (which I'll name  here) that returns the first non-nil pointer:</p><pre><code>a Action any  acreateObject  acreateObject\n\t aupdateObject  aupdateObject\n\t adeleteObject  adeleteObject\n\t adeleteAllObjects  adeleteAllObjects\n\t</code></pre><p>So this is already a big improvement on my  approach. Since the accessor method to the underlying value returns , I'm now checking the  which can be one of the more precise structs (, , etc.):</p><pre><code>action Action result  v  actionCreateObject\n\t\tresult  fmt vObjectType vObjectID vObjectNameUpdateObject\n\t\tresult  fmt vObjectType vObjectID vObjectNameDeleteObject\n\t\tresult  fmt vIDDeleteAllObjects\n\t\tresult  result\n</code></pre><p>Some issues remain though:</p><ul><li>I \"trust\" the  return value of the accessor method to be one of the action structs (, , etc.) and nothing else</li><li>If I add a \"branch\" (i.e. another action type), I can easily forget to update the  statement in </li></ul><p>Another generator that I tried out, <a href=\"https://github.com/oapi-codegen/oapi-codegen\">oapi-codegen</a>, uses a slightly different approach. It holds on to a  and delays the decoding until we call an equivalent of the  accessor method:</p><pre><code> Action \n\tunion jsonRawMessage\n CreateObject \n\tType   \n\tObject Object a Actionany err</code></pre><p>The decoding works essentially the same, first decode enough to check the  field, then according to its value unmarshal into one of the action structs (, , etc.). The <a href=\"https://pkg.go.dev/encoding/json#example-RawMessage-Unmarshal\"> documentation</a> actually has a similar example.</p><p>Since delaying JSON decoding wasn't particularly useful in my case, I didn't choose this route. But I wanted to mention it for completeness' sake.</p><p>What about  (aka \"Protobuf\")? I found the following particularly interesting in their <a href=\"https://pkg.go.dev/encoding/json#example-RawMessage-Unmarshal\">Go generated code guide</a>:</p><blockquote><p>For a oneof field, the protobuf compiler generates a single field with an interface type . It also generates a struct for each of the singular fields within the oneof. These all implement this  interface.</p></blockquote><p>Let's try it out. Even though we're working with a JSON API, a Protobuf definition for our data model could look like this:</p><pre><code> value  create_object  update_object  delete_object  delete_all_objects  object </code></pre><p>The generated code indeed creates an interface  with a single method, as well as an  struct that holds a field with that interface type:</p><pre><code> Action \n\tValue isAction_Value  isAction_Value  Action_CreateObject \n\tCreateObject CreateObject Action_CreateObject</code></pre><p>Now these two code generators, OpenAPI and Protobuf, will be the inspiration for my second attempt at decoding the JSON sum type in a more type-safe way...</p><h2 tabindex=\"-1\">Decoding JSON sum types in Go, take two</h2><p>After a bit of searching on the topic of \"Go sum types\", I stumbled across this: <a href=\"https://github.com/alecthomas/go-check-sumtype\">go-check-sumtype</a>. From the README:</p><blockquote><p>A typical proxy for representing sum types in Go is to use an interface with an unexported method and define each variant of the sum type in the same package to satisfy said interface. This guarantees that the set of types that satisfy the interface is closed at compile time.</p></blockquote><p>This \"interface with an unexported method\" (also called \"sealed interface\", or \"marker interface\") sounded like a reasonable way to do it. And it's also what the Protobuf codegen seems to be using.</p><p>I replaced my single \"bag of all the fields\"  struct with a sealed interface  and a struct for each variant (, , etc.). Each variant struct implements the interface:</p><pre><code> IsAction  CreateObject \n\tObject Object CreateObject UpdateObject \n\tObject Object UpdateObject DeleteObject \n\tID DeleteObject DeleteAllObjects DeleteAllObjects</code></pre><p>Now I am quite pleased. Not only do these action-specific structs provide more type-safety, but if I forget to handle a variant in my  statement (or if I add a new one that implements the sealed interface), the  linter will catch it instead of getting an error at runtime!</p><pre><code>action Action result  v  actionCreateObject\n\t\tresult  fmt vObjectType vObjectID vObjectNameUpdateObject\n\t\tresult  fmt vObjectType vObjectID vObjectNameDeleteObject\n\t\tresult  fmt vIDDeleteAllObjects\n\t\tresult  result\n</code></pre><p>I still needed to figure out how to decode the JSON sum types payload into this interface and structs. You can't unmarshal into an interface value directly, you need to pass a concrete type. So I created a wrapper struct like so:</p><pre><code> Action \n\tvalue IsAction\n</code></pre><p>I also found the <a href=\"https://github.com/nishanths/exhaustive\">exhaustive</a> linter, so why stop at sum types when you can also have enums! I defined one for action types, which are used as \"tags\" in my tagged union, along with the proper methods for JSON and string representations:</p><pre><code> ActionType \n\tActionType_CreateObject ActionType \n\tActionType_UpdateObject\n\tActionType_DeleteObject\n\tActionType_DeleteAllObjects\nt ActionTypet ActionTypedata t ActionType</code></pre><p>I then defined  for my  wrapper struct like so:</p><pre><code>a Actiondata  tag \n\t\tType ActionType  err  jsondatatag err  err\n\t v IsAction\n\t tagType  ActionType_CreateObject\n\t\tv CreateObject ActionType_UpdateObject\n\t\tv UpdateObject ActionType_DeleteObject\n\t\tv DeleteObject ActionType_DeleteAllObjects\n\t\tv DeleteAllObjects err  jsondata v err  err\n\t\n\n\tavalue  v\n\t</code></pre><p>This works similarly to what we saw in the OpenAPI generated code:</p><ul><li>first decode only what is needed in the JSON to check the  field</li><li>second, according to the value of , choose the appropriate variant struct of the sum type (, , etc.) and use it to decode the JSON payload</li></ul><p>For the other way around, I also defined  for the wrapper struct:</p><pre><code>a Action\n\tv  avalue\n\n\tdata err  jsonv err  err\n\t tagged any\n\t err  jsondatatagged err  err\n\t vCreateObject\n\t\ttagged ActionType_CreateObject\n\tUpdateObject\n\t\ttagged ActionType_UpdateObject\n\tDeleteObject\n\t\ttagged ActionType_DeleteObject\n\tDeleteAllObjects\n\t\ttagged ActionType_DeleteAllObjects\n\t jsontagged</code></pre><ul><li>first encode the wrapped interface as JSON (unlike decoding, we can do this because the interface here will be initialized with an underlying concrete type: , , etc.)</li><li>second, to add the tag in the  field, we do a roundtrip: decode into a , add the tag to that map, and re-encode the map into JSON</li></ul><p>Notice that I use the  linter in  to make sure I handle all possible tags, and I use the  linter in  to make sure I handle all possible variant structs. So given I keep the \"enum\" and \"sum type\" up-to-date, I will have exhaustiveness checking in both these methods (in addition to other methods or functions, such as  we saw earlier).</p><p>That's it! Yes, there is a bit of boilerplate, but if one is using Go they are probably already OK with a little boilerplate here and there. Also, between AI coding assistants and other codegen tools, the cost of boilerplate can be mitigated. And finally there is that thing we say, \"code is read (and maintained) much more often than written\"? So I'd argue the added type-safety and the fact that we catch issues at compile time instead of runtime may be worth the tradeoff.</p><h2 tabindex=\"-1\">Alternative implementations</h2><p>Of course, the implementation described above is only  of decoding JSON sum types in Go. Below are a couple alternatives, some of which we've already mentioned.</p><pre><code> Action \n\tcreateObject     CreateObject\n\tupdateObject     UpdateObject\n\tdeleteObject     DeleteObject\n\tdeleteAllObjects DeleteAllObjects\n</code></pre><pre><code> Action \n\tpayload jsonRawMessage\n</code></pre><p>With the \"sealed interface\" approach I ended up using, I also considered an implementation of  that doesn't require an encode/decode roundtrip to add the tag, at the cost of a bit more boilerplate. It uses <a href=\"https://gobyexample.com/struct-embedding\">struct embedding</a> instead (<a href=\"https://github.com/nicolashery/example-tagged-union/blob/main/go/altjson.go\">full example here</a>):</p><pre><code>a Action data  err  v  avalueCreateObject\n\t\ttagged \n\t\t\tType ActionType \n\t\t\tCreateObject\n\t\t\n\t\t\tType         ActionType_CreateObject\n\t\t\tCreateObjectv\n\t\tdata err  jsontagged data err\n</code></pre><p>Finally, it is worth mentioning that there are different ways to represent sum types in JSON, notably:</p><ul><li> (the one used in this article): <code>{\"type\": \"delete_object\", \"id\": \"1\", \"soft_delete\": true}</code></li><li>: <code>{\"type\": \"delete_object\", \"value\": {\"id\": \"1\", \"soft_delete\": true}}</code></li><li>: <code>{\"delete_object\": {\"id\": \"1\", \"soft_delete\": true}}</code></li></ul><p>The naming is taken from the Rust library <a href=\"https://serde.rs/enum-representations.html\">Serde's documentation</a>, which provides a good explanation and examples for each representation.</p><p>All JSON representations are possible with the Go implementation of sum types described in this post (you can find the adjacently tagged <a href=\"https://github.com/nicolashery/example-tagged-union/blob/main/go/altjson.go\">full example here</a>).</p><h2 tabindex=\"-1\">What Go could have been: V lang?</h2><p>I'll let the project's website do its own marketing:</p><blockquote><p>V is very similar to Go. If you know Go, you already know ≈80% of V.</p></blockquote><blockquote><p>[...] V is very similar to Go, and its domain is similar to Rust's [...]</p></blockquote><p>Wait... The simplicity of Go, but with enums and sum types? Yes, please!</p><p>I tried porting my example to V, and I have to admit it works out quite nicely (<a href=\"https://github.com/nicolashery/example-tagged-union/blob/main/vlang/main.v\">full source here</a>):</p><pre><code>\n\tuser\n\tgroup\n\n\tid   \n\tname \n\tobject Object\n\n\tobject Object\n\n\tid  CreateObject  UpdateObject  DeleteObject  DeleteAllObjects\n\naction Action action \n\t\tCreateObject \n\t\tUpdateObject \n\t\tDeleteObject \n\t\tDeleteAllObjects </code></pre><p>The  expression has exhaustiveness checking, of course. And the  sum type decodes from/encodes to JSON right out-of-the box (with the caveat that, at the time of writing, it uses the adjacently tagged representation with no way of configuring it).</p><p>Before getting too excited it is worth noting that V is very much a niche language, and can't be compared to Go's popularity and ecosystem. Our industry works in mysterious ways, who knows why some languages gain traction while others don't. Also, this might have some truth to it:</p><blockquote><p>There are only two kinds of languages: the ones people complain about and the ones nobody uses.</p><p><strong>Bjarne Stroustrup, The C++ Programming Language</strong></p></blockquote><p>Nevertheless, I found the V language interesting! It's a garbage-collected language that seems to have found a sweet spot between Go's simplicity and Rust's powerful type system.</p><h2 tabindex=\"-1\">Examples in other languages</h2><p>If you made it this far, I'll leave you with a link to <a href=\"https://github.com/nicolashery/example-tagged-union\">this repository</a>. It contains an implementation of the example sum type from this article, with JSON encoding/decoding (where applicable), in the following languages:</p><ul></ul>","contentLength":19031,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1jcduqh/decoding_json_sum_types_in_go_without_panicking/"},{"title":"TracePerf: TypeScript-Powered Node.js Logger That Actually Shows You What's Happening","url":"https://github.com/thelastbackspace/traceperf","date":1742070828,"author":"/u/shubhwadekar","guid":406,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1jc4h7d/traceperf_typescriptpowered_nodejs_logger_that/"},{"title":"Were multiple return values Go's biggest mistake?","url":"https://herecomesthemoon.net/2025/03/multiple-return-values-in-go/","date":1742054834,"author":"/u/SophisticatedAdults","guid":408,"unread":true,"content":"<p><strong>tl;dr: ‘Multiple return values’ in Go interact poorly with other language features. We should probably\n                promote them to full-blown tuple types.</strong></p><p>\n              All of this is normal. Sickos like me  discussing perceived shortcomings of programming\n              languages. It’s nothing personal. I like Go, even, despite its shortcomings.\n            </p><p>\n              My personal candidate for Go’s  historical mistake is that of multiple return values,\n              exactly because of how harmless they look.\n              Multiple return values influenced the design of the language (in bad ways), interact poorly with other\n              features, and <em>make the language much more complex than it has to be</em>.\n            </p><p>Exhibit A, multiple return values:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>Looking at this, you’d be forgiven for thinking that Go has ’tuples’ (like Python or Rust).</p><p>\n              It doesn’t. There’s no such thing as a ’tuple’. All Go has is a special case syntax which allows functions\n              to return multiple values at the same time. If you want something that sort of behaves like a tuple in Go,\n              you need to define a struct.</p><p>\n              There’s a few other cases of this ‘multiple return values’ behavior special cased for the built-in\n               operator or when accessing a value from a map or channel.\n            </p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              What I’m complaining about in this screed is that—as a consequence of putting multiple return values into\n              the language and not making them a dedicated tuple type—Go is in a worse state than it had to be, and that\n              all of this was completely avoidable.\n            </p><p>\n              When I use other languages, I tend to be  that whatever one of my functions spits\n              out, I can put it into a list or vector.\n            </p><p>\n              Through the power of Go, it’s impossible to  pass data around without additional ceremony. I\n              can’t overstate how  it is that in the world of Go, calling a function and being able to\n              store the result in a list is the exception, and not the rule.\n            </p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              This (of course) doesn’t compile since  is not a type. Tuples don’t exist. So\n              you  get used to first refactoring all of your functions and defining a whole new struct\n              just to pass some data around. Maybe use two lists? Or a new struct? Amazing.\n            </p><p>This gets significantly more annoying once you try to go concurrent.</p><p>\n              Imagine that you want to spin up some goroutines, have each call\n              <code>func doStuff() (string, error)</code>, and then gather the results. You  pass\n               through a channel since it’s not a standalone type. The usual workaround is\n              to do\n              <a href=\"https://stackoverflow.com/questions/13670818/pair-tuple-data-type-in-go\" target=\"_blank\">whatever this is</a>\n              or to\n              <a href=\"https://herecomesthemoon.net/2025/03/multiple-return-values-in-go/\" target=\"_blank\">define a custom struct</a>:\n            </p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              Let me repeat this: Go—a language famous for its concurrency and uncompromising errors-as-values\n              approach—requires you to define a non-standard wrapper type to handle errors as soon as its most basic\n              synchronization primitive is involved or to store  in a slice.\n            </p><p>In other words, <em>Go’s error handling and concurrency don’t compose</em>.</p><p>Hell, even Go’s built-in containers and error handling don’t compose!</p><p>\n              Like many of Go’s problems, it’s something you can work around, but I don’t think that that’s much of an\n              excuse.\n            </p><p>\n              The whole idea behind Go’s error handling is that . You can pass them around\n              like values, inspect them like values, and they’re handled using the same control flow constructs as\n              everything else.\n            </p><p>\n              So despite errors being values, the return of a function call is  not a value at all.\n              You can’t pass it around, you can’t store it.\n            </p><p>\n              A friend of mine has suggested that he believes that “Rob Pike invented Go as a practical joke.”. That’s a\n              pretty rough way too put it, but I can’t entirely blame him? Why would you design a language where the\n              result of a function call cannot be stored or passed around?\n            </p><p>\n              The problem is that this situation was avoidable—if anyone had thought about this in slightly more detail\n              back in the earliest design days—it would’ve been easy to just promote multiple return values to anonymous\n              structs. Instead that time was, presumably, spent adding nonsense like\n              <a href=\"https://go.dev/tour/basics/7\" target=\"_blank\">named return values</a>.\n            </p><p>\n              This is about . Nothing is ‘simple’ about the fact that calling a function doesn’t\n              return a value. It’s a weird idiosyncrasy. By trying to make the language ‘simple’, you played yourself\n              and added a weird edge case.\n            </p><h2>Iterators and ‘Range over Functions’</h2><p>Here’s a basic example of ranging over functions:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              Just create a constructor function which returns a function which captures variables from the enclosing\n              function scope, and uses them to decide when to call its argument function, thereby determining the\n              behavior of the loop for the end-user. Nothing could possibly be easier. (That’s sarcasm. I find this code\n              hard to read and would’ve preferred an interface-based approach.)\n            </p><p>The Go standard library defines the following types and functions as part of this release:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              Go cannot handle the case of iterating over one or two values in a uniform, parametrized way. It requires\n              , one for handling one value at a time, and one for two values.\n            </p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              Because Go doesn’t have ’tuples’. Why doesn’t Go have tuples? I don’t know—There were\n              <a href=\"https://groups.google.com/g/golang-nuts/c/o8SbEM5GLRw\" target=\"_blank\">some vague discussions in 2009</a>, but it just looks like the Go developers didn’t think of the feature as particularly important. Keeping\n              the language ‘small’ was the higher priority for them.\n            </p><p>\n              Again: This was an attempt to keep the language ‘simple’ which\n              <em>now results in weird, complex edge cases and having to learn twice as many APIs</em>. Congratulations,\n              you tried to simplify and instead just played yourself.\n            </p><p>\n              (Back in the day Go didn’t have generics. Designing a language that interacts poorly with generics under\n              the assumption they’ll never be added was a design tradeoff that probably made sense at the time. Funfact:\n              Go took 5 years until it’s 1.0 release. Rust needed 9 years, and Zig still isn’t there.)\n            </p><p>\n              Take a step back to think about what this means: The designers of the standard library are forced to\n              hardcode specific instances of a type because the language is unable to sufficiently abstract over whether\n              you’re handling one or two values at a time.\n            </p><p>\n              Again: This is not a hard technical problem. There  solutions for this. It’s not even hard if\n              you design a language from the get-go. Go just didn’t implement them.\n            </p><p>\n              Consider what this means for Go’s library ecosystem. If even the standard library easily runs into\n              situations where it’s necessary to <em>work around this limitation</em>, how hard do you think it is a\n              library that does anything slightly fancier? (Again, this limitation extends to error handling, since\n              error handling happens through multiple return values.)\n            </p><p>Warning: Hot opinions ahead, and a bunch of speculation.</p><p>\n              Go’s multiple return value-based error handling was considered to be “good enough”, and prevented the\n              development of a better approach to error handling.\n            </p><p>\n              In reality that could’ve gone either way: The Go developers considered enums and or-operators to be such\n              mysterious, advanced features that there’s no guarantees Go would have ended up with\n              -type based error handling even if multiple return values had never made it into the\n              language.\n            </p><p>For all we know we’d have “Go with exceptions”, which would probably be a step backwards.</p><p>\n              Still: I’ll stand by the fact that multiple return values were a classic ‘worse is better’-type solution\n              that prevented the Go developers from ever  anything even slightly more nuanced,\n              like a\n              <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\" target=\"_blank\">Result type</a> (aka a sum\n              type purely for error handling, i.e. a value which is either a result  an error).\n            </p><p>\n              Instead, we’re stuck with multiple return values-based error handling. I’m sure you’ve seen people\n              complain about the issues with accidental shadowing of variables. Those make it pretty easy to\n              accidentally forget to check errors. Not a big deal but (once again, this is a running theme here)\n              entirely unnecessary.\n            </p><p>\n              Or taking an example from\n              <a href=\"https://www.dolthub.com/blog/2023-08-16-go-pitfalls/#destructuring-multiple-return-values\" target=\"_blank\">here</a>, that code like this compiles:\n            </p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>Or the fact that, no, there’s nothing that stops you from writing functions like this here:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>Is this bad? Well, it’s by design.</p><p>\n              I am not saying Go’s error handling is . It’s okay. It’s decisively mid-tier, which is a\n              bit embarrassing for a modern green-field project. They had an opportunity to do better than this, and\n              they blew it, and  of these issues are downstream of the decision to standardize on\n              multiple return values as the idiomatic way to handle errors.\n            </p><p>\n              I’ll put my own take on what Go’s error handling should have been like in here since it’s my blog post and\n              you cannot stop me. I’m sure some people will heavily disagree. That’s fine. I think that if Go had\n              standardized around this approach to error handling everyone would’ve gotten used to it.\n            </p><p>\n              Simple, just define a  type that has a  method or operator\n              defined on it that either just passes the value or (if an error is present) wraps it and\n              <em>returns from the function.</em></p><p>\n              You can bikeshed the hell out of this one. Make it a postfix operator instead of a method, if you want.\n              Write  or  to make it stand out more, I don’t care.\n            </p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><ol><li>Vastly better interactions with generics.</li><li>\n                Allows you to store  in slices and pass it around however you please.\n              </li><li>Better for static analysis.</li><li>Less verbose, if you care about that. (I honestly don’t.)</li><li>There’s not even a need for sum types if you don’t want them.</li></ol><p>\n              In practice, it’s too late for invasive changes like that: Go has standardized on multiple return values\n              for error handling, and trying to move away from that would be a fool’s errand.\n            </p><p>\n              Since trying to move towards sum-type-based error handling is a nonstarter unless we want to split the\n              language, let’s ask the obvious question: Is there anything that can be done to improve any of the issues\n              outlined in this post?\n            </p><p>Can we at least promote multiple return values to full blown types and allow generics over them?</p><p>Maybe. That’d be cool. I think it’d be an improvement.</p><p>\n              It’s not entirely trivial though, so let me write down some reasons why it’d be hard, and the changes\n              that’d have to be made.\n            </p><p>\n              You might say “But doesn’t Go have strong backwards compatibility guarantees?” Yeah, it does. That’s what\n              makes it hard. If you could just change stuff however you want, it’d be easy.\n            </p><p>\n              That said, <a href=\"https://go.dev/blog/loopvar-preview\" target=\"_blank\">even Go 1.22</a> made a pretty\n              significant change. You can get pretty far as long as you’re willing to say “Old code will continue to\n              mean exactly what it means today: the fix only applies to new or updated code.”,  you provide\n              tools to auto-fix code during a migration from Go 1.N to Go 1.(N+1).\n            </p><p>In other words, it doesn’t sound impossible.</p><p>\n              In Go, multiple return values are ‘unpacked’ via . This makes the following\n              code syntactically ambiguous due to the optional presence value you can extract from maps:\n            </p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              Is this a problem? Eeeeh. It looks like one, but it’s to resolve by just picking one. Since tuples don’t\n              exist in previous versions of Go, old code is just not affected.\n            </p><h4>Multiple Return Value passing</h4><p>Passing multiple return values to a variadic function is currently legal Go code:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>\n              Does this pass the tuple  to bar as the first argument, or does it automatically unpack\n               to pass the fields as first and second argument?\n            </p><p>\n              Moving away from auto-unpacking would be a breaking change, but if we don’t move away from it then\n              .\n            </p><p>\n              The modern solution to that is pretty simple: First, allow tuples to be unpacked like slices are (i.e. you\n              have to write  to unpack the tuple). Second, add  and\n               commands that identify this issue and fix it when upgrading to the most recent edition\n              of Go.\n            </p><p>\n              Honestly? I thought this would be hard, but as far as language changes go, this seems pretty easy, all\n              things considered.\n            </p><p>\n              If you want to dig deeper into this, you can find\n              <a href=\"https://github.com/golang/go/issues/33080\" target=\"_blank\">a bunch</a> of\n              <a href=\"https://github.com/golang/go/issues/64613\" target=\"_blank\">similar</a> Github\n              <a href=\"https://github.com/golang/go/issues/63221\" target=\"_blank\">issues</a> on these topics. I stumbled\n              upon them when doing research for this blog, I’ve not participated in any of them.\n            </p><p>Maybe I should, though. It would be  to see this one issue finally resolved.</p><p>\n              I don’t know for sure how Go ended up in this weird state with ‘multiple return values’, where it’s\n              impossible to pass function results through a channel or into a slice.\n            </p><p>That one is still baffling to me, so here’s me trying to make sense of it.</p><p>\n              My understanding is that multiple return values were part of Go before its public release. Even in the\n              <a href=\"https://go.dev/doc/devel/weekly\" target=\"_blank\">Weekly Snapshot History</a> that goes all the\n              way back to 2009, there’s only a single mention of multiple return values way back in 2010: “cgo: correct\n              multiple return value function invocations (thanks Christian Himpel)”.</p><p>I imagine the situation played out as follows:</p><p>\n              First of all, multiple return values entered the language . Perhaps via the\n               operator, since someone figured that using a traditional\n              <code>for (int i = 0; i &lt; 100; i++)</code>-style loop just to iterate over the elements of an array or\n              map is too error prone, or perhaps just as a convenience feature.\n            </p><p>\n              Then, the gates of hell opened, demons attacked and the world of programming was set back—no, sorry, I am\n              kidding.\n            </p><p>\n              I assume that what actually happened is that multiple return values were just  and\n              quickly became the idiomatic ‘gold-standard’ for error handling, passing values around, and so on.\n            </p><p>\n              At this point I’m sure that someone asked “Hey, why don’t we just promote those to a full-blown tuple\n              type?”, and was shot down with something like “We already have . There should be a\n              single way of doing things. Go is a simple language. Why would we want to have two features that do the\n              same thing?”\n            </p><p>\n              In either case, at this point multiple return values were here to stay, and the feature established itself\n              as the standard for error handling.\n            </p><p>\n              Looking at the oldest internal discussions in Google’s ‘Golang Nuts’ group (just one or three days after\n              the first\n              <a href=\"https://opensource.googleblog.com/2009/11/hey-ho-lets-go.html\" target=\"_blank\">announcement</a>)\n              is interesting. Say\n              <a href=\"https://groups.google.com/g/golang-nuts/c/TTCaIpSxn2U/m/AQklTsAqi7IJ\" target=\"_blank\">here</a> or\n              <a href=\"https://groups.google.com/g/golang-nuts/c/rvGTZSFU8sY/m/ArU_Ef8Nyl0J\" target=\"_blank\">here</a>. I\n              mean it! Go and take a look. Lines such as “Go doesn’t have nullable types, we haven’t seen a lot of\n              demand for them” really puts things into perspective.\n            </p><p>\n              Give it a few years and we enter the present day, and Go is struggling with some of its earliest design\n              decisions. (Evidence: This entire post. Also,\n              <a href=\"https://github.com/golang/go/issues/49085\" target=\"_blank\">generic methods</a> are still\n              <a href=\"https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#No-parameterized-methods\" target=\"_blank\">impossible</a>.)\n            </p><p>\n              Go has these weird special cases (e.g. multiple return values, named return values), decided that ‘and’\n              and ‘or’ are close enough (<a href=\"https://jerf.org/iri/post/2024/go_faq_pipe_in_generics/\" target=\"_blank\">they even made that mistake twice</a>), and many of these problems were <em>intentional design decisions</em> or avoidable.\n            </p><p>\n              The ‘avoidable’ part is a big deal for me. It just feels like a lot of pain could’ve been avoided if Go\n              had spent slightly more time thinking about programming language design.\n            </p><p>\n              Going out on a limb, to me it looks like many of the issues boil down to the question of whether you take\n              types seriously, and are willing to dig into the bare minimum of abstractions to figure out how certain\n              features need to be designed, instead of just making things up as you ™.\n            </p><p>\n              I don’t want to shill for Rust , but one thing that language did well is that it\n               and designed itself around its type system.\n            </p><p> is how it got memory safety without a garbage collector. By\n              <em>moving that information to the type system</em>. This is exactly, intentionally the road that Go\n              didn’t pick.\n            </p><p>\n              Go instead got…multiple return values, which are specifically, intentionally\n              <em>not a type in their own right to keep the language simple</em>. I think this was a bad decision. When\n              it’s easy to codify an abstraction as a type, you  codify it as a type. Go is still\n              learning that lesson today.\n            </p><p>\n              To go out on a positive note—I just spent a whole post complaining about Go, after all—I think that Go is\n              an impressive technical achievement, and set the modern gold standard as far as tooling goes. I am\n              grateful for that. I also really have to respect that its simplicity keeps perfectionism at bay.\n            </p><p>\n              Someday I want to write a post about what I like about Go, but that day is not today. I’ll cross my\n              fingers that tuples are going to be on the list by then.\n            </p>","contentLength":19051,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1jbyghx/were_multiple_return_values_gos_biggest_mistake/"},{"title":"Fired “Kill Switch” Programmer Faces 10 Years In Jail: What Went Wrong?","url":"https://programmers.fyi/fired-kill-switch-programmer-faces-10-years-in-jail-what-went-wrong","date":1742053967,"author":"/u/derjanni","guid":410,"unread":true,"content":"<p>The 55 year old Texan Davis Lu was just <a href=\"https://www.justice.gov/usao-ndoh/pr/texas-man-formerly-employed-ohio-company-convicted-damaging-source-code-and-deleting\" rel=\"noopener ugc nofollow\" target=\"_blank\">sentenced to 10 years in jail</a> for pulling a “kill switch” on his employer EATON Corporation where he was employed as a Senior Software Developer for Emerging Technologies <a href=\"https://www.theregister.com/2025/03/08/developer_server_kill_switch/\" rel=\"noopener ugc nofollow\" target=\"_blank\"></a><a href=\"https://regmedia.co.uk/2025/03/07/lu.pdf\" rel=\"noopener ugc nofollow\" target=\"_blank\"></a>. Davis build apps that would regularly execute a method called “IsDLEnabledinAD” which stands for “Is Davis Lu enabled in Active Directory”. Once that method failed, his apps would wreak havoc on the systems of his employer.</p><p>When Davis Lu was laid off on September 9th, 2019 his “secret server” in Kentucky started to administer his evil plans. It reaked havoc when his account was removed from the company’s Active Directory. His hidden server housed dozens of Java apps, some going by the name of “Hakai” 破壊 <em>(Japanese for “destruction”)</em> and “Hūnshuì” 昏睡 . Lu’s fellow coworkers found the kill switch after his termination when the apps already interrupted thousands of company users and systems causing severe financial damage to his former employer.</p><blockquote><p>“Sadly, Davis Lu used his education, experience, and skill to purposely harm and hinder not only his employer and their ability to safely conduct business, but also stifle thousands of users worldwide,” <em>— FBI Special Agent, Greg Nelsen</em></p></blockquote>","contentLength":1246,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1jby4uu/fired_kill_switch_programmer_faces_10_years_in/"},{"title":"Distributed Locking: A Practical Guide","url":"https://www.architecture-weekly.com/p/distributed-locking-a-practical-guide","date":1742051423,"author":"/u/Adventurous-Salt8514","guid":407,"unread":true,"content":"<p><strong>Was your data ever mysteriously overwritten? No? Think again. Have you noticed conflicting updates to the same data?</strong></p><p><strong>In distributed systems, coordination is crucial. </strong></p><p><strong>A distributed lock ensures that if one actor (node, service instance, etc.) changes a shared resource—like a database record, file, or external service—no other node can step in until the first node is finished.</strong></p><p>Today, we’ll try to discuss it and:</p><ol></ol><p>By the end, you should have a decent grasp of distributed locks, enough to make informed decisions about whether (and how) to use them in your architecture.</p><p><strong>who’s in charge of updating shared data?</strong></p><p>For example, you might have:</p><ul><li><p><strong>Multiple Writers are updating the same table row.</strong><strong>That’s a common issue when updating read models.</strong></p></li></ul><p>Without locks, you can get unpredictable states - like a read model flipping from correct to incorrect or a file partially overwritten by multiple workers. Locks sacrifice a bit of parallelism for the certainty that no two nodes update the same resource simultaneously. In many cases, that’s the safest trade-off, especially if data correctness is paramount.</p><p><a href=\"https://event-driven.io/en/idempotent_command_handling/\" rel=\"\">idempotent actions</a><a href=\"https://www.architecture-weekly.com/p/the-write-ahead-log-a-foundation\" rel=\"\">write-ahead logs</a></p><ol><li><ul><li><p>If no lock currently exists, the node creates one, for instance by setting a Redis key with a time-to-live or by creating an ephemeral zNode in ZooKeeper.</p></li><li><p>If another node is holding the lock, this node either waits, fails immediately, or retries, depending on your chosen policy.</p></li></ul></li><li><p><strong>Crash or Automatic Release</strong></p></li></ol><p>The basic flow would look like:</p><p>And the acquisition part with TTL handling:</p><p>There are many tools for distributed locking; let's check the most popular for certain categories.</p><ul><li><p><strong>Kubernetes Single-Instance</strong></p></li></ul><p>Distributed locks all share a common goal: ensure only one node does a particular thing at any given time. However, each tool mentioned approaches the problem with distinct designs, strengths, and failover behaviours.</p><p>Let’s look at each tool’s big-picture purpose—why you’d even consider it—then move on to how it implements (or approximates) a lock. Lastly, let’s discuss a few technical details that matter once you start coding or troubleshooting.</p><p><strong>Redis runs all commands in a single thread, so there is no risk of two commands interfering partway through.</strong></p><p><strong>Redis runs all commands in a single thread, so there is no risk of two commands interfering partway through. </strong></p><p>To create a lock, you need to create a “lock key” using a Redis command, for instance:</p><pre><code>SET lockKey node123 NX EX 30</code></pre><p>That looks cryptic, but let’s see what’s happening behind the scenes:</p><ol><li><p><strong>Atomic Key Creation with NX. </strong></p></li><li><p><code>SET lockKey node123 NX EX 30</code></p></li><li><p><code>SET lockKey node123 NX EX 30</code></p></li><li><p><strong>Handling Network Partitions. </strong><a href=\"https://redis.io/docs/latest/develop/use/patterns/distributed-locks/\" rel=\"\">Redlock algorithm</a></p></li></ol><p>Choosing Redis may be a good option if you already run a Redis cluster for caching or need a lightweight solution that’s easy to integrate. </p><p>Performance is generally good, though absolute consistency under partitions can require more complex setups.</p><p><strong>ZooKeeper and etcd each run as a cluster of nodes that keep data consistent across a majority of them (a quorum).</strong></p><p><strong>You create something like </strong><strong> in ZooKeeper or a key in etcd.</strong></p><p><strong>When you’re done, you delete the ephemeral node or lease key, signalling that source is available.</strong></p><p>Other clients can “watch” that lock path. If the lock holder crashes, ZooKeeper or etcd detects the session loss and removes the node, instantly notifying watchers that the lock is free again. This allows any waiting client to move in and grab the lock right away.</p><p>If a node is isolated from the quorum, ZooKeeper or etcd eventually considers that session dead and removes the ephemeral node. This auto-frees the lock. The newly updated cluster state reflects that the lock is available, so another node can pick it up.</p><p>If your environment already depends on them for cluster metadata or leader election, reusing them for locks is natural. They replicate data across multiple servers, so updates to the lock state are consistent, reducing the risk of split-brain scenarios. The ephemeral mechanism automatically frees locks if a session dies, so you don’t end up with “zombie” locks after crashes.</p><p><strong>They offer stronger consistency guarantees at the cost of heavier operational overhead compared to Redis.</strong></p><p>Sometimes you’d rather avoid setting up additional infrastructure, like Redis or ZooKeeper, and simply rely on the single relational database you already use. Many SQL databases—PostgreSQL, MySQL, SQL Server, and others—provide built-in locking features that can help you coordinate concurrency directly in your existing environment. There are generally two ways to handle locks in a relational database: </p><ul></ul><p><em>“I want exclusive access to something”</em></p><ol></ol><p>They serve different needs, but both let you say, “I want exclusive access to something,” using your existing DB.</p><p>You can lock specific rows in a table by issuing something like:</p><pre><code><code>BEGIN;\nSELECT * FROM locks WHERE lock_id = @loc_key FOR UPDATE;\n/* make changes */\nCOMMIT;\n</code></code></pre><p>That looks cryptic, but here’s what’s happening. </p><p><em>“Lock this row so nobody else can modify it until I’m done.”</em></p><p><strong>The lock lasts until you commit or roll back the transaction.</strong></p><p>You may also use regular rows instead of a dedicated locks table. It’s natural if your concurrency problem revolves around specific table rows. For others you need to define key that would represent the scope of locking</p><pre><code><code>-- PostgreSQL\nSELECT pg_advisory_lock(12345);\n/* do something exclusive */\nSELECT pg_advisory_unlock(12345);\n</code></code></pre><pre><code><code>-- MySQL\nSELECT GET_LOCK('readModel', 10);\n/* do something exclusive */\nSELECT RELEASE_LOCK('readModel');\n</code></code></pre><p><a href=\"https://www.postgresql.org/docs/current/explicit-locking.html#ADVISORY-LOCKS\" rel=\"\">PostgreSQL Advisory Locks</a></p><p>In many cases, database locks require minimal setup. There’s no need to spin up Redis or ZooKeeper if you already trust a single relational DB for everything. You can use familiar SQL, which can benefit many developers. You get transaction integrations.</p><p><strong>Still, they’re tight to a single database scope.</strong></p><p><strong>The other downside is lock contention.</strong></p><p><strong>You also can get deadlocks</strong></p><p>Sometimes, you don’t need a distributed lock at all—you just need to ensure there’s no possibility of concurrency. In Kubernetes, you can tell the cluster to run exactly one replica of your service. With only one pod, you don’t risk two pods writing to the same resource simultaneously. This approach is straightforward but also very limiting.</p><ul><li><p><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/\" rel=\"\">StatefulSet</a></p></li><li><p><strong>No Parallelism or scaling</strong></p></li></ul><p><strong><a href=\"https://etcd.io/\" rel=\"\">etcd</a></strong><a href=\"https://etcd.io/\" rel=\"\">etcd</a></p><p><strong>In Kubernetes, the mechanisms and controllers designed to manage the number of pods are quite robust, but in highly dynamic or unusual situations, there might be brief moments where conditions could lead to more than one pod being created temporarily.</strong></p><ul><li><p><strong>Rapid Scale-Up and Scale-Down:</strong></p></li><li><p><strong>Network Partitions or etcd Availability Issues:</strong></p></li></ul><p><strong>Why You’d Choose Single-Instance in Kubernetes?</strong></p><p>If you just need to enforce that there’s a single instance processing background job (read model handling, job processing) and you have Kubernetes set up, then it’s a decent choice. You remove the concurrency at all. You don’t spin up Redis or ZooKeeper just to handle locks.</p><p><strong>Still, the race conditions can be dangerous for high traffic or important cases. It’s not fully reliable.</strong></p><p>Here’s my recommended decision-making scheme for locking mechanism:</p><ol><li><p><strong>If you have a single relational DB handling all app state, advisory locks might suffice</strong></p></li><li><p><strong>If your environment already includes a Redis cluster for caching and you want a simpler ephemeral lock, Redis is a natural fit.</strong></p></li><li><p><strong>If concurrency is never desired or is completely out of scope for a specific microservice, AND you’re using already Kubernetes a single-instance Kubernetes approach may be acceptable.</strong></p></li><li><p><strong>If your microservices need advanced coordination (like leader election, watchers, or strongly consistent state), consider ZooKeeper or etcd. </strong></p></li></ol><p>If your system needs to acquire multiple locks at once, you risk deadlocks (e.g., process A has Lock1 and wants Lock2; process B has Lock2 and wants Lock1). The best practice is to lock in a consistent order globally or use carefully designed transaction boundaries. I’ll show you next week how you could use queuing and single writer for that.</p><p>Locks serialize access. If too many services fight for the same lock, your system effectively becomes single-threaded. To avoid bottlenecks, lock only the smallest critical sections. If concurrency at some granularity is acceptable, consider sharding or partitioned locks.</p><ul></ul><p>If you rely on a single Redis instance or a single ZooKeeper node, your lock manager can fail. Always consider using a clustered or highly available setup, such as Redis with sentinel or cluster mode or a ZooKeeper ensemble of three or five nodes.</p><p>Systems like Redlock try to handle partial failures, but no distributed lock can be 100% guaranteed if your network is severely partitioned (CAP theorem territory). You might end up with multiple holders, each believing they’re the only one. Proper design, timeouts, and conflict detection help reduce these edge cases.</p><ol><li><p><strong>Try to avoid distributed locking if you can. </strong></p></li></ol><p>Distributed systems will always have complexities, but a well-implemented distributed lock (or a strategic single-instance approach) can tame the chaos of concurrency—keeping your data consistent and your architecture stable.</p><p><strong>What are your experiences, use cases, and challenges with distributed locking?</strong></p><p>And hey, all the best for Christmas if you celebrate it. If you don’t, try to also get the chance to rest a bit. And if you  don’t want to, that’s fine, as long as you’re happy!</p><p><strong>p.s. Ukraine is still under brutal Russian invasion. A lot of Ukrainian people are hurt, without shelter and need help.</strong><a href=\"https://savelife.in.ua/en/donate/\" rel=\"\">Ukraine humanitarian </a><a href=\"https://www.gofundme.com/f/help-to-save-the-lives-of-civilians-in-a-war-zone\" rel=\"\">Ambulances for Ukraine</a><a href=\"https://redcross.org.ua/en/\" rel=\"\">Red Cross</a></p>","contentLength":9564,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1jbx75z/distributed_locking_a_practical_guide/"}],"tags":["dev","reddit"]}