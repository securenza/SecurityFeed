{"id":"AXJnNj1p7gNGHeShbM5NH2qrEU51AXyHm","title":"Julia Evans","displayTitle":"Dev - Julia Evans","url":"https://jvns.ca/atom.xml","feedLink":"https://jvns.ca/atom.xml","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":2,"items":[{"title":"How to add a directory to your PATH","url":"https://jvns.ca/blog/2025/02/13/how-to-add-a-directory-to-your-path/","date":1739449676,"author":"Julia Evans","guid":46,"unread":true,"content":"<p>I was talking to a friend about how to add a directory to your PATH today. It’s\nsomething that feels “obvious” to me since I’ve been using the terminal for a\nlong time, but when I searched for instructions for how to do it, I actually\ncouldn’t find something that explained all of the steps – a lot of them just\nsaid “add this to ”, but what if you’re not using bash? What if your\nbash config is actually in a different file? And how are you supposed to figure\nout which directory to add anyway?</p><p>So I wanted to try to write down some more complete directions and mention some\nof the gotchas I’ve run into over the years.</p><p>Here’s a table of contents:</p><h3>step 1: what shell are you using?</h3><p>If you’re not sure what shell you’re using, here’s a way to find out. Run this:</p><ul><li>if you’re using , it’ll print out </li><li>if you’re using , it’ll print out </li><li>if you’re using , it’ll print out an error like “In fish, please use\n$fish_pid” ( isn’t valid syntax in fish, but in any case the error\nmessage tells you that you’re using fish, which you probably already knew)</li></ul><p>Also bash is the default on Linux and zsh is the default on Mac OS (as of\n2024). I’ll only cover bash, zsh, and fish in these directions.</p><h3>step 2: find your shell’s config file</h3><ul><li>in zsh, it’s probably </li><li>in bash, it might be , but it’s complicated, see the note in the next section</li><li>in fish, it’s probably <code>~/.config/fish/config.fish</code> (you can run  if you want to be 100% sure)</li></ul><h3>a note on bash’s config file</h3><p>Bash has three possible config files: , , and .</p><p>If you’re not sure which one your system is set up to use, I’d recommend\ntesting this way:</p><ol><li>add  to your </li><li>If you see “hi there”, that means  is being used! Hooray!</li><li>Otherwise remove it and try the same thing with </li><li>You can also try  if the first two options don’t work.</li></ol><p>(there are a lot of elaborate flow charts out there that explain how bash\ndecides which config file to use but IMO it’s not worth it and just testing is\nthe fastest way to be sure)</p><h3>step 3: figure out which directory to add</h3><p>Let’s say that you’re trying to install and run a program called \nand it doesn’t work, like this:</p><pre><code>$ npm install -g http-server\n$ http-server\nbash: http-server: command not found\n</code></pre><p>How do you find what directory  is in? Honestly in general this is\nnot that easy – often the answer is something like “it depends on how npm is\nconfigured”. A few ideas:</p><ul><li>Often when setting up a new installer (like , , , etc),\nwhen you first set it up it’ll print out some directions about how to update\nyour PATH. So if you’re paying attention you can get the directions then.</li><li>Sometimes installers will automatically update your shell’s config file\nto update your  for you</li><li>Sometimes just Googling “where does npm install things?” will turn up the\nanswer</li><li>Some tools have a subcommand that tells you where they’re configured to\ninstall things, like:\n<ul><li>Node/npm:  (then append )</li><li>Go:  (then append )</li><li>asdf: <code>asdf info | grep ASDF_DIR</code> (then append  and )</li></ul></li></ul><h3>step 3.1: double check it’s the right directory</h3><p>Once you’ve found a directory you think might be the right one, make sure it’s\nactually correct! For example, I found out that on my machine,  is\nin . I can make sure that it’s the right directory by trying to\nrun the program  in that directory like this:</p><pre><code>$ ~/.npm-global/bin/http-server\nStarting up http-server, serving ./public\n</code></pre><p>It worked! Now that you know what directory you need to add to your ,\nlet’s move to the next step!</p><h3>step 4: edit your shell config</h3><p>Now we have the 2 critical pieces of information we need:</p><ol><li>Which directory you’re trying to add to your PATH (like  )</li><li>Where your shell’s config is (like , , or <code>~/.config/fish/config.fish</code>)</li></ol><p>Now what you need to add depends on your shell:</p><p>Open your shell’s config file, and add a line like this:</p><pre><code>export PATH=$PATH:~/.npm-global/bin/\n</code></pre><p>(obviously replace  with the actual directory you’re trying to add)</p><p>You can do the same thing as in bash, but zsh also has some slightly fancier\nsyntax you can use if you prefer:</p><pre><code>path=(\n  $path\n  ~/.npm-global/bin\n)\n</code></pre><p>In fish, the syntax is different:</p><pre><code>set PATH $PATH ~/.npm-global/bin\n</code></pre><p>(in fish you can also use , some notes on that <a href=\"https://jvns.ca/blog/2025/02/13/how-to-add-a-directory-to-your-path/#a-note-on-fish-add-path\">further down</a>)</p><h3>step 5: restart your shell</h3><p>Now, an extremely important step: updating your shell’s config won’t take\neffect if you don’t restart it!</p><ol><li>open a new terminal (or terminal tab), and maybe close the old one so you don’t get confused</li><li>Run  to start a new shell (or  if you’re using zsh, or  if you’re using fish)</li></ol><p>I’ve found that both of these usually work fine.</p><p>And you should be done! Try running the program you were trying to run and\nhopefully it works now.</p><p>If not, here are a couple of problems that you might run into:</p><h3>problem 1: it ran the wrong program</h3><p>If the wrong  of a is program running, you might need to add the\ndirectory to the  of your PATH instead of the end.</p><p>For example, on my system I have two versions of  installed, which I\ncan see by running :</p><pre><code>$ which -a python3\n/usr/bin/python3\n/opt/homebrew/bin/python3\n</code></pre><p>The one your shell will use is the .</p><p>If you want to use the Homebrew version, you need to add that directory\n() to the  of your PATH instead, by putting this in\nyour shell’s config file (it’s  instead of the usual )</p><pre><code>export PATH=/opt/homebrew/bin/:$PATH\n</code></pre><pre><code>set PATH ~/.cargo/bin $PATH\n</code></pre><h3>problem 2: the program isn’t being run from your shell</h3><p>All of these directions only work if you’re running the program . If you’re running the program from an IDE, from a GUI, in a cron job,\nor some other way, you’ll need to add the directory to your PATH in a different\nway, and the exact details might depend on the situation.</p><ul><li>use the full path to the program you’re running, like <code>/home/bork/bin/my-program</code></li><li>put the full PATH you want as the first line of your crontab (something like\nPATH=/bin:/usr/bin:/usr/local/bin:….). You can get the full PATH you’re\nusing in your shell by running .</li></ul><p>I’m honestly not sure how to handle it in an IDE/GUI because I haven’t run into\nthat in a long time, will add directions here if someone points me in the right\ndirection.</p><h3>problem 3: duplicate  entries making it harder to debug</h3><p>If you edit your path and start a new shell by running  (or , or\n), you’ll often end up with duplicate  entries, because the shell\nkeeps adding new things to your  every time you start your shell.</p><p>Personally I don’t think I’ve run into a situation where this kind of\nduplication breaks anything, but the duplicates can make it harder to debug\nwhat’s going on with your  if you’re trying to understand its contents.</p><p>Some ways you could deal with this:</p><ol><li>If you’re debugging your , open a new terminal to do it in so you get\na “fresh” state. This should avoid the duplication.</li><li>Deduplicate your  at the end of your shell’s config  (for example in\nzsh apparently you can do this with )</li><li>Check that the directory isn’t already in your  when adding it (for\nexample in fish I believe you can do this with <code>fish_add_path --path /some/directory</code>)</li></ol><p>How to deduplicate your  is shell-specific and there isn’t always a\nbuilt in way to do it so you’ll need to look up how to accomplish it in your\nshell.</p><h3>problem 4: losing your history after updating your </h3><p>Here’s a situation that’s easy to get into in bash or zsh:</p><ol><li>Run  to reload your config</li><li>Press the up arrow a couple of times to rerun the failed command (or open a new terminal)</li><li>The failed command isn’t in your history! Why not?</li></ol><p>This happens because in bash, by default, history is not saved until you exit\nthe shell.</p><p>Some options for fixing this:</p><ul><li>Instead of running  to reload your config, run  (or\n in zsh). This will reload the config inside your current\nsession.</li><li>Configure your shell to continuously save your history instead of only saving\nthe history when the shell exits. (How to do this depends on whether you’re\nusing bash or zsh, the history options in zsh are a bit complicated and I’m\nnot exactly sure what the best way is)</li></ul><p>When you install  (Rust’s installer) for the first time, it gives you\nthese instructions for how to set up your PATH, which don’t mention a specific\ndirectory at all.</p><pre><code>This is usually done by running one of the following (note the leading DOT):\n\n. \"$HOME/.cargo/env\"        \t# For sh/bash/zsh/ash/dash/pdksh\nsource \"$HOME/.cargo/env.fish\"  # For fish\n</code></pre><p>The idea is that you add that line to your shell’s config, and their script\nautomatically sets up your  (and potentially other things) for you.</p><p>This is pretty common (for example <a href=\"https://github.com/Homebrew/install/blob/deacfa6a6e62e5f4002baf9e1fac7a96e9aa5d41/install.sh#L1072-L1087\">Homebrew</a> suggests you eval ), and there are\ntwo ways to approach this:</p><ol><li>Just do what the tool suggests (like adding  to your shell’s config)</li><li>Figure out which directories the script they’re telling you to run would add\nto your PATH, and then add those manually. Here’s how I’d do that:\n<ul><li>Run  in my shell (or the fish version if using fish)</li><li>Run <code>echo \"$PATH\" | tr ':' '\\n' | grep cargo</code> to figure out which directories it added</li><li>See that it says  and shorten that to </li><li>Add the directory  to PATH (with the directions in this post)</li></ul></li></ol><p>I don’t think there’s anything wrong with doing what the tool suggests (it\nmight be the “best way”!), but personally I usually use the second approach\nbecause I prefer knowing exactly what configuration I’m changing.</p><p>fish has a handy function called  that you can run to add a directory to your  like this:</p><pre><code>fish_add_path /some/directory\n</code></pre><p>This is cool (it’s such a simple command!) but I’ve stopped using it for a couple of reasons:</p><ol><li>Sometimes  will update the  for every session in the\nfuture (with a “universal variable”) and sometimes it will update the \njust for the current session and it’s hard for me to tell which one it will\ndo. In theory the docs explain this but I could not understand them.</li></ol><p>Hopefully this will help some people. Let me know (on Mastodon or Bluesky) if\nyou there are other major gotchas that have tripped you up when adding a\ndirectory to your PATH, or if you have questions about this post!</p>","contentLength":9872,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Some terminal frustrations","url":"https://jvns.ca/blog/2025/02/05/some-terminal-frustrations/","date":1738774620,"author":"Julia Evans","guid":45,"unread":true,"content":"<blockquote><p>What’s the most frustrating thing about using the terminal for you?</p></blockquote><p>1600 people answered, and I decided to spend a few days categorizing all the\nresponses. Along the way I learned that classifying qualitative data is not\neasy but I gave it my best shot. I ended up building a custom\n<a href=\"https://github.com/jvns/classificator\">tool</a> to make it faster to categorize\neverything.</p><p>As with all of my surveys the methodology isn’t particularly scientific. I just\nposted the survey to Mastodon and Twitter, ran it for a couple of days, and got\nanswers from whoever happened to see it and felt like responding.</p><p>Here are the top categories of frustrations!</p><p>I think it’s worth keeping in mind while reading these comments that</p><ul><li>40% of people answering this survey have been using the terminal for </li><li>95% of people answering the survey have been using the terminal for at least 4 years</li></ul><p>These comments aren’t coming from total beginners.</p><p>Here are the categories of frustrations! The number in brackets is the number\nof people with that frustration. I’m mostly writing this up for myself because\nI’m trying to write a zine about the terminal and I wanted to get a sense for\nwhat people are having trouble with.</p><p>People talked about struggles remembering:</p><ul><li>the syntax for CLI tools like awk, jq, sed, etc</li><li>keyboard shortcuts for tmux, text editing, etc</li></ul><blockquote><p>There are just so many little “trivia” details to remember for full\nfunctionality. Even after all these years I’ll sometimes forget where it’s 2\nor 1 for stderr, or forget which is which for  and .</p></blockquote><h3>switching terminals is hard (91)</h3><p>People talked about struggling with switching systems (for example home/work\ncomputer or when SSHing) and running into:</p><ul><li>OS differences in keyboard shortcuts (like Linux vs Mac)</li><li>systems which don’t have their preferred text editor (“no vim” or “only vim”)</li><li>different versions of the same command (like Mac OS grep vs GNU grep)</li><li>a shell they aren’t used to (“the subtle differences between zsh and bash”)</li></ul><p>as well as differences inside the same system like pagers being not consistent\nwith each other (git diff pagers, other pagers).</p><blockquote><p>I got used to fish and vi mode which are not available when I ssh into\nservers, containers.</p></blockquote><p>Lots of problems with color, like:</p><ul><li>programs setting colors that are unreadable with a light background color</li><li>finding a colorscheme they like (and getting it to work consistently across different apps)</li><li>color not working inside several layers of SSH/tmux/etc</li><li>not wanting color at all and struggling to turn it off</li></ul><p>This comment felt relatable to me:</p><blockquote><p>Getting my terminal theme configured in a reasonable way between the terminal\nemulator and fish (I did this years ago and remember it being tedious and\nfiddly and now feel like I’m locked into my current theme because it works\nand I dread touching any of that configuration ever again).</p></blockquote><p>Half of the comments on keyboard shortcuts were about how on Linux/Windows, the\nkeyboard shortcut to copy/paste in the terminal is different from in the rest\nof the OS.</p><p>Some other issues with keyboard shortcuts other than copy/paste:</p><ul><li>using  in a browser-based terminal and closing the window</li><li>the terminal only supports a limited set of keyboard shortcuts (no\n, no , no , lots of  shortcuts aren’t\npossible like )</li><li>the OS stopping you from using a terminal keyboard shortcut (like by default\nMac OS uses  for something else)</li><li>issues using emacs in the terminal</li><li>backspace not working (2)</li></ul><h3>other copy and paste issues (75)</h3><p>Aside from “the keyboard shortcut for copy and paste is different”, there were\na lot of OTHER issues with copy and paste, like:</p><ul><li>how tmux and the terminal emulator both do copy/paste in different ways</li><li>dealing with many different clipboards (system clipboard, vim clipboard, the\n“middle click” clipboard on Linux, tmux’s clipboard, etc) and potentially\nsynchronizing them</li><li>random spaces added when copying from the terminal</li><li>pasting multiline commands which automatically get run in a terrifying way</li><li>wanting a way to copy text without using the mouse</li></ul><p>There were lots of comments about this, which all came down to the same basic\ncomplaint – it’s hard to discover useful tools or features! This comment kind of\nsummed it all up:</p><blockquote><p>How difficult it is to learn independently. Most of what I know is an\nassorted collection of stuff I’ve been told by random people over the years.</p></blockquote><h3>steep learning curve (44)</h3><p>A lot of comments about it generally having a steep learning curve. A couple of\nexample comments:</p><blockquote><p>After 15 years of using it, I’m not much faster than using it than I was 5 or\nmaybe even 10 years ago.</p></blockquote><blockquote><p>That I know I could make my life easier by learning more about the shortcuts\nand commands and configuring the terminal but I don’t spend the time because it\nfeels overwhelming.</p></blockquote><p>Some issues with shell history:</p><ul><li>history not being shared between terminal tabs (16)</li><li>limits that are too short (4)</li><li>history not being restored when terminal tabs are restored</li><li>losing history because the terminal crashed</li><li>not knowing how to search history</li></ul><blockquote><p>It wasted a lot of time until I figured it out and still annoys me that\n“history” on zsh has such a small buffer;  I have to type “history 0” to get\nany useful length of history.</p></blockquote><ul><li>documentation being generally opaque</li><li>lack of examples in man pages</li><li>programs which don’t have man pages</li></ul><p>Here’s a representative comment:</p><blockquote><p>Finding good examples and docs. Man pages often not enough, have to wade\nthrough stack overflow</p></blockquote><p>A few issues with scrollback:</p><ul><li>programs printing out too much data making you lose scrollback history</li><li>resizing the terminal messes up the scrollback</li><li>GUI programs that you start in the background printing stuff out that gets in\nthe way of other programs’ outputs</li></ul><blockquote><p>When resizing the terminal (in particular: making it narrower) leads to\nbroken rewrapping of the scrollback content because the commands formatted\ntheir output based on the terminal window width.</p></blockquote><p>Lots of comments about how the terminal feels hampered by legacy decisions and\nhow users often end up needing to learn implementation details that feel very\nesoteric. One example comment:</p><blockquote><p>Most of the legacy cruft, it would be great to have a green field\nimplementation of the CLI interface.</p></blockquote><p>Lots of complaints about POSIX shell scripting. There’s a general feeling that\nshell scripting is difficult but also that switching to a different less\nstandard scripting language (fish, nushell, etc) brings its own problems.</p><blockquote><p>Shell scripting. My tolerance to ditch a shell script and go to a scripting\nlanguage is pretty low. It’s just too messy and powerful. Screwing up can be\ncostly so I don’t even bother.</p></blockquote><p>Some more issues that were mentioned at least 10 times:</p><ul><li>(31) inconsistent command line arguments: is it -h or help or –help?</li><li>(24) keeping dotfiles in sync across different systems</li><li>(23) performance (e.g. “my shell takes too long to start”)</li><li>(20) window management (potentially with some combination of tmux tabs, terminal tabs, and multiple terminal windows. Where did that shell session go?)</li><li>(17) generally feeling scared/uneasy (“The debilitating fear that I’m going\nto do some mysterious Bad Thing with a command and I will have absolutely no\nidea how to fix or undo it or even really figure out what happened”)</li><li>(16) terminfo issues (“Having to learn about terminfo if/when I try a new terminal emulator and ssh elsewhere.”)</li><li>(16) lack of image support (sixel etc)</li><li>(15) SSH issues (like having to start over when you lose the SSH connection)</li><li>(15) various tmux/screen issues (for example lack of integration between tmux and the terminal emulator)</li><li>(13) the terminal getting messed up for various reasons (pressing , ing a binary, etc)</li><li>(12) quoting/escaping in the shell</li><li>(11) various Windows/PowerShell issues</li></ul><p>There were also 122 answers to the effect of “nothing really” or “only that I\ncan’t do EVERYTHING in the terminal”</p><blockquote><p>Think I’ve found work arounds for most/all frustrations</p></blockquote><p>I’m not going to make a lot of commentary on these results, but here are a\ncouple of categories that feel related to me:</p><ul><li>remembering syntax &amp; history (often the thing you need to remember is something you’ve run before!)</li><li>discoverability &amp; the learning curve (the lack of discoverability is definitely a big part of what makes it hard to learn)</li><li>“switching systems is hard” &amp; “it feels outdated” (tools that haven’t really\nchanged in 30 or 40 years have many problems but they do tend to be always\n no matter what system you’re on, which is very useful and makes them\nhard to stop using)</li></ul><p>Trying to categorize all these results in a reasonable way really gave me an\nappreciation for social science researchers’ skills.</p>","contentLength":8518,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}