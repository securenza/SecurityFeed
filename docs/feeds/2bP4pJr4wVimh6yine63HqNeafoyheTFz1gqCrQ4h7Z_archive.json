{"id":"2bP4pJr4wVimh6yine63HqNeafoyheTFz1gqCrQ4h7Z","title":"AlgoMaster Newsletter","displayTitle":"Dev - Algomaster","url":"https://blog.algomaster.io/feed","feedLink":"https://blog.algomaster.io/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":3,"items":[{"title":"Top 15 Database Scaling Techniques","url":"https://blog.algomaster.io/p/top-15-database-scaling-techniques","date":1742100801,"author":"Ashish Pratap Singh","guid":483,"unread":true,"content":"<p>When your application is small, with just a few hundred users, a  is usually enough to handle all the reads, writes, and transactions.</p><p>But as your , so does the volume of data and database operations. More users mean more queries per second, more concurrent connections, and larger datasets.</p><p>If you don't scale your database to handle the increased load, it can  your app and cause problems.</p><p>In this article we will explore the <strong>15 Database Scaling Techniques</strong> to ensure your application keeps operating at optimal performance without the database becoming a bottleneck.</p><p>, also known as , is the process of increasing the capacity of a single database server by adding more resources—CPU, RAM, disk storage, or network bandwidth.</p><ol><li><p> – You replace the existing machine with a higher-capacity one. This might involve switching to a server with more CPU cores, higher memory, or better disk performance (e.g., moving from HDDs to NVMe SSDs).</p></li><li><p><strong>Increasing Resource Allocations</strong> – If you're using a cloud provider (AWS, GCP, Azure), you can resize instances dynamically. For example, upgrading from an AWS RDS  instance to a  instance.</p></li><li><p><strong>Database Engine Optimizations</strong> – Tuning configurations such as increasing buffer pool size in MySQL () or allocating more shared memory in PostgreSQL ().</p></li><li><p> – Moving from traditional HDDs to SSDs or leveraging NVMe storage to reduce disk I/O bottlenecks.</p></li></ol><h3><strong>When Should You Consider Using Vertical Scaling?</strong></h3><ul><li><p>When your workload fits within the limits of a single machine and you want  without introducing the complexity of distributed databases.</p></li><li><p>When , and distributing queries across multiple nodes introduces unwanted overhead.</p></li><li><p>When your application is still , and horizontal scaling (sharding or replication) is unnecessary.</p></li><li><p>When you need a <strong>quick and cost-effective solution</strong> in the short term without redesigning the system architecture.</p></li></ul><h3><strong>Limitations of Vertical Scaling</strong></h3><ol><li><p> – There's a ceiling to how much you can scale a single machine. Even the largest cloud instance has limits.</p></li><li><p> – A vertically scaled database is a single machine. If it crashes, everything goes down unless there's a failover mechanism.</p></li><li><p><strong>Expensive Beyond a Certain Point</strong> – The cost of high-end machines grows exponentially. A top-tier AWS RDS instance can cost thousands of dollars per month.</p></li><li><p> – Increasing CPU, memory, or disk space often requires downtime, especially in on-premise setups.</p></li></ol><blockquote><p>Vertical scaling is <strong>simple, effective, and easy to implement</strong>, making it a great first step for scaling a database. However, as traffic grows, a single machine will eventually hit a hard limit, forcing a move toward <strong>horizontal scaling techniques</strong> like sharding or replication.</p></blockquote><p> is a technique used to <strong>speed up database queries</strong> by creating a data structure that allows for faster lookups. Instead of scanning the entire table to find relevant rows, an index acts like a  in a book—helping the database locate data quickly.</p><p>Imagine searching for a word in a dictionary. Without an index, you’d have to read every page. But with an alphabetically sorted index, you can jump directly to the correct section. That’s exactly how a database index works.</p><p>Creating an index on a single column that is frequently used in  clauses. Example:</p><pre><code>CREATE INDEX idx_users_email ON users(email);</code></pre><p>An index on multiple columns, useful when queries filter by multiple conditions. Example:</p><pre><code>CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);</code></pre><h3><strong>When Should You Consider Using Indexing?</strong></h3><ul><li><p>When queries frequently  by a specific column (, , ).</p></li><li><p>When performing  on large tables.</p></li><li><p>When optimizing , where fast lookups are more critical than fast writes.</p></li></ul><ol><li><p> – Every , , or  operation must also update the index, increasing overhead.</p></li><li><p> – Indexes consume additional disk space, sometimes larger than the actual table.</p></li><li><p><strong>Not Useful for Every Query</strong> – If a query retrieves a large portion of the table, an index may not help and could even slow it down.</p></li><li><p> – Too many indexes can slow down performance instead of improving it. Choosing the right indexes is key.</p></li></ol><blockquote><p>Indexing is one of the most powerful ways to scale a database <strong>without adding more hardware</strong>. However, it requires careful planning. The  can improve query performance by orders of magnitude, while  can slow down writes and waste storage.</p></blockquote><p> is the process of storing frequently accessed data in a  to reduce database load and improve response times. Instead of repeatedly querying the database for the same data, applications can retrieve it from a , which is significantly faster.</p><p>There are multiple <a href=\"https://blog.algomaster.io/p/top-5-caching-strategies-explained\">caching strategies</a> (read through, cache aside, write back etc.,) each suited for different use cases.</p><p>The  pattern is widely used because it gives the application full control over caching logic.</p><ul><li><p>When a client requests data, the application first checks the cache.</p></li><li><p>If the data exists in cache (), it is returned instantly.</p></li><li><p>If data is not found (), it is fetched from the database, stored in the cache for future requests, and returned to the client.</p></li></ul><h4><strong>Content Delivery Network (CDN) Caching</strong></h4><p>For web applications, static content (images, videos, scripts) is cached at CDN edge servers, reducing database and server load.</p><h3><strong>When Should You Consider Using Caching?</strong></h3><ul><li><p>When the <strong>same data is frequently accessed</strong>, such as user profiles, product catalogs, or search results.</p></li><li><p>When you need , especially for real-time applications.</p></li><li><p>When your database is experiencing  and you want to reduce direct database queries.</p></li><li><p>When serving  like images, CSS, and JavaScript in web applications.</p></li></ul><ol><li><p> – If the cache is not updated when the database changes, users might see outdated information.</p></li><li><p><strong>Cache Invalidation Complexity</strong> – Deciding when to refresh or expire cached data is challenging.</p></li><li><p> – Caching requires additional memory (RAM), which can be expensive at scale.</p></li><li><p><strong>Not Ideal for Write-Heavy Applications</strong> – Since caches mainly optimize read performance, write-heavy applications don’t benefit as much.</p></li></ol><blockquote><p>Caching is one of the most effective database scaling techniques because it <strong>reduces query load and improves response times</strong>. However, it requires <strong>careful cache invalidation strategies</strong> to ensure data consistency.</p></blockquote>","contentLength":6084,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/42a63987-4801-4374-81ca-d8453943b6c7_1238x874.png","enclosureMime":"","commentsUrl":null},{"title":"REST vs GraphQL","url":"https://blog.algomaster.io/p/rest-vs-graphql","date":1741668622,"author":"Ashish Pratap Singh","guid":482,"unread":true,"content":"<p> are the backbone of modern applications, acting as the bridge between <strong>client applications and backend servers</strong>.</p><p>Among the many API design choices,  and  have emerged as two dominant approaches.</p><p>Both offer powerful ways to retrieve and manipulate data, but they are built on fundamentally different philosophies.</p><p>REST, a time-tested architectural style, structures APIs around <strong>fixed endpoints and HTTP methods</strong>, making it intuitive and widely adopted. </p><p>On the other hand, GraphQL, a newer query language developed by Facebook, takes a more <strong>flexible and efficient approach</strong>, allowing clients to request exactly the data they need in a single request.</p><p>In this article, we’ll break down REST and GraphQL, compare their differences, and help you decide which one is best suited for your use case.</p><p> emerged in the early 2000s as a set of architectural principles for designing networked applications.</p><p>REST is not a protocol or standard but rather a <strong>set of guiding principles</strong> that leverage the existing  to enable communication between clients and servers.</p><p>At its core, REST is built around . Each resource (such as a user, order, or product) is uniquely identified by a Uniform Resource Locator, and clients interact with these resources using a <strong>fixed set of HTTP methods</strong>.</p><ul><li><p> → Retrieve a resource (e.g.,  to fetch user data).</p></li><li><p> → Create a new resource (e.g.,  to add a new user).</p></li><li><p> → Update an existing resource (e.g.,  to update user details).</p></li><li><p> → Remove a resource (e.g.,  to delete a user).</p></li></ul><p>For example, let’s say a client needs information about a specific user with .</p><ul><li><p>The client makes a request</p></li><li><p>The server responds with a JSON representation of the user</p></li></ul><p>REST APIs typically  and use  to communicate the outcome of the request:</p><ul><li><p> → Resource successfully created</p></li><li><p> → Client error (e.g., missing required fields)</p></li><li><p> → Requested resource does not exist</p></li><li><p><strong>500 Internal Server Error</strong> → Unexpected server issue</p></li></ul><ul><li><p><strong>Simplicity and Intuitive Design</strong>: The resource-based model aligns well with most business domains, making REST intuitive for developers.</p></li><li><p>: Each request contains all the information needed to complete it, making REST scalable across distributed systems.</p></li><li><p>: HTTP's caching mechanisms can be leveraged to improve performance.</p></li><li><p>REST APIs can be easily scaled using load balancers and CDNs.</p></li><li><p>: With nearly two decades of widespread use, REST enjoys robust tooling, documentation, and developer familiarity.</p></li></ul><ul><li><p>REST endpoints often return , leading to inefficient network usage. For example, if a mobile app only needs a user’s name and email, but the API response includes additional fields like address, phone number, and metadata, it results in .</p></li><li><p>: If an API doesn’t return related data, the client may need to  to retrieve all required information. For example, to get user details and their posts, a client might have to make:</p><ol><li><p> (fetch user)</p></li><li><p> (fetch user’s posts)</p></li></ol></li><li><p>: When APIs evolve, maintaining backward compatibility becomes difficult. REST APIs often require  (, ), adding maintenance overhead.</p></li><li><p><strong>Rigid Response Structure:</strong> The server defines how data is returned, and clients must adapt to it—even if they only need a subset of the data.</p></li></ul><p>For years,  was the de facto standard for building APIs. However, as applications grew more complex, REST began to show limitations—especially in scenarios where clients needed fine-grained control over the data they fetched.</p><p>To address these challenges, <strong>Facebook introduced GraphQL in 2015</strong>, offering a more flexible and efficient approach to data retrieval.</p><p>Unlike REST, which organizes APIs around <strong>fixed endpoints and HTTP methods</strong>, GraphQL is a  that allows clients to request exactly the data they need—nothing more, nothing less.</p><blockquote><p>A  () replaces multiple REST endpoints, allowing clients to structure their own queries instead of relying on predefined responses.</p></blockquote><p>Here, the query asks for a <strong>specific user's firstName, email, profileUrl and posts</strong>, all within a </p><p>GraphQL aggregates the data from multiple services and returns precisely the requested data.</p><p>It solves the problems of  (getting unnecessary data) and  (requiring multiple requests to retrieve related data).</p><p>Unlike REST, where API responses are  and may vary across versions, <strong>GraphQL enforces a strict schema</strong> that defines the shape of the data.</p><p>A simple GraphQL schema for the above example might look like this:</p><pre><code>type User {\n  id: ID!\n  firstName: String!\n  lastName: String!\n  email: String!\n  profile: Profile!\n  posts: [Post!]\n}\n\ntype Profile {\n  id: ID!\n  url: String!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  publishedDate: String!\n  content: String!\n  author: User!\n}\n\ntype Query {\n  user(id: ID!): User\n  posts: [Post!]!\n}</code></pre><h3>Three Core Functionalities of GraphQL</h3><p>GraphQL provides three core functionalities:</p><p>Similar to GET requests in REST, GraphQL queries allow clients to request specific fields of data.</p><p>Clients have full control over what they retrieve, avoiding unnecessary data fetching.</p><p><strong>Example: Fetching specific user and post details in a single request</strong></p><pre><code>query {\n  user(id: 123) {\n    name\n    email\n    posts {\n      title\n      content\n    }\n  }\n}</code></pre><p>Equivalent to <strong>POST, PUT, PATCH, or DELETE</strong> in REST. Used to <strong>create, update, or delete</strong> resources in the API.</p><p><strong>Example: Creating a new post</strong></p><pre><code>mutation {\n  createPost(title: \"GraphQL vs REST\", content: \"GraphQL solves many of REST's limitations...\", publishedDate: \"2025-03-10\") {\n    id\n    title\n    content\n  }\n}</code></pre><p>The response will contain the newly created post with its .</p><h4>3.  → Real-Time Updates</h4><p>Unlike REST, which requires polling or WebSockets for real-time updates, GraphQL subscriptions enable clients to listen for changes and receive updates automatically when data is modified.</p><p>Ideal for chat applications, live feeds, stock market updates, and notifications.</p><p><strong>Example: Listening for new posts</strong></p><pre><code>subscription {\n  newPost {\n    title\n    content\n    author {\n      name\n    }\n  }\n}</code></pre><p>Whenever a , all subscribed clients will .</p><h3><strong>How GraphQL Differs from REST</strong></h3><p>Both GraphQL and REST rely on <strong>HTTP requests and responses</strong>, but they differ in how they structure and deliver data.</p><ul><li><p>REST centers around resources (each identified by a URL).</p></li><li><p>GraphQL centers around a schema that defines the types of data available.</p></li></ul><p>In REST, the  decides which data is included in a response. If a client requests a blog post, the API might also return related , even if they aren’t needed.</p><p>With GraphQL, the  what to fetch. This makes GraphQL more flexible but also introduces challenges in <strong>caching and performance optimization</strong>.</p><ol><li><p>: Clients can request only the fields they need, reducing over-fetching and under-fetching.</p></li><li><p><strong>Single Request for Multiple Resources</strong>: Related data can be retrieved in one request, solving REST’s  query problem.</p></li><li><p>: GraphQL APIs use a schema to define available data, making them easier to explore and document.</p></li><li><p><strong>Real-time Data with Subscriptions:</strong> GraphQL natively supports real-time data updates through subscriptions, enabling clients to receive automatic notifications whenever data changes on the server.</p></li><li><p><strong>API Evolution Without Versioning</strong>: New fields can be added without breaking existing queries, avoiding REST-style ,  versioning issues.</p></li></ol><ol><li><p>: Unlike REST, which can be used with basic HTTP clients (cURL, browsers), GraphQL requires a GraphQL server, schema, and resolvers.</p></li><li><p>: REST APIs leverage HTTP caching (e.g., browser caching, CDNs), but GraphQL queries use POST requests, making caching trickier.</p></li><li><p> Since clients can request arbitrary amounts of data, GraphQL APIs must be carefully optimized to prevent performance issues.</p></li><li><p> Unoptimized queries (e.g., deeply nested requests) can lead to costly database scans, increasing the risk of denial-of-service (DoS) attacks.</p></li></ol><h3>Performance Risks with GraphQL</h3><p>Imagine a mobile app introduces a  that unexpectedly triggers a  on a critical database table.</p><p>With REST, this scenario is less likely because API endpoints are predefined, and developers control how data is exposed.</p><p>With GraphQL, the client , which could inadvertently request massive amounts of data. If a poorly designed query is executed on a high-traffic service, it could <strong>bring down the entire database</strong>.</p><p>To mitigate this, GraphQL APIs require <strong>strict query rate limiting, depth restrictions, and cost analysis mechanisms</strong>—adding additional complexity to the implementation.</p><p>There is no  answer.  remains a great choice for simple APIs, while  is powerful for complex applications with varying data needs.</p><p>Ultimately, it’s not about which is better, but which is better for your specific needs.</p><ul><li><p>Your API is simple and doesn’t require flexible queries.</p></li><li><p>You need caching benefits from HTTP. </p></li><li><p>You need a standardized, well-established API  approach.</p></li><li><p>You’re integrating with third-party services.</p></li><li><p>Your team is already familiar with REST and need faster implementation.</p></li></ul><ul><li><p>You need flexible and efficient data fetching.</p></li><li><p>Your API serves multiple clients (mobile, web, IoT) with different data needs.</p></li><li><p>Real-time updates are required (GraphQL subscriptions). </p></li><li><p>You want to avoid API versioning issues.</p></li><li><p>Your application requires deeply nested data</p></li></ul><h4><strong>Can You Use Both REST and GraphQL?</strong></h4><p>Absolutely! REST and GraphQL are , and many organizations implement a  to get the best of both worlds:</p><ul><li><p>GraphQL for client-facing applications where flexibility, performance, and dynamic querying are essential.</p></li><li><p>REST for admin interfaces, third-party integrations, and internal microservices where statelessness, caching, and simplicity are beneficial.</p></li></ul><p>If you found it valuable, hit a like ❤️ and consider subscribing for more such content every week.</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/how-i-mastered-data-structures-and-algorithms?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&amp;token=eyJ1c2VyX2lkIjo4MzYwMjc0MywicG9zdF9pZCI6MTQ1NjU1MjUyLCJpYXQiOjE3MjE1MjE3MzEsImV4cCI6MTcyNDExMzczMSwiaXNzIjoicHViLTIyMDIyNjgiLCJzdWIiOiJwb3N0LXJlYWN0aW9uIn0.2cNY811YEugd5iH9XJQhakBzyahGqF7PcATBlFj5J2w&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>This post is public so feel free to share it.</p></div></div><p> If you’re enjoying this newsletter and want to get even more value, consider becoming a .</p><p>I hope you have a lovely day!</p>","contentLength":9590,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc4d86506-cb5f-4c9f-a56a-257439ec46eb_1666x1210.png","enclosureMime":"","commentsUrl":null},{"title":"I created a FREE Low Level Design (LLD) Interview Resource","url":"https://blog.algomaster.io/p/low-level-design-interview-resource","date":1741525361,"author":"Ashish Pratap Singh","guid":481,"unread":true,"content":"<p>I’m excited to share that you can now prepare for <strong>Low-Level Design (LLD) Interviews </strong>for FREE at .</p><p>It includes structured resources to help you study:</p><ul><li><p><strong>Object-Oriented Programming (OOP)</strong></p></li><li><p>, categorized by difficulty</p></li></ul><ul><li><p> through topics</p></li><li><p> by marking topics as complete</p></li><li><p>Experience resources based on your preferred programming language—supports Java, Python, C++, C#, and Go</p></li></ul><p>Previously, I shared LLD learning resources in a , which many found valuable. However, it had limitations—no filtering, no language-based experience, and no progress tracking.</p><p>I've added it to AlgoMaster.io to solve these issues and provide a <strong>better learning experience</strong>.</p><p>I plan to <strong>keep improving the platform</strong>—adding UML diagrams, real-world use cases, and much more to make it <strong>the best resource for mastering LLD interviews</strong>.</p>","contentLength":787,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/b2821a47-6e44-4562-affb-279801c7f276_1364x1038.png","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}