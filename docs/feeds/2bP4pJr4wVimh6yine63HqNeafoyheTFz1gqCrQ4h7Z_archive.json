{"id":"2bP4pJr4wVimh6yine63HqNeafoyheTFz1gqCrQ4h7Z","title":"AlgoMaster Newsletter","displayTitle":"Dev - Algomaster","url":"https://blog.algomaster.io/feed","feedLink":"https://blog.algomaster.io/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":9,"items":[{"title":"Coding Interviews were HARD Until I Learned These 20 Tips","url":"https://blog.algomaster.io/p/20-coding-interviews-tips","date":1739467827,"author":"Ashish Pratap Singh","guid":729,"unread":true,"content":"<p>I gave my first  in 2016—and failed. I failed the next five interviews as well before finally landing my first job at .</p><p>Since then, I’ve interviewed with many companies and faced my fair share of rejections. However, over the years, my failure rate in coding interviews dropped significantly.</p><p>By 2022, with just 1.5 months of focused preparation, I successfully cleared interviews at  and .</p><p>Surprisingly, my success wasn’t due to a dramatic improvement in problem-solving skills. The real game-changer was my approach— and  during the interview.</p><p>In this article, I’ll share  that made coding interviews significantly easier for me.</p><p>These tips cover everything you need to know, including:</p><ul><li><p>How to systematically approach coding interview problems</p></li><li><p>Key concepts and patterns you should know</p></li><li><p>The type of problems you should practice</p></li><li><p>How to choose the right algorithm for a given problem</p></li><li><p>Techniques to optimize your solution</p></li><li><p>How to communicate your thought process effectively</p></li></ul><p>By applying these strategies, you’ll be able to tackle coding interviews with confidence and massively increase your chances of success.</p><p>In a coding interview, interviewers want to see how well you , , and  under pressure.</p><p>Here's a breakdown of what they look for:</p><ol><li><p><strong>Understanding the problem</strong>: Do you ask clarifying questions instead of making assumptions to ensure you fully understand the problem?</p></li><li><p>: Can you decompose the problem into smaller, manageable parts?</p></li><li><p>: Can you design an optimal solution in terms of time and space complexity?</p></li><li><p>: Do you handle edge cases like empty inputs, duplicates, large values, or special conditions?</p></li><li><p>: Can you explain why one approach is better than another?</p></li><li><p>: Do you have a strong grasp of data structures and algorithms, and can you choose the right one for the problem?</p></li><li><p>Can you quickly compute the time and space complexity of your solution?</p></li><li><p><strong>Explaining your thought process</strong>: Can you clearly articulate your approach and why it works?</p></li><li><p>: Are you receptive to hints and able to adjust your approach accordingly?</p></li><li><p>: Do you follow good coding practices (meaningful variable names, proper indentation, modular functions etc..)?</p></li><li><p><strong>Improving the initial solution</strong>: Can you optimize and refine your first solution when prompted?</p></li><li><p>Are you able to tackle variations of the original problem?</p></li><li><p>Can you manually walk through your code with sample inputs to verify correctness?</p></li></ol><p>Most coding interviews last </p><p>Depending on the company and interviewer, you may be asked to solve 2-3easy/medium problems or 1 hard problem with follow-ups.</p><p>Lets assume you are given one problem, with a follow up in a 45-minute interview. Here’s how you can optimally allocate your time:</p><ol><li><p>The interviewer may ask you to introduce yourself. Prepare a concise 1-2 minute introduction that highlights your background, experience, and key strengths. Practice it beforehand so that you can deliver it smoothly.</p></li><li><p><strong>Understand the Problem (5-10 mins):  </strong>Carefully read the problem statement, ask clarifying questions, and walk through sample inputs and expected outputs.</p></li><li><p><strong>Plan the Approach (10-20 mins): </strong>Brainstorm possible solutions, evaluate trade-offs, and discuss time and space complexity.</p></li><li><p><strong>Implement the Code (20-30 mins): </strong>Write a clean, modular and readable code.</p></li><li><p>Dry-run your code with sample inputs, debug any issues, and ensure edge cases are handled.</p></li><li><p><strong>Follow-ups and Wrap Up (35-45 mins): </strong>Answer follow up questions, and ask thoughtful questions to the interviewer about the company, role, or team.</p></li></ol><p>One of the biggest mistakes candidates make in coding interviews is jumping into coding too soon.</p><p>If you don't fully understand the question, you might end up solving the </p><p>Here’s how to ensure you grasp the problem before coding:</p><h4><strong>Read the Problem Carefully</strong></h4><p>Take a moment to absorb the problem statement. Rephrase it in your own words to confirm your understanding. </p><p>Identify the expected input/output format and any hidden constraints.</p><p>If anything is unclear, ask questions before diving into the solution. Interviewers appreciate when you seek clarity. Never assume details that aren’t explicitly mentioned in the problem statement.</p><p>Common clarifications include:</p><ul><li><p>Are there duplicate values?</p></li><li><p>Can the input be empty? If so, what should the output be?</p></li><li><p>Should the solution handle negative numbers?</p></li><li><p>Should the output maintain the original order of elements?</p></li><li><p>Is the graph directed or undirected?</p></li><li><p>Does the input contain only lowercase English letters, or can it have uppercase, digits, or special characters?</p></li><li><p>What should happen if multiple solutions exist? Should I return any valid solution, or does the problem have specific requirements?</p></li></ul><h4><strong>Walk Through Input/Output Examples</strong></h4><p>Once you understand the problem statement and constraints, go over a few input and output examples to make sure you get it.</p><p>Draw them out if it helps, especially for visual data structures like trees or graphs.</p><p>Try to take examples that cover different scenarios of the problem. Think about any  that might come up.</p>","contentLength":4908,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/61c3f6c0-4027-4d37-b4a7-a30fc183fa12_1602x1032.png","enclosureMime":"","commentsUrl":null},{"title":"Stateful vs. Stateless Architecture","url":"https://blog.algomaster.io/p/stateful-vs-stateless-architecture","date":1739263586,"author":"Ashish Pratap Singh","guid":728,"unread":true,"content":"<p>When a client interacts with a server, there are two ways to handle it:</p><ul><li><p> The client includes all necessary data in each request, so the server doesn’t store any prior information.</p></li><li><p> The server retains some data from previous requests, making future interactions dependent on past state.</p></li></ul><blockquote><p>In software systems,  refers to any data that persists across requests, such as user sessions, shopping carts, or authentication details.</p></blockquote><p>The choice between stateless and stateful architecture can affect scalability, performance, complexity, and cost.</p><p>In this article, we’ll break down both the approaches, their advantages and trade-offs, and when to use each—with real-world examples.</p><p>In a , the system remembers client or process data () across multiple requests.</p><p>Once a client connects, the server holds on to certain details—like user preferences, shopping cart contents, or authentication sessions—so the client doesn’t need to resend everything with each request.</p><p>Stateful systems typically store the state data in a database or in-memory storage.</p><blockquote><p> During online shopping, when you add items to your cart, the website remembers your selections. If you navigate away to browse more items and then return to your cart, your items are still there, waiting for you to check out.</p></blockquote><h2>Common Patterns in Stateful Architecture</h2><p>If you use  session storage (i.e., each app server keeps its own sessions locally), you can configure your load balancer for “sticky sessions.” </p><p>This means: Once a client is assigned to , all subsequent requests from that client are routed to .</p><blockquote><p>: If Server A fails, the user’s session data is lost or the user is forced to re-log in. Sticky sessions are also less flexible when scaling because you can’t seamlessly redistribute user traffic to other servers.</p></blockquote><h3>2. Centralized Session Store</h3><p>A more robust approach is to store session data in a  or  store (e.g., Redis). </p><ul><li><p>: All servers can access and update session data for any user. Any server can handle any request, because the session data is not tied to a specific server’s memory.</p></li></ul><blockquote><p>: You introduce network overhead and rely on an external storage. If the centralized storage fails, you lose session data unless you have a fallback strategy.</p></blockquote><ul><li><p><strong>Personalized Experiences:</strong> Stateful systems can deliver highly tailored interactions, as they remember user preferences and past actions.</p></li><li><p> Users can seamlessly resume activities where they left off, even if they disconnect and reconnect.</p></li><li><p> Certain operations can be faster because the server already possesses necessary data.</p></li></ul><ul><li><p> Maintaining state for a large number of users can become resource-intensive and complex, as each server needs to keep track of specific sessions.</p></li><li><p> Managing and synchronizing state across multiple servers (if needed) introduces additional challenges.</p></li><li><p> If a server holding a user's state fails, their session data might be lost.</p></li></ul><ul><li><p><strong>E-commerce Shopping Carts</strong> – Stores cart contents and user preferences across multiple interactions, even if the user navigates away and returns.</p></li><li><p><strong>Video Streaming Services (Netflix, YouTube)</strong> – Remembers user watch progress, recommendations, and session data for a seamless experience.</p></li><li><p><strong>Messaging Apps (WhatsApp, Slack)</strong> – Maintains active user sessions and message history for real-time communication.</p></li></ul><p>In a  architecture, the server does  preserve client-specific data between individual requests.</p><ul><li><p>Each request is treated as , with no memory of previous interactions.</p></li><li><p>Every request must include <strong>all necessary information</strong> for processing.</p></li><li><p>Once the server responds, it <strong>discards any temporary data</strong> used for that request.</p></li></ul><blockquote><p>: Most  follow a stateless design. For instance, when you request weather data from a public API, you must provide all required details (e.g., location) in each request. The server processes it, sends a response, and forgets the interaction.</p></blockquote><h2>Common Patterns in Stateless Architecture</h2><h3>1. Token-Based Authentication (JWT)</h3><p>A very popular way to implement statelessness is through tokens, particularly  (JSON Web Tokens):</p><ol><li><p><strong>Client Authenticates Once</strong>: The user logs in using credentials (username/password) for the first time, and the server issues a signed .</p></li><li><p>: The client includes JWT token in each request (e.g., <code>Authorization: Bearer &lt;token&gt;</code> header).</p></li><li><p>: The server validates the token’s signature and any embedded claims (e.g., user ID, expiry time).</p></li><li><p>: The server does  need to store session data; it just verifies the token on each request.</p></li></ol><blockquote><p>Many APIs, including OAuth-based authentication systems, use JWTs to enable stateless, scalable authentication.</p></blockquote><p>Stateless architectures benefit from , ensuring that repeated requests produce the same result. This prevents inconsistencies due to network retries or client errors.</p><p> A  request with the same payload  updates the user’s data but doesn’t create duplicates.</p><blockquote><p>Idempotent APIsensures consistency and reliability, especially in distributed systems where requests might be retried automatically.</p></blockquote><ul><li><p> Stateless systems are inherently easier to scale horizontally. New servers can be added effortlessly, as they don't need to maintain any specific user sessions.</p></li><li><p> Since servers don't track state, the architecture is generally simpler and easier to manage.</p></li><li><p> The failure of a single server won't disrupt user sessions, as data isn't tied to specific servers.</p></li><li><p>With no session data stored on the server, you free up memory that would otherwise be reserved for session management.</p></li><li><p><strong>Easier to Cache Responses: </strong>Since requests are self-contained, caching layers (like CDNs) can more easily store and serve responses.</p></li></ul><ul><li><p> Stateless systems can't provide the same level of personalization or context awareness as stateful systems without additional effort (like using cookies or tokens).</p></li><li><p>The client must keep track of the authentication token or relevant data. If it loses the token, it must re-authenticate.</p></li><li><p> Every request needs to carry all the required information, potentially leading to larger payloads.</p></li></ul><ol><li><p><strong>Microservices Architecture: </strong>Each service handles requests independently, relying on external databases or caches instead of maintaining session data.</p></li><li><p><strong>Public APIs (REST, GraphQL): </strong>Clients send tokens with each request, eliminating the need for server-side sessions.</p></li><li><p>Tokens are securely stored on the device and sent with every request to authenticate users.</p></li><li><p>Stateless endpoints make caching easier since responses depend only on request parameters, not stored session data. A CDNcan cache and serve repeated requests, improving performance and reducing backend load.</p></li></ol><p>There's no one-size-fits-all answer when choosing between stateful and stateless architectures.</p><p>The best choice depends on your application’s needs, scalability goals, and user experience expectations.</p><h3><strong>When to Choose Stateful Architecture</strong></h3><p>Stateful systems are ideal when <strong>user context and continuity</strong> are critical. </p><p>Consider a stateful approach if your application:</p><ul><li><p>Requires personalization (e.g., user preferences, session history)</p></li><li><p>Needs real-time interactions (e.g., chat applications, multiplayer gaming)</p></li><li><p>Manages multi-step workflows (e.g., online banking transactions, checkout processes)</p></li><li><p>Must retain authentication sessions for security and convenience</p></li></ul><blockquote><p> A shopping cart in an e-commerce app should persist, so users don’t have to re-add items after refreshing the page.</p></blockquote><h3><strong>When to Choose Stateless Architecture</strong></h3><p>Stateless systems work best when <strong>scalability, simplicity, and resilience</strong> are top priorities. </p><p>Use a stateless approach if your application:</p><ul><li><p>Handles a high volume of requests and needs to scale efficiently</p></li><li><p>Doesn’t require storing client-specific data between requests</p></li><li><p>Needs fast, distributed processing without server dependencies</p></li><li><p>Must ensure reliability and failover readiness</p></li></ul><blockquote><p> A weather API doesn’t need to remember previous requests. Each query includes the location, and the response is processed independently.</p></blockquote><h3><strong>Hybrid Approaches: The Best of Both Worlds</strong></h3><p>Many modern applications  stateful and stateless components for flexibility.</p><p>This hybrid approach allows:</p><ul><li><p>Stateless APIs for core functionality, ensuring high scalability</p></li><li><p>Stateful sessions for personalization, improving user experience</p></li><li><p>External session stores (e.g., Redis) to manage state while keeping app servers stateless</p></li></ul><blockquote><p> A video streaming platform (e.g., Netflix) uses a stateless backend for streaming but retains stateful user sessions to track watch history and recommendations.</p></blockquote><p>If you found it valuable, hit a like ❤️ and consider subscribing for more such content every week.</p><p>If you have any questions or suggestions, leave a comment.</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/how-i-mastered-data-structures-and-algorithms?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&amp;token=eyJ1c2VyX2lkIjo4MzYwMjc0MywicG9zdF9pZCI6MTQ1NjU1MjUyLCJpYXQiOjE3MjE1MjE3MzEsImV4cCI6MTcyNDExMzczMSwiaXNzIjoicHViLTIyMDIyNjgiLCJzdWIiOiJwb3N0LXJlYWN0aW9uIn0.2cNY811YEugd5iH9XJQhakBzyahGqF7PcATBlFj5J2w&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>This post is public so feel free to share it.</p></div></div><p> If you’re enjoying this newsletter and want to get even more value, consider becoming a .</p><p>I hope you have a lovely day!</p>","contentLength":8612,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/7e4801c3-e3aa-4ab6-8fe6-759af4a1f91a_1684x1196.png","enclosureMime":"","commentsUrl":null},{"title":"Design a Real-Time Gaming Leaderboard - System Design Interview","url":"https://blog.algomaster.io/p/design-real-time-gaming-leaderboard","date":1738852955,"author":"Ashish Pratap Singh","guid":727,"unread":true,"content":"<p>A  is a ranked list of players, typically sorted by a specific metric such as score, points or level.</p><p> In a  leaderboard, updates happen almost instantly:</p><ol><li><p>A player’s score changes (e.g., after scoring a point or defeating an opponent).</p></li><li><p>The system updates that player’s rank immediately.</p></li><li><p>Other players can see the updated position without waiting or refreshing.</p></li></ol><p>This real-time aspect makes the user experience more dynamic and engaging. </p><p>However, it also introduces significant , such as:</p><ul><li><p>Efficiently retrieving Top-N players (e.g., Top 10 or Top 100).</p></li><li><p>Allowing players to quickly find their own rank without scanning the entire leaderboard.</p></li></ul><p>In this article, we will explore how to design a , , and  that can support above queries and enhance the user experience.</p><p>Before diving into the design, lets clearly define the functional and non-functional requirements of our real-time gaming leaderboard..</p><ul><li><p>: Display top N players (e.g., top 10, top 100) on the leaderboard and update it in real-time.</p></li><li><p>: Allow a player to query their current rank without scanning the entire leaderboard.</p></li><li><p> Provide the ability to retrieve a “slice” of the leaderboard around a specific player (e.g., ranks 45 to 55 if the player is rank 50).</p></li><li><p> Players can view past game scores and historical leaderboards for previous matches.</p></li></ul><h3>Non-Functional Requirements</h3><ul><li><p> Score changes should reflect immediately in the leaderboard.</p></li><li><p>: Leaderboard queries should return the results in milliseconds.</p></li><li><p>: System should support thousands of concurrent players submitting scores and fetching rankings.</p></li></ul><h3>Approach to Designing the System</h3><p>The most challenging aspects of building a real-time leaderboard is . Choosing the right storage system is critical to ensuring that queries can be executed efficiently without performance bottlenecks.</p><p>To simplify the design process, we will follow below approach:</p><ol><li><p>Clearly define the input/output structure of leaderboard queries and updates.</p></li><li><p><strong>Define the High-Level Architecture: </strong>Identify core system components and their interactions.</p></li><li><p>Choose the appropriate storage model optimized for fast leaderboard lookups and real-time updates.</p></li></ol><p>To support real-time leaderboard operations, we define a set of  that allow players to update scores, retrieve rankings, and query nearby ranks efficiently.</p><p>Updates a player's score incrementally</p><p>: <code>POST /leaderboard/score/update</code></p><pre><code><code>{\n  \"playerId\": \"player123\",\n  \"scoreDelta\": 50\n}</code></code></pre><blockquote><p>We will use relative score updates () rather than absolute updates.</p></blockquote><pre><code><code>{\n  \"playerId\": \"player123\",\n  \"updatedScore\": 1000,\n  \"currentRank\": 10\n}</code></code></pre><p>Retrieves the top-N players from the leaderboard, ranked by their scores.</p><p>: <code>GET /leaderboard/top?n=10</code></p><p>:  = number of top players to fetch (default 10, max 100, etc.)</p><pre><code><code>{\n  \"leaderboardId\": \"global\",\n  \"topPlayers\": [\n    { \"playerId\": \"playerA\", \"score\": 1500, \"rank\": 1 },\n    { \"playerId\": \"playerB\", \"score\": 1490, \"rank\": 2 },\n    // ...\n  ]\n}</code></code></pre><p>Allows a player to retrieve their current rank without scanning the entire leaderboard.</p><p>: <code>GET /leaderboard/rank/{playerId}</code></p><pre><code><code>{\n  \"playerId\": \"player123\",\n  \"score\": 1000,\n  \"rank\": 10\n}</code></code></pre><p>Retrieves players ranked around a given player, allowing for comparison with competitors of similar skill levels.</p><p>: <code>GET /leaderboard/nearby/{playerId}?range=5</code></p><p>:  indicates how many ranks above and below to fetch (e.g., 5 above, 5 below).</p><pre><code><code>{\n  \"playerId\": \"player123\",\n  \"startRank\": 45,\n  \"endRank\": 55,\n  \"players\": [\n    { \"playerId\": \"playerX\", \"score\": 1020, \"rank\": 44 },\n    { \"playerId\": \"player123\", \"score\": 1000, \"rank\": 45 },\n    { \"playerId\": \"playerZ\", \"score\": 995,  \"rank\": 46 },\n    // ...\n  ]\n}</code></code></pre><p> If a player is ranked 50th, this API allows them to see players ranked 45-55 for a competitive comparison.</p><h3>2.5 WebSockets for Real-Time Updates</h3><p>While REST APIs are good for on-demand queries, WebSockets or Server-Sent Events (SSEs) can push real-time leaderboard updates to subscribed users.</p><p>Players would subscribe to leaderboard updates, and receive updates instantly without polling.</p>","contentLength":3933,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fdbc07561-4165-42b9-a375-caaa33a2b6e3_2208x1668.png","enclosureMime":"","commentsUrl":null},{"title":"What are ACID Transactions in Databases?","url":"https://blog.algomaster.io/p/what-are-acid-transactions-in-databases","date":1738647067,"author":"Ashish Pratap Singh","guid":726,"unread":true,"content":"<p>Imagine you’re running an e-commerce application. </p><p>A customer places an order, and your system needs to deduct the item from inventory, charge the customer’s credit card, and record the sale in your accounting system—all at once. </p><p>What happens if the payment fails but your inventory count has already been reduced? Or if your application crashes halfway through the process?</p><p>This is where  come into play. They ensure that all the steps in such critical operations happen reliably and consistently.</p><p>ACID is an acronym that refers to the set of 4 key properties that define a transaction: <strong>Atomicity, Consistency, Isolation,</strong> and </p><p>In this article, we’ll dive into what each of the ACID properties mean, why they are important, and how they are implemented in databases.</p><p>A  in the context of databases is a sequence of one or more operations (such as inserting, updating, or deleting records) that the database treats as . It either fully succeeds or fully fails, with no in-between states.</p><p>When you send money to a friend, two things happen:</p><ol><li><p>Money is deducted from your account.</p></li><li><p>Money is added to their account.</p></li></ol><p>These two steps form . If either step fails, both are canceled.</p><p>Without transactions, databases could end up in inconsistent states. </p><ul><li><p>: Your money is deducted, but your friend never receives it.</p></li><li><p>: Two people booking the last movie ticket at the same time.</p></li></ul><p>Transactions solve these problems by enforcing rules like  (Atomicity, Consistency, Isolation, Durability).</p><p>Now, lets looks at each of the ACID properties.</p><p>Atomicity ensures that a transaction—comprising multiple operations—executes as a unit of work: it either  succeeds (commits) or  fails (rolls back). </p><p>If any part of the transaction fails, the entire transaction is rolled back, and the database is restored to a state exactly as it was before the transaction began.</p><blockquote><p>In a money transfer transaction, if the credit step fails, the debit step cannot be allowed to stand on its own. This prevents inconsistent states like “money disappearing” from one account without showing up in another.</p></blockquote><p>Atomicity abstracts away the complexity of manually undoing changes if something goes wrong.</p><h2>How Databases Implement Atomicity</h2><p>Databases use two key mechanisms to guarantee atomicity.</p><h4><strong>1. Transaction Logs (Write-Ahead Logs)</strong></h4><ul><li><p>Every operation is recorded in a  before it’s applied to the actual database table.</p></li><li><p>If a failure occurs, the database uses this log to  incomplete changes.</p></li></ul><p>Once the WAL entry is safely on disk, the database proceeds with modifying the in-memory pages that contain rows for  and .</p><p>When the operations succeed:</p><ol><li><p>The database marks  as  in the transaction log.</p></li><li><p>The newly updated balances for A and B will eventually get flushed from memory to their respective data files on disk.</p></li></ol><p>If the database crashes  the log entry is written but  the data files are fully updated, the WAL provides a way to recover:</p><ul><li><p>On restart, the database checks the WAL.</p></li><li><p>It sees  was committed.</p></li><li><p>It reapplies the  operations to ensure the final balances are correct in the data files.</p></li></ul><p>If the transaction had not committed (or was marked as “in progress”) at the time of the crash, the database would  those changes using information in the log, leaving the table as if the transaction never happened.</p><h4><strong>2. Commit/Rollback Protocols</strong></h4><ul><li><p>Databases provide commands like , , and </p></li><li><p>Any changes made between  and  are considered “in-progress” and won’t be permanently applied unless the transaction commits successfully.</p></li><li><p>If any step fails, or if you explicitly issue a , all changes since the start of the transaction are undone.</p></li></ul><p> in the context of ACID transactions ensures that any transaction will bring the database from one valid state to another valid state—never leaving it in a broken or “invalid” state.</p><p>It means that all the data integrity constraints, such as  (no duplicate IDs),  (related records must exist in parent tables), and (age can’t be negative), are satisfied before and after the transaction.</p><p>If a transaction tries to violate these rules, it will not be committed, and the database will revert to its previous state.</p><p>You have two tables in an e-commerce database:</p><ol><li><p> (with columns: , , etc.)</p></li><li><p> (with columns: , , , etc.)</p></li></ol><ul><li><p>: You can’t place an order for a product if  is greater than the  in the  table.</p></li></ul><ul><li><p>If the product’s  was 8 (less than what we’re trying to order), the database sees that the new value would be  which breaks the consistency rule (it should not go negative).</p></li><li><p>The transaction fails or triggers a rollback, preventing the database from ending in an invalid state.</p></li></ul><h2>How to Implement Consistency</h2><ol><li><p><strong>Database Schema Constraints</strong></p><ul><li><p>, , , ,  constraints, and other schema definitions ensure no invalid entries are allowed.</p></li></ul></li><li><p><strong>Triggers and Stored Procedures</strong></p><ul><li><p>Triggers can automatically check additional rules whenever rows are inserted, updated, or deleted.</p></li><li><p>Stored procedures can contain logic to validate data before committing.</p></li></ul></li><li><p><strong>Application-Level Safeguards</strong></p><ul><li><p>While the database enforces constraints at a lower level, applications often add extra checks—like ensuring business rules are followed or data is validated before it even reaches the database layer.</p></li></ul></li></ol><p> ensures that concurrently running transactions do not interfere with each other’s intermediate states.</p><p>Essentially, while a transaction is in progress, its updates (or intermediate data) remain invisible to other ongoing transactions—giving the illusion that each transaction is running sequentially, one at a time.</p><p>Without isolation, two or more transactions could read and write partial or uncommitted data from each other, causing incorrect or inconsistent results.</p><p>With isolation, developers can reason more reliably about how data changes will appear to other transactions.</p><p>To understand how isolation works, it helps to see what can go wrong without proper isolation.  Common concurrency anomalies include:</p><ol><li><ul><li><p>Transaction A reads data that Transaction B has modified but not yet committed.</p></li><li><p>If Transaction B then rolls back, Transaction A ends up holding an invalid or “dirty” value that never truly existed in the committed state.</p></li></ul></li><li><ul><li><p>Transaction A reads the same row(s) multiple times during its execution but sees different data because another transaction updated or deleted those rows in between A’s reads.</p></li></ul></li><li><ul><li><p>Transaction A performs a query that returns a set of rows. Another transaction inserts, updates, or deletes rows that match A’s query conditions.</p></li><li><p>If A re-runs the same query, it sees a different set of rows (“phantoms”).</p></li></ul></li></ol><p>Databases typically allow you to choose an , which balances data correctness with performance.</p><p>Higher isolation levels provide stronger data consistency but can reduce system performance by increasing the wait times for transactions. </p><p>Let's explore the four common isolation levels:</p><ol><li><ul><li><p>Allows dirty reads; transactions can see uncommitted changes.</p></li><li><p>Rarely used, as it can lead to severe anomalies.</p></li></ul></li><li><ul><li><p>A transaction sees only data that has been committed at the moment of reading.</p></li><li><p>Prevents dirty reads, but non-repeatable reads and phantom reads can still occur.</p></li></ul></li><li><ul><li><p>Ensures if you read the same rows multiple times within a transaction, you’ll get the same values (unless you explicitly modify them).</p></li><li><p>Prevents dirty reads and non-repeatable reads, but phantom reads may still happen (depending on the database engine).</p></li></ul></li><li><ul><li><p>The highest level of isolation, acting as if all transactions happen sequentially one at a time.</p></li><li><p>Prevents dirty reads, non-repeatable reads, and phantom reads.</p></li><li><p>Most expensive in terms of performance and concurrency because it can require more locking or more conflict checks.</p></li></ul></li></ol><h2>How Databases Enforce Isolation</h2><ul><li><p><strong>Pessimistic Concurrency Control</strong></p><ul><li><p>Rows or tables are locked so that no other transaction can read or write them until the lock is released.</p></li><li><p>Can lead to blocking or deadlocks if multiple transactions compete for the same locks.</p></li></ul></li></ul><h4>2. MVCC (Multi-Version Concurrency Control)</h4><ul><li><p><strong>Optimistic Concurrency Control</strong></p><ul><li><p>Instead of blocking reads, the database keeps multiple versions of a row.</p></li><li><p>Readers see a consistent snapshot of data (like a point-in-time view), while writers create a new version of the row when updating.</p></li><li><p>This approach reduces lock contention but requires carefully managing row versions and cleanup (vacuuming in PostgreSQL, for example).</p></li></ul></li></ul><ul><li><p>A form of MVCC where each transaction sees data as it was at the start (or a consistent point) of the transaction.</p></li><li><p>Prevents non-repeatable reads and dirty reads. Phantom reads may still occur unless the isolation level is fully serializable.</p></li></ul><p> ensures that once a transaction has been committed, the changes it made will survive, even in the face of power failures, crashes, or other catastrophic events. </p><p>In other words, once a transaction says “done,” the data is permanently recorded and cannot simply disappear.</p><h2>How Databases Ensure Durability</h2><h4>1. Transaction Logs (Write-Ahead Logging)</h4><p>Most relational databases rely on a  to preserve changes before they’re written to the main data files:</p><ol><li><p>: The intended operations (updates, inserts, deletes) are recorded in the WAL on durable storage (disk).</p></li><li><p>: Once the WAL entry is safely persisted, the database can mark the transaction as committed.</p></li><li><p><strong>Apply Changes to Main Data Files</strong>: The updated data eventually gets written to the main files—possibly first in memory, then flushed to disk.</p></li></ol><p>If the database crashes, it uses the WAL during :</p><ul><li><p>: Any committed transactions not yet reflected in the main files are reapplied.</p></li><li><p>: Any incomplete (uncommitted) transactions are rolled back to keep the database consistent.</p></li></ul><h4>2. Replication / Redundancy</h4><p>In addition to WAL, many systems use replication to ensure data remains durable even if hardware or an entire data center fails.</p><ul><li><p>: Writes are immediately copied to multiple nodes or data centers. A transaction is marked committed only if the primary and at least one replica confirm it’s safely stored.</p></li><li><p>: Changes eventually sync to other nodes, but there is a (small) window where data loss can occur if the primary fails before the replica is updated.</p></li></ul><p>Regular  provide a safety net beyond logs and replication. In case of severe corruption, human error, or catastrophic failure:</p><ul><li><p>: Capture the entire database at a point in time.</p></li><li><p><strong>Incremental/Differential Backups</strong>: Store changes since the last backup for faster, more frequent backups.</p></li><li><p>: Ensures backups remain safe from localized disasters, allowing you to restore data even if hardware is damaged.</p></li></ul><p>If you found it valuable, hit a like ❤️ and consider subscribing for more such content every week.</p><p>If you have any questions or suggestions, leave a comment.</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/scalability?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&amp;token=eyJ1c2VyX2lkIjo4MzYwMjc0MywicG9zdF9pZCI6MTQwMDc4MDk0LCJpYXQiOjE3Mzc1MzgxODMsImV4cCI6MTc0MDEzMDE4MywiaXNzIjoicHViLTIyMDIyNjgiLCJzdWIiOiJwb3N0LXJlYWN0aW9uIn0.xroFXQDDEPvo2FWnnt-G2Ji9MzYIDtJ68NRQX6sT8x8&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>This post is public so feel free to share it.</p></div></div><p> If you’re finding this newsletter helpful and want to get even more value, consider becoming a .</p><p>I hope you have a lovely day!</p>","contentLength":10638,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa9ceb65c-70e6-4f3e-9511-f6bc5da93d13_1308x1086.png","enclosureMime":"","commentsUrl":null},{"title":"Design YouTube - System Design Interview","url":"https://blog.algomaster.io/p/design-youtube-system-design-interview","date":1738215950,"author":"Ashish Pratap Singh","guid":725,"unread":true,"content":"<p>With over  monthly active users,  is the second most visited website in the world—trailing only Google.</p><p>As a , it enables users to upload, watch, and interact with video content, while handling hundreds of millions of daily visitors, managing petabytes of data, and ensuring real-time video delivery across the globe.</p><p>In this article, we’ll explore the <strong>system design of a large-scale video streaming service like YouTube</strong> that can accommodate hundreds of millions of daily users and billions of views, all while maintaining low latency and high availability.</p><p>We’ll walk through every step of the design—from requirements and high-level architecture to database and API design—before diving deep into core use cases. </p><p>The concepts covered here are equally applicable to other large-scale video platforms such as  and .</p><p>Before diving into the design, lets outline the functional and non-functional requirements.</p><ul><li><p>Users should be able to  video files.</p></li><li><p>Uploaded videos must be  into multiple resolutions (e.g., 240p, 360p, 720p, 1080p) to support different network conditions and devices.</p></li></ul><ul><li><p>Users should be able to  videos in real-time with <strong>adaptive bitrate streaming</strong> to adjust quality based on network conditions.</p></li></ul><ul><li><p>Users can  for videos by title, tags, or description.</p></li><li><p>Users can  and  on videos.</p></li><li><p>Users should be able to create and subscribe to .</p></li></ul><h3><strong>Non-Functional Requirements:</strong></h3><ol><li><p> The system should support millions of concurrent users and thousands of video uploads per minute.</p></li><li><p> Core features like video upload, playback, and search should have minimal downtime.</p></li><li><p> Fast video streaming with minimal buffering and near-instantaneous search results.</p></li><li><p> Video files must be stored reliably, with redundancy mechanisms to prevent data loss due to hardware failures.</p></li><li><p> Optimize storage and bandwidth costs.</p></li></ol><ul><li><p><strong>Daily Active Users (DAU):</strong> 10 million</p></li><li><p> ~100,000 videos/day</p></li><li><p><strong>Average Videos Watched per User per Day:</strong> 5 videos</p></li><li><p> 500 MB.</p></li><li><p> 1 KB.</p></li></ul><ul><li><p>: 100,000 videos / day * 500 MB / video = 50 TB / day</p></li><li><p><strong>Daily Video Metadata Storage</strong>: 100,000 * 1KB = 100MB / day</p></li></ul><h4><strong>Network Bandwidth Estimation:</strong></h4><ul><li><p>10 million users × 5 videos/user = 50 million views/day </p></li><li><p><strong>Daily Bandwidth Requirements (without compression &amp; caching) </strong>: 50 million views * 500 MB / day = 25 PB / day</p></li></ul><p>Given the high storage and bandwidth requirements, leveraging  is the most practical approach:</p><ol><li><p><strong>Content Delivery Network (CDN):</strong> To cache frequently accessed videos closer to users and reduce latency.</p></li><li><p><strong>Blob Storage (e.g., AWS S3):</strong> To store video files reliably with redundancy.</p></li></ol><p>We can break the architecture of YouTube into two primary components: </p><ul><li><p> – Handles video playback, and delivery.</p></li><li><p><strong>Video Upload &amp; Processing</strong> – Manages user uploads, transcoding, and metadata storage.</p></li></ul><h2>3.1 Video Streaming Architecture</h2>","contentLength":2703,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F23342c70-b11d-48c3-b30b-63ea245e5d2a_2026x1322.png","enclosureMime":"","commentsUrl":null},{"title":"Long Polling vs WebSockets","url":"https://blog.algomaster.io/p/long-polling-vs-websockets","date":1738038640,"author":"Ashish Pratap Singh","guid":724,"unread":true,"content":"<p>Whether you are playing an online game or chatting with a friend—updates appear in real-time without hitting .</p><p>Behind these seamless experiences lies a critical engineering decision: <strong>how to push real-time updates from servers to clients</strong>.</p><p>The traditional HTTP model was designed for request-response: <em>\"Client asks, server answers.\". </em>But in many real-time systems, the server needs to talk first and more often.</p><p>This is where  and  come into play—two popular methods for achieving real-time updates.</p><p>In this article, we’ll explore these two techniques, how they work, their pros and cons, and use cases.</p><p>HTTP, the backbone of the web, follows a :</p><ol><li><p>The client (e.g., a browser or mobile app) sends a request to the server.</p></li><li><p>The server processes the request and sends back a response.</p></li></ol><p>This model is simple and works for many use-cases, but it has limitations:</p><ul><li><p> With plain HTTP, the server cannot proactively push data to the client. The client has to request the data periodically.</p></li><li><p> HTTP is stateless, meaning each request stands alone with no persistent connection to the server. This can be problematic if you need continuous exchange of data.</p></li></ul><p>To build truly real-time features—live chat, financial tickers, or gaming updates—you need a mechanism where the server can instantly notify the client when something changes.</p><p> is a technique that mimics real-time behavior by keeping HTTP requests open until the server has data.</p><p>Long Polling is an enhancement over traditional polling. In regular polling, the client repeatedly sends requests at fixed intervals (e.g., every second) to check for updates. This can be wasteful if no new data exists. </p><p>Long Polling tweaks this approach: the client asks the server for data and then “waits” until the server has something new to return or until a timeout occurs.</p><h3>How Does Long Polling Work?</h3><ol><li><p> to the server, expecting new data.</p></li><li><p><strong>Server holds the request open</strong> until it has an update or a timeout is reached.</p><ul><li><p>If there's new data, the server immediately responds.</p></li><li><p>If there’s no new data and the timeout is reached, the server responds with an empty or minimal message.</p></li></ul></li><li><p>Once the client receives a response—new data or a timeout—it <strong>immediately sends a new request</strong> to the server to keep the connection loop going.</p></li></ol><ul><li><p>Simple to implement (uses standard HTTP).</p></li><li><p>Supported universally since it uses standard HTTP, and it works reliably through firewalls and proxies.</p></li></ul><ul><li><p>Higher latency after each update (client must re-establish connection).</p></li><li><p>Resource-heavy on servers (many open hanging requests).</p></li></ul><ul><li><p>Simple chat or comment systems where real-time but slightly delayed updates (near real-time) are acceptable.</p></li><li><p>Notification systems for less frequent updates (e.g., Gmail’s \"new email\" alert).</p></li><li><p>Legacy systems where WebSockets aren’t feasible.</p></li></ul><h3>Code Example (JavaScript)</h3><p> provide a <strong>full-duplex, persistent connection</strong> between the client and the server.</p><p>Once established, both parties can send data to each other at any time, without the overhead of repeated HTTP requests.</p><ol><li><p> Client sends an HTTP request with .</p></li><li><p>: If supported, the server upgrades the connection to WebSocket (switching from  to ). After the handshake, client and server keep a TCP socket open for communication.</p></li><li><p><strong>Full-Duplex Communication:</strong> Once upgraded, data can be exchanged bidirectionally in real time until either side closes the connection.</p></li></ol><ol><li><p>Ultra-low latency (no repeated handshakes).</p></li><li><p>Lower overhead since there’s only one persistent connection rather than repeated HTTP requests.</p></li><li><p>Scalable for real-time applications that need to support large number of concurrent users.</p></li></ol><ol><li><p>More complex setup (requires the client and server to support WebSocket).</p></li><li><p>Some proxies and firewalls may not allow WebSocket traffic.</p></li><li><p>Complexity in implementation and handling reconnections/errors.</p></li><li><p>Server resource usage might grow if you have a large number of concurrent connections.</p></li></ol><ol><li><p>Live chat and collaboration tools (Slack, Google Docs, etc.).</p></li><li><p>Multiplayer online games with real-time state synchronization.</p></li><li><p>Live sports/financial dashboards that need to push frequent updates.</p></li></ol><h3>Code Example (JavaScript)</h3><p>Both methods achieve real-time updates, but your choice depends on your project’s requirements:</p><ol><li><ul><li><p> is easier to implement using standard libraries. Any environment that supports HTTP can handle it, often without extra packages.</p></li><li><p> require a bit more setup and a capable proxy environment (e.g., support in Nginx or HAProxy). However, many frameworks (e.g., Socket.io) simplify the process significantly.</p></li></ul></li><li><p><strong>Scalability and Performance</strong></p><ul><li><p> can become resource-intensive with a large number of simultaneous clients, due to multiple open connections waiting on the server side.</p></li><li><p> offer a more efficient, persistent connection and scale better for heavy, frequent data streams.</p></li></ul></li><li><ul><li><p> fits scenarios where data updates aren’t super frequent. If new data arrives every few seconds or minutes, long polling might be enough.</p></li><li><p> are better for high-frequency updates or two-way communication (e.g., multiple participants editing a document or interacting in a game).</p></li></ul></li><li><ul><li><p> typically works even in older networks or those with strict firewalls.</p></li><li><p> might face issues in certain corporate or older mobile environments, though this is less of a problem as the standard becomes more widespread.</p></li></ul></li></ol><blockquote><p>While both achieve real-time communication, WebSockets are generally more efficient for truly real-time applications, while Long Polling can be simpler to implement for less demanding scenarios.</p></blockquote><h4><strong>1. Server-Sent Events (SSE)</strong></h4><ul><li><p>Allows the server to push messages to the client over HTTP.</p></li><li><p>It's simpler than WebSockets for one-way communication, but not full-duplex.</p></li><li><p>Best suited for use cases like news feeds, real-time notifications, and status updates.</p></li></ul><ul><li><p>Commonly used in IoT for lightweight publish-subscribe messaging.</p></li><li><p>Specialized for device-to-device or device-to-server communication with minimal overhead.</p></li></ul><h4><strong>3. Libraries like Socket.io</strong></h4><ul><li><p>Provides an abstraction over WebSockets for easier real-time communication.</p></li><li><p>Automatically falls back to long polling if WebSockets are unsupported.</p></li><li><p>Ensures cross-browser compatibility with robust and reliable performance.</p></li></ul><p>If you found it valuable, hit a like ❤️ and consider subscribing for more such content every week.</p><p>If you have any questions or suggestions, leave a comment.</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/scalability?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&amp;token=eyJ1c2VyX2lkIjo4MzYwMjc0MywicG9zdF9pZCI6MTQwMDc4MDk0LCJpYXQiOjE3Mzc1MzgxODMsImV4cCI6MTc0MDEzMDE4MywiaXNzIjoicHViLTIyMDIyNjgiLCJzdWIiOiJwb3N0LXJlYWN0aW9uIn0.xroFXQDDEPvo2FWnnt-G2Ji9MzYIDtJ68NRQX6sT8x8&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>This post is public so feel free to share it.</p></div></div><p> If you’re enjoying this newsletter and want to get even more value, consider becoming a .</p><p>I hope you have a lovely day!</p>","contentLength":6360,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/90181ae6-4dcb-456f-a43a-7824d97c740b_2002x1472.png","enclosureMime":"","commentsUrl":null},{"title":"Master the Art of REST API Design","url":"https://blog.algomaster.io/p/master-the-art-of-rest-api-design","date":1737610478,"author":"Ashish Pratap Singh","guid":723,"unread":true,"content":"<p> is one of the most crucial steps in  and a key topic of discussion in .</p><p>A well-designed <a href=\"https://blog.algomaster.io/p/whats-an-api\">API</a> allows developers to easily integrate with a system while ensuring scalability and security.</p><p>Over the years, various  have emerged, including <strong>REST, GraphQL, gRPC, Webhooks and SOAP,</strong> each designed to address different needs.</p><p>However,  continue to dominate web development due to their simplicity, scalability, flexibility, widespread adoption and alignment with HTTP standards.</p><p>In this article, we will dive into covering:</p><ul><li><p> for building a well-structured, scalable, and secure RESTful API.</p></li><li><p><strong>Performance optimization techniques</strong> to enhance API efficiency and response times.</p></li></ul><p>REST (<strong>Representational State Transfer</strong>) is an architectural style for designing web services that enable communication between clients (e.g., web browsers, mobile apps) and servers over the .</p><p>REST uses HTTP methods (GET, POST, PUT, DELETE, etc.) to <strong>retrieve, create, update, and delete</strong> resources.</p><p>To build a well-designed REST APIyou must first understand the fundamentals of theHTTP protocol.</p><h3>1. HTTP Methods (Verbs) in REST APIs</h3><p>HTTP provides a set of  that define the type of operation to be performed on a resource.</p><p>In RESTful architectures, these methods typically map to CRUD operations:</p><p>It’s essential to use the correct HTTP method to make your API clear and intuitive. For example,  signals a read-only request to developers and should never modify server data, while  indicates data creation or an action that results in a change.</p><h3>2. REST is Resource-Oriented</h3><p>In RESTful API design, data is represented as , and each resource is identified by a <strong>Uniform Resource Identifier (URI)</strong>.</p><ul><li><p>→ A collection (or list) of books</p></li><li><p> → A specific book with ID 123</p></li></ul><p>An  is a combination of:</p><ul><li><p>An HTTP method (GET, POST, PUT etc.)</p></li><li><p>A resource URI (, )</p></li></ul><p>Each endpoint represents a specific operation on a resource.</p><ul><li><p> → Fetch all books</p></li><li><p> → Create a new book</p></li><li><p> → Delete the book with ID 123</p></li></ul><p>Using clear and consistent endpoints helps developers quickly understand how to interact with your API.</p><h3>4. HTTP Status Codes: Understanding API Responses</h3><p>Each API response includes an , which indicates the result of the request.</p><p>Using meaningful status codes is important for helping consumers of your API understand why a request might have failed and how they can fix or retry it.</p><p>Common status codes include:</p><ul><li><p>: The request was successfully received and processed.</p><ul><li><p>: The request succeeded.</p></li><li><p>: A new resource was successfully created.</p></li><li><p>: The request succeeded, but there is no content to return.</p></li></ul></li><li><p>: Further action is needed to complete the request (e.g., a different endpoint or resource location).</p></li><li><p>: There was an error in the request sent by the client.</p><ul><li><p>: The request was malformed or invalid.</p></li><li><p>: Authentication is required or has failed.</p></li><li><p>: The client does not have permission to access the resource.</p></li><li><p>: The requested resource does not exist.</p></li><li><p>: Rate limit exceeded.</p></li></ul></li><li><p>: The server encountered an error while processing the request.</p><ul><li><p><strong>500 Internal Server Error</strong>: A general error occurred on the server.</p></li><li><p>: The server is currently unable to handle the request, often due to maintenance or overload.</p></li></ul></li></ul><h2><strong>1. Define Clear Resource Naming Conventions</strong></h2><p>Using a <strong>consistent, intuitive, and hierarchical structure</strong> for API endpoints improves both readability and usability. The goal is to help developers quickly understand how to interact with your API without extensive documentation.</p><p>Since REST is resource-oriented, focus on  (nouns) rather than  (verbs) for your endpoints. The HTTP methods (, , etc.) already describe the action, so using verbs in the URL are redundant.</p><pre><code><code>GET /getAllUsers\nPOST /createNewOrder\nDELETE /removeProduct/123</code></code></pre><pre><code>GET /users\nPOST /orders\nDELETE /products/123</code></pre>","contentLength":3656,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F64780231-6a91-4d72-8ea2-159d4cd71f4e_1504x1056.png","enclosureMime":"","commentsUrl":null},{"title":"What's an API?","url":"https://blog.algomaster.io/p/whats-an-api","date":1737437464,"author":"Ashish Pratap Singh","guid":722,"unread":true,"content":"<p>API stands for <strong>Application Programming Interface</strong>.</p><p>At its core, an API is a  that takes an  and gives you predictable </p><p>Think of an API as a  that enables applications to interact <strong>without needing direct access to each other's code or database</strong>.</p><p>Almost every digital service you use today—social media, e-commerce, online banking, ride-hailing apps—all of them are a bunch of APIs working together.</p><ul><li><p> – If you provide a city name as input (), the API returns the <strong>current temperature, humidity, and weather conditions</strong>.</p></li><li><p> – If you provide a <strong>pickup and destination address</strong>, the API finds the  and calculates the estimated fare.</p></li><li><p> – If you provide a list of numbers (), the API returns the  ().</p></li></ul><p>When engineers build APIs, they clearly define <strong>what inputs the API accepts</strong> and , ensuring consistent behavior across different applications.</p><p>APIs follow a simple  model:</p><ul><li><p>A client (such as a web app or mobile app) makes a request to an API.</p></li><li><p>The API (hosted on an API server) processes the request, interacts with the necessary databases or services, and prepares a response.</p></li><li><p>The API sends the response back to the client in a structured format (usually JSON or XML).</p></li></ul><p>Every API requires , and passing incorrect data can result in errors.</p><p>For example: If you tried putting your name into the Google Maps API as an input, that wouldn’t work very well.</p><p>Some APIs also <strong>require inputs in a specific format</strong>.</p><p>Example: The  might need the input as  instead of .</p><p>APIs often  to ensure they are correct before processing them, which helps maintain .</p><p>Just as APIs require , they also return .</p><p>For example, the  always returns <strong>coordinates in the same format</strong>.</p><pre><code>{   \"latitude\": 40.6892,   \"longitude\": -74.0445 }</code></pre><p>If the API can’t find the location, it provides an error response explaining why.</p><pre><code>{   \"error\": \"Invalid address format\",   \"code\": 400 }</code></pre><p>The apps you use every day—whether it's <strong>Gmail, Instagram, Uber, or Spotify</strong>—are essentially <strong>a collection of APIs with a polished user interface (UI) on top</strong>.</p><p>Most applications follow the <strong>frontend/backend architecture</strong>, where:</p><ul><li><p>The  consists of APIs that handle <strong>data processing, business logic, and communication with databases</strong>.</p></li><li><p>The  is a <strong>graphical user interface (GUI)</strong> that interacts with these APIs, making applications user-friendly and accessible <strong>without requiring users to write code</strong>.</p></li></ul><p>Let’s break this down with a real-world example: .</p><p>Before the Uber app existed as a sleek, user-friendly experience, the company first built <strong>the core APIs that power ride-hailing services:</strong></p><ul><li><p>Calculating Fares &amp; Routes</p></li><li><p>Matching Riders &amp; Drivers</p></li></ul><p>These APIs run on Uber’s servers, forming the . Every time you request a ride, track your driver, or make a payment, these backend APIs handle the request.</p><p> are responsible for optimizing these APIs, improving ride-matching algorithms, securing transactions, and ensuring a smooth experience for millions of users.</p><p>The backend APIs handle , but they —which isn't practical for everyday users. That’s why companies build a <strong>frontend (user interface)</strong> on top of these APIs, allowing users to interact with the system .</p><p>When you enter your pickup &amp; destination address, the frontend sends an API request to  and displays available cars.</p><p>Once the trip is complete, the frontend may call the process payment API to display the receipt.</p><p>APIs come in different forms depending on , , and .</p><h3>1. Open APIs (Public APIs)</h3><p>Open APIs, also known as , are accessible to external developers with minimal restrictions.</p><p>Companies provide these APIs to encourage  to integrate their services and build new applications on top of them.</p><h4><strong>Example: YouTube Data API</strong></h4><p>Normally, when you use the , it makes  to fetch your video feed, search for content, or post comments. However, YouTube also provides a  that allows developers to access some of this functionality .</p><p>For example, the  allows developers to fetch video results based on a keyword. If you send a request to the API with <code>\"machine learning tutorial\"</code> as the search term, it will return a structured response (JSON format) containing a list of relevant videos, including <strong>titles, descriptions, thumbnails, and video links</strong>.</p><p>This is incredibly useful because it enables developers to build custom applications on top of YouTube.</p><h3>2. Internal APIs (Private APIs)</h3><p>, also known as , are designed xclusively for internal use within an organization. Unlike Open APIs, these are not accessible to external developers and are used to facilitate seamless communication between different internal systems within a company.</p><p>Let’s take  as an example. When you place an order, you might assume that a single system processes your request. In reality,  (order processing, inventory, payment, logistics etc..) work together behind the scenes to fulfill your order efficiently.</p><p>Each of these APIs , but they communicate through well-defined protocols to ensure a smooth and efficient process.</p><p>Internal APIs allow companies to break down their applications into <strong>smaller, manageable services</strong>, making it easier to scale. Developers can  across different projects, reducing  and speeding up development.</p><p>The first two types of APIs we discussed—<strong>Open APIs and Internal APIs</strong>—are functional and serve  like fetching weather data or booking a ride.</p><p>But there’s another category of APIs that developers use daily:  (also called  or ).</p><p>These APIs don’t connect different applications; instead, they provide predefined functions within a programming language or framework to make development easier.</p><p>Python’s built-in list API</p><p>When working with lists, Python provides a set of <strong>built-in functions (methods) to manipulate data</strong>.</p><pre><code>numbers = [5, 3, 8, 1, 4] numbers.sort()  # API call to sort the list  fruits = [\"apple\", \"banana\"] fruits.append(\"orange\")  # API call to add an element  fruits.pop()  # API call to remove the last element</code></pre><p>Instead of writing sorting algorithms from scratch, developers can use  or  in Python.</p><p>Code APIs are not just limited to built-in programming language functions. Take , an AI/ML library. It provides a  for training machine learning models without needing to implement complex mathematical operations from scratch.</p><p>For example, creating a  using TensorFlow's API is as simple as:</p><pre><code>import tensorflow as tf model = tf.keras.Sequential([tf.keras.layers.Dense(64, activation=\"relu\")])</code></pre><p>Programming APIs abstract away complexity so that developers can focus on building solutions rather than reinventing the wheel.</p><p>APIs communicate using different <strong>protocols and architectures</strong> that define how requests are sent, how responses are formatted, and how data is exchanged between systems.</p><h3>1. REST (Representational State Transfer)</h3><p>REST is the most widely used API communication method today. It is <strong>lightweight, stateless, and scalable</strong>, making it perfect for web services and mobile applications. </p><p>REST APIs follow a set of design principles and use  (GET, POST, PUT, DELETE) to perform operations.</p><p>REST APIs are based on , and each resource is accessed through a . The API follows the , meaning the client sends a request, and the server processes it and sends a response.</p><h4>Example: REST API for a Bookstore</h4><p><strong>Retrieve a list of books (GET Request):</strong></p><pre><code>GET https://api.bookstore.com/books</code></pre><pre><code>[   { \"id\": 1, \"title\": \"Clean Code\", \"author\": \"Robert C. Martin\" },   { \"id\": 2, \"title\": \"The Pragmatic Programmer\", \"author\": \"Andrew Hunt\" } ]</code></pre><h3>2. SOAP (Simple Object Access Protocol)</h3><p>SOAP is an older API communication method that <strong>relies on XML-based messaging</strong>. </p><p>Unlike REST, which is lightweight, SOAP is more structured and secure, making it ideal for banking, healthcare, and enterprise applications.</p><p>SOAP messages are sent using  and require a <strong>WSDL (Web Services Description Language) file</strong>, which defines the API's available functions and request structure.</p><h4><strong>Example: SOAP API for a Banking Service</strong></h4><p> Fetching account balance</p><pre><code>&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:bank=\"http://bank.example.com/\"&gt;    &lt;soapenv:Header/&gt;    &lt;soapenv:Body&gt;       &lt;bank:GetAccountBalance&gt;          &lt;bank:accountNumber&gt;123456&lt;/bank:accountNumber&gt;       &lt;/bank:GetAccountBalance&gt;    &lt;/soapenv:Body&gt; &lt;/soapenv:Envelope&gt; </code></pre><pre><code>&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;    &lt;soapenv:Body&gt;       &lt;bank:GetAccountBalanceResponse&gt;          &lt;bank:balance&gt;5000.00&lt;/bank:balance&gt;       &lt;/bank:GetAccountBalanceResponse&gt;    &lt;/soapenv:Body&gt; &lt;/soapenv:Envelope&gt;</code></pre><p>GraphQL is an alternative to REST that <strong>allows clients to request exactly the data they need</strong>, making it more efficient for modern applications. Unlike REST, which requires multiple API calls to fetch related data, GraphQL can <strong>fetch all necessary data in a single request</strong>.</p><p>Instead of predefined endpoints, GraphQL exposes a , and the client sends queries to request specific fields.</p><h4>Example: Fetching a user's profile and their recent posts in a single request.</h4><pre><code>{   user(id: 123) {     name     email     posts {       title       likes     }   } }</code></pre><pre><code>{   \"data\": {     \"user\": {       \"name\": \"Alice\",       \"email\": \"alice@example.com\",       \"posts\": [         { \"title\": \"Hello World\", \"likes\": 100 },         { \"title\": \"GraphQL is Amazing!\", \"likes\": 200 }       ]     }   } }</code></pre><p>gRPC (Google Remote Procedure Call) is a <strong>high-performance API communication method</strong> that uses <strong>Protocol Buffers (Protobuf)</strong> instead of JSON or XML, making it faster and more efficient.</p><p>gRPC uses  instead of text-based formats, reducing payload size and it supports , meaning the client and server can send data at the same time.</p><p>Using an API might seem complex at first, but it follows a simple  pattern.</p><p>Here’s a guide on<strong> how to find, access, and interact with an API</strong> step by step:</p><h3><strong>Step 1: Find an API to Use</strong></h3><p>Before using an API, you need to  for your needs. APIs are available for different services like weather data, finance, social media, etc.</p><p><strong>Official API Documentation:</strong></p><h3><strong>Step 2: Read the API Documentation</strong></h3><p>API documentation explains <strong>how to use the API, available endpoints, authentication, and response formats</strong>.</p><p>The OpenWeatherMap API allows users to fetch real-time weather data. Here's a breakdown of its key components:</p><pre><code>https://api.openweathermap.org/data/3.0/weather?q=city_name&amp;appid=YOUR_API_KEY</code></pre><ul><li><p>: City name (e.g., )</p></li><li><p>: API Key (required for access)</p></li></ul><h3><strong>Step 3: Get API Access (API Key / Authentication)</strong></h3><p>Most APIs  to prevent unauthorized access and manage usage limits.</p><h4><strong>Common Authentication Methods:</strong></h4><ul><li><p>A unique key provided by the API service</p></li><li><p>Secure login via Google, Github, etc.</p></li><li><p>Token-based authentication</p></li><li><p>Username + password (Base64 encoded)</p></li></ul><p><strong>Example: Getting an API Key (OpenWeather API)</strong></p><ul><li><p>Sign up at https://home.openweathermap.org/users/sign_up.</p></li><li><p>Go to the  section and generate a key.</p></li><li><p>Use the API key in requests:</p></li></ul><pre><code>GET https://api.openweathermap.org/data/2.5/weather?q=London&amp;appid=YOUR_API_KEY</code></pre><h3><strong>Step 4: Test the API Using Postman or cURL</strong></h3><p>Before writing code,  to see how it responds.</p><h4><strong>Option 1: Using Postman (Recommended for Beginners)</strong></h4><ul><li><p>Click , enter the API endpoint URL (<code>https://api.openweathermap.org/data/3.0/weather?q=London&amp;appid=YOUR_API_KEY</code>).</p></li><li><p>Select  as the HTTP method.</p></li><li><p>Click  and view the response in .</p></li></ul><h4><strong>Option 2: Using cURL (For Command Line Users)</strong></h4><p>You can also test APIs directly from the  using .</p><pre><code>curl -X GET \"https://api.openweathermap.org/data/3.0/weather?q=New+York&amp;appid=YOUR_API_KEY\"</code></pre><h3><strong>Step 5: Write Code to Call the API</strong></h3><p>Now that you’ve tested the API, it’s time to <strong>integrate it into your application</strong>.</p><h4><strong>Example: Calling an API in Python</strong></h4><pre><code>import requests  url = \"https://api.openweathermap.org/data/3.0/weather?q=New York&amp;appid=YOUR_API_KEY\" response = requests.get(url)  if response.status_code == 200:     data = response.json()     print(f\"Temperature: {data['main']['temp']}°C\") else:     print(\"Error:\", response.status_code)</code></pre><ul><li><p> – Sends an API request.</p></li><li><p> – Converts response to JSON.</p></li><li><p><code>if response.status_code == 200</code> – Checks if the request was successful.</p></li></ul><h3><strong>Step 6: Handle Errors &amp; Rate Limits</strong></h3><p>APIs <strong>don’t always return perfect responses</strong>. You should handle:</p><ul><li><p> (e.g., wrong city name).</p></li><li><p> (e.g., expired API keys).</p></li><li><p> (e.g., exceeding request limits).</p></li></ul><h4><strong>Example: Handling API Errors in Python</strong></h4><pre><code>if response.status_code == 200:     data = response.json()     print(f\"Weather: {data['weather'][0]['description']}\") elif response.status_code == 401:     print(\"Error: Invalid API key\") elif response.status_code == 404:     print(\"Error: City not found\") else:     print(f\"Unexpected error: {response.status_code}\")</code></pre><h3>Step 7: Use API Responses in Your Application</h3><p>Once you fetch data from an API, you can <strong>display it dynamically in a web or mobile app</strong>.</p><p> You can build a weather dashboard using the OpenWeatherMap API.</p><ul><li><p>Fetch live weather data from the API.</p></li><li><p>Parse and extract relevant details (temperature, humidity, condition).</p></li><li><p>Display the weather report in a user-friendly format.</p></li></ul><p>If you found it valuable, hit a like ❤️ and consider subscribing for more such content every week.</p><p>If you have any questions or suggestions, leave a comment.</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/scalability?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&amp;token=eyJ1c2VyX2lkIjo4MzYwMjc0MywicG9zdF9pZCI6MTQwMDc4MDk0LCJpYXQiOjE3Mzc1MzgxODMsImV4cCI6MTc0MDEzMDE4MywiaXNzIjoicHViLTIyMDIyNjgiLCJzdWIiOiJwb3N0LXJlYWN0aW9uIn0.xroFXQDDEPvo2FWnnt-G2Ji9MzYIDtJ68NRQX6sT8x8&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>This post is public so feel free to share it.</p></div></div><p> If you’re finding this newsletter helpful and want to get even more value, consider becoming a .</p><p>I hope you have a lovely day!</p>","contentLength":12963,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/ae14a376-92a3-4ff6-a329-8e4f2a7ac9b5_1546x1074.png","enclosureMime":"","commentsUrl":null},{"title":"System Design Interviews were HARD Until I Learned these 15 Tips","url":"https://blog.algomaster.io/p/system-design-interview-tips","date":1737001843,"author":"Ashish Pratap Singh","guid":721,"unread":true,"content":"<p>When I started preparing for  for the first time in 2019, I felt completely overwhelmed. It wasn’t a subject covered in college, and I had no prior experience building scalable systems.</p><p>But, over time, I realized that <strong>you don’t need professional experience with distributed systems to pass system design interviews</strong>.</p><p>Even experienced engineers often find these interviews challenging because the format is unique and requires a specific approach.</p><p>The good news is that once you understand the , the , and , and learn how to connect them effectively, system design interviews become far less intimidating.</p><p>In this article, I’ll share  that improved my system design interview skills and made it significantly easier—and hopefully, they’ll do the same for you.</p><p>In a system design interview, the interviewer evaluates your ability to , , and .</p><p>Here’s what they are looking for:</p><ul><li><p> Can you ask the right questions to clarify functional and non-functional requirements?</p></li><li><p> Can you outline the main components of the system (e.g., clients, APIs, databases, caching, load balancers) and explain how they interact?</p></li></ul><ul><li><p> Can your design handle increased traffic or scale with user growth? </p></li><li><p> Can you address single points of failure and ensure fault tolerance?</p></li><li><p> Can you explain the pros and cons of your decisions and justify your choices?</p></li><li><p> Can you dive into the details of critical components (e.g., database schema, caching strategy, API design)?</p></li><li><p><strong>Bottlenecks and Edge Cases:</strong> Can you identify potential issues and propose strategies to mitigate them?</p></li><li><p> Can you articulate your ideas clearly and engage in a constructive discussion with the interviewer?</p></li><li><p> Are you receptive to feedback and able to refine your design?</p></li><li><p> Can you manage your time effectively and focus on high-impact components?</p></li><li><p> Are you familiar with common system design patterns (e.g., sharding, replication, caching)?</p></li><li><p> Can you discuss tools or technologies relevant to the problem?</p></li></ul><p>System design interviews typically last , which means managing your time effectively is crucial.</p><p>A well-structured approach ensures you cover all key aspects of the design while leaving room for discussion and feedback with the interviewer.</p><p>Here’s a framework you can follow:</p><ol><li><p><strong>Clarifying Requirements (5-10 minutes):</strong> Understand functional and non-functional needs.</p></li><li><p><strong>High-Level Design (10-15 minutes): </strong>Outline the system's main components and overall architecture (e.g., clients, database, cache, load balancer, messaging queues).</p></li><li><p><strong>Database Design (5-8 minutes): </strong>Choose the appropriate database type (SQL, NoSQL, or hybrid). Define schemas and discuss partitioning, indexing, replication, and caching.</p></li><li><p><strong>API Design (5-8 minutes): </strong>Define intuitive and scalable APIs. List critical endpoints and their purpose.</p></li><li><p><strong>Deep Dive into Key Components (15-20 minutes): </strong>Discuss 2-3 critical components in detail.</p></li><li><p><strong>Handling Trade-Offs and Edge Cases (5-10 minutes): </strong>Highlight trade-offs, bottlenecks, and failure handling. Propose mitigation strategies.</p></li><li><p><strong>Address scalability, security and monitoring (5-10 minutes): </strong>Explain how your design handles growth, ensures security, and incorporates monitoring.</p></li></ol><p>You can adjust this framework based on the problem type and requirements.</p><blockquote><p>I haven’t included  here but I recommend minimal capacity estimation at the start to set context (e.g., \"The system will handle 1 million requests per day\").</p><p>Avoid detailed calculations unless explicitly required. You don’t want to waste your precious time doing unnecessary maths calculation.</p></blockquote><p>A common mistake many candidates make is jumping directly into designing the system without fully understanding what needs to be built.</p><p>System design questions are intentionally  and often underspecified. Interviewers deliberately withhold details, expecting you to ask the right questions to uncover the information you need.</p><p>To succeed, start by clarifying the —the  and  the system must support.</p><p>At this stage, avoid thinking about design, implementation, or technical specifics. The primary goal is to define  needs to be built, not  to build it or the scale it needs to support. Focus purely on understanding the \"what.\"</p><p>Based on the problem, list down the core features and use cases and confirm them with the interviewer.</p><ul><li><p>What specific features does the system need?</p></li><li><p>Are there any must-have or optional features?</p></li><li><p>What are the main objects and their relations?</p></li><li><p>How the objects will interact with each other and access pattern?</p></li><li><p>Can the system’s objects be modified after creation?</p></li><li><p>What types of data will the system handle?</p></li></ul><p> For a chat application:</p><ul><li><p>Users should be able to send and receive messages.</p></li><li><p>The primary objects are users and messages.</p></li><li><p>Users should view all messages in chronological order.</p></li><li><p>Messages may be edited or deleted after being sent.</p></li><li><p>Messages may include text, images, and videos.</p></li></ul><blockquote><p>Your aim is to ask just enough questions to gather a clear picture of all important use cases for the system.</p></blockquote><p>Once functional requirements are well-defined, shift your focus to <strong>non-functional requirements</strong>.</p><p>These describe  the system should perform its functions.</p><p>The most common non-functional requirements you should consider in a system design interview are:</p><ul><li><p> How quickly should the system respond to user requests?</p></li><li><p> Should the system tolerate downtime? If yes, how much?</p></li><li><p> Is strong or eventual consistency required?</p></li><li><p> Are there any special security considerations or workflows?</p></li></ul><p><strong>Questions to Clarify NFRs:</strong></p><ul><li><p>What is the  of the system?</p><ul><li><p>How many users should it support?</p></li><li><p>How many requests per second should the server handle?</p></li></ul></li><li><p>Is  acceptable? What is the cost of downtime for this system?</p></li><li><p>Is the system  or ? What is the read-to-write ratio?</p></li><li><p>Should updates be visible to users instantly, or is a delay acceptable?</p></li><li><p>Are there any specific  concerns?</p><ul><li><p> Are there workflows involving sensitive data or code execution?</p></li></ul></li></ul><p> For a chat application:</p><ul><li><p> 1 million daily active users, with up to 10,000 concurrent users per server.</p></li><li><p> Aim for 99.99% uptime (no more than ~52 minutes of downtime per year).</p></li><li><p> High read volume as users fetch messages frequently compared to writing messages.</p></li><li><p> Messages should appear in real-time for recipients.</p></li></ul>","contentLength":6052,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/6fd079d4-c3d6-4552-8135-db0501c292e3_1566x1124.png","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}